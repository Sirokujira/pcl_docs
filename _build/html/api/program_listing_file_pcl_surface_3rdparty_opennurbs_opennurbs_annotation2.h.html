

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_annotation2.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_arc.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_arc.h.html" />
    <link rel="prev" title="File opennurbs_annotation2.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_annotation2.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_annotation2.h.html">File opennurbs_annotation2.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_annotation2.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_annotation2.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-annotation2-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-annotation2-h"></span><h1>Program Listing for File opennurbs_annotation2.h<a class="headerlink" href="#program-listing-for-file-opennurbs-annotation2-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_annotation2.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-annotation2-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_annotation2.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="cp">#pragma once</span>

<span class="cp">#if defined(ON_OS_WINDOWS_GDI)</span>

<span class="cp">#define ON_RECT RECT</span>

<span class="cp">#else</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagON_RECT</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">top</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">right</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">bottom</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ON_RECT</span><span class="p">;</span>

<span class="cp">#endif</span>


<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_Annotation2Text</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_wString</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_Annotation2Text</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_Annotation2Text</span><span class="p">();</span>

  <span class="c1">// 24 Sep 2010 Dale Lear</span>
  <span class="c1">//    None of these were implmented and they don&#39;t make any sense.</span>
  <span class="c1">//    ON_Annotation2Text is derived from ON_wString, not ON_Object.</span>
  <span class="c1">//    I&#39;m commenting out these functions and it doesn&#39;t break the</span>
  <span class="c1">//    SDK because linking would fail for anybody trying to use</span>
  <span class="c1">//    these functions.</span>

  <span class="c1">//////void SetDefaults();</span>
  <span class="c1">//////  // override virtual ON_Object::Dump function</span>
  <span class="c1">//////void Dump( ON_TextLog&amp; text_log ) const;</span>
  <span class="c1">//////// override virtual ON_Object::Dump function</span>
  <span class="c1">//////unsigned int SizeOf() const;</span>
  <span class="c1">//////// override virtual ON_Object::Write function</span>
  <span class="c1">//////ON_BOOL32 Write(ON_BinaryArchive&amp; binary_archive) const;</span>
  <span class="c1">//////// override virtual ON_Object::Read function</span>
  <span class="c1">//////ON_BOOL32 Read(ON_BinaryArchive&amp; binary_archive);</span>
  <span class="c1">//////// override virtual ON_UserData::GetDescription function</span>
  <span class="c1">//////ON_BOOL32 GetDescription( ON_wString&amp; description );</span>
  <span class="c1">//////// override virtual ON_UserData::Archive function</span>
  <span class="c1">//////ON_BOOL32 Archive() const;</span>



  <span class="n">ON_Annotation2Text</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
  <span class="n">ON_Annotation2Text</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">SetText</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span> <span class="p">);</span>
  <span class="kt">void</span> <span class="nf">SetText</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">s</span> <span class="p">);</span>

  <span class="c1">// m_rect is a Windows gdi RECT that bounds text</span>
  <span class="c1">// (&quot;x&quot; increases to the right and &quot;y&quot; increases downwards).</span>
  <span class="c1">// If all fields are 0, then m_rect is not set.</span>
  <span class="c1">// If left &lt; right and top &lt; bottom, then the rect bounds</span>
  <span class="c1">// the text when it is drawn with its font&#39;s</span>
  <span class="c1">// lfHeight=ON_Font::normal_font_height and (0,0) left baseline</span>
  <span class="c1">// point of the leftmost character on the first line</span>
  <span class="c1">// of text. If (x,y) is a point on the drawn text, then</span>
  <span class="c1">// left &lt;= x &lt; right and top &lt;= y &lt; bottom.</span>
  <span class="n">ON_RECT</span> <span class="n">m_rect</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Extension to ON_TextEntity added 12/10/2009 for Text background drawing</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_TextExtra</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_UserData</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_TextExtra</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>

  <span class="n">ON_TextExtra</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_TextExtra</span><span class="p">();</span>

  <span class="k">static</span>
  <span class="n">ON_TextExtra</span><span class="o">*</span> <span class="nf">TextExtension</span><span class="p">(</span><span class="k">class</span> <span class="nc">ON_TextEntity2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>
  <span class="k">static</span> <span class="k">const</span>
  <span class="n">ON_TextExtra</span><span class="o">*</span> <span class="nf">TextExtension</span><span class="p">(</span><span class="k">const</span> <span class="k">class</span> <span class="nc">ON_TextEntity2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">SetDefaults</span><span class="p">();</span>

  <span class="c1">// override virtual ON_Object::Dump function</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="n">text_log</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// override virtual ON_Object::Dump function</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// override virtual ON_Object::Write function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// override virtual ON_Object::Read function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">);</span>

  <span class="c1">// override virtual ON_UserData::GetDescription function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetDescription</span><span class="p">(</span> <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">description</span> <span class="p">);</span>

  <span class="c1">// override virtual ON_UserData::Archive function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Archive</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_UUID</span> <span class="nf">ParentUUID</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetParentUUID</span><span class="p">(</span> <span class="n">ON_UUID</span> <span class="n">parent_uuid</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">DrawTextMask</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetDrawTextMask</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bDraw</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">MaskColorSource</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetMaskColorSource</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">);</span>

  <span class="n">ON_Color</span> <span class="nf">MaskColor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// Only works right if MaskColorSource returns 2.</span>
                               <span class="c1">// Does not return viewport background color</span>
  <span class="kt">void</span> <span class="nf">SetMaskColor</span><span class="p">(</span><span class="n">ON_Color</span> <span class="n">color</span><span class="p">);</span>

  <span class="kt">double</span> <span class="nf">MaskOffsetFactor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetMaskOffsetFactor</span><span class="p">(</span><span class="kt">double</span> <span class="n">offset</span><span class="p">);</span>

  <span class="n">ON_UUID</span>  <span class="n">m_parent_uuid</span><span class="p">;</span>    <span class="c1">// uuid of the text using this extension</span>

  <span class="kt">bool</span>     <span class="n">m_bDrawMask</span><span class="p">;</span>      <span class="c1">// do or don&#39;t draw a mask</span>

  <span class="kt">int</span>      <span class="n">m_color_source</span><span class="p">;</span>   <span class="c1">// 0: Use background color from viewport</span>
                             <span class="c1">// 1: Use specific color from m_mask_color</span>

  <span class="n">ON_Color</span> <span class="n">m_mask_color</span><span class="p">;</span>     <span class="c1">// Color to use for mask if m_color_source is 2</span>

  <span class="kt">double</span>   <span class="n">m_border_offset</span><span class="p">;</span>  <span class="c1">// Offset for the border around text to the rectangle used to draw the mask</span>
                             <span class="c1">// This number * HeightOfI for the text is the offset on each side of the</span>
                             <span class="c1">// tight rectangle around the text characters to the mask rectangle.</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_DimensionExtra</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_UserData</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_DimensionExtra</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>

  <span class="n">ON_DimensionExtra</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_DimensionExtra</span><span class="p">();</span>

  <span class="k">static</span>
  <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">(</span><span class="k">class</span> <span class="nc">ON_LinearDimension2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>
  <span class="k">static</span> <span class="k">const</span>
  <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">(</span><span class="k">const</span> <span class="k">class</span> <span class="nc">ON_LinearDimension2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>
  <span class="k">static</span>
  <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">(</span><span class="k">class</span> <span class="nc">ON_RadialDimension2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>
  <span class="k">static</span> <span class="k">const</span>
  <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">(</span><span class="k">const</span> <span class="k">class</span> <span class="nc">ON_RadialDimension2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>
  <span class="k">static</span>
  <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">(</span><span class="k">class</span> <span class="nc">ON_OrdinateDimension2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>
  <span class="k">static</span> <span class="k">const</span>
  <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">(</span><span class="k">const</span> <span class="k">class</span> <span class="nc">ON_OrdinateDimension2</span><span class="o">*</span> <span class="n">pDim</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bCreate</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">SetDefaults</span><span class="p">();</span>

  <span class="c1">// override virtual ON_Object::Dump function</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="n">text_log</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// override virtual ON_Object::Dump function</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// override virtual ON_Object::Write function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// override virtual ON_Object::Read function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">);</span>

  <span class="c1">// override virtual ON_UserData::GetDescription function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetDescription</span><span class="p">(</span> <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">description</span> <span class="p">);</span>

  <span class="c1">// override virtual ON_UserData::Archive function</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Archive</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_UUID</span> <span class="nf">ParentUUID</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetParentUUID</span><span class="p">(</span> <span class="n">ON_UUID</span> <span class="n">parent_uuid</span><span class="p">);</span>

  <span class="c1">//  0: default position</span>
  <span class="c1">//  1: force inside</span>
  <span class="c1">// -1: force outside</span>
  <span class="kt">int</span> <span class="nf">ArrowPosition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetArrowPosition</span><span class="p">(</span> <span class="kt">int</span> <span class="n">position</span><span class="p">);</span>

  <span class="c1">// For a dimension in page space that measures between points in model space</span>
  <span class="c1">// of a detail view, this is the ratio of the page distance / model distance.</span>
  <span class="c1">// When the dimension text is displayed, the distance measured in model space</span>
  <span class="c1">// is multiplied by this number to get the value to display.</span>
  <span class="kt">double</span> <span class="nf">DistanceScale</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetDistanceScale</span><span class="p">(</span><span class="kt">double</span> <span class="n">s</span><span class="p">);</span>

  <span class="c1">// Basepont in modelspace coordinates for ordinate dimensions</span>
  <span class="kt">void</span> <span class="nf">SetModelSpaceBasePoint</span><span class="p">(</span><span class="n">ON_3dPoint</span> <span class="n">basepoint</span><span class="p">);</span>
  <span class="n">ON_3dPoint</span> <span class="nf">ModelSpaceBasePoint</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//const wchar_t* ToleranceUpperString() const;</span>
  <span class="c1">//ON_wString&amp; ToleranceUpperString();</span>
  <span class="c1">//void SetToleranceUpperString( const wchar_t* upper_string);</span>
  <span class="c1">//void SetToleranceUpperString( ON_wString&amp; upper_string);</span>

  <span class="c1">//const wchar_t* ToleranceLowerString() const;</span>
  <span class="c1">//ON_wString&amp; ToleranceLowerString();</span>
  <span class="c1">//void SetToleranceLowerString( const wchar_t* lower_string);</span>
  <span class="c1">//void SetToleranceLowerString( ON_wString&amp; lower_string);</span>

  <span class="c1">//const wchar_t* AlternateString() const;</span>
  <span class="c1">//ON_wString&amp; AlternateString();</span>
  <span class="c1">//void SetAlternateString( const wchar_t* alt_string);</span>
  <span class="c1">//void SetAlternateString( ON_wString&amp; alt_string);</span>

  <span class="c1">//const wchar_t* AlternateToleranceUpperString() const;</span>
  <span class="c1">//ON_wString&amp; AlternateToleranceUpperString();</span>
  <span class="c1">//void SetAlternateToleranceUpperString( const wchar_t* upper_string);</span>
  <span class="c1">//void SetAlternateToleranceUpperString( ON_wString&amp; upper_string);</span>

  <span class="c1">//const wchar_t* AlternateToleranceLowerString() const;</span>
  <span class="c1">//ON_wString&amp; AlternateToleranceLowerString();</span>
  <span class="c1">//void SetAlternateToleranceLowerString( const wchar_t* lower_string);</span>
  <span class="c1">//void SetAlternateToleranceLowerString( ON_wString&amp; lower_string);</span>

  <span class="n">ON_UUID</span> <span class="n">m_partent_uuid</span><span class="p">;</span>  <span class="c1">// the dimension using this extension</span>

  <span class="kt">int</span> <span class="n">m_arrow_position</span><span class="p">;</span>

  <span class="c1">// This is either NULL or an array of GDI rects for the substrings</span>
  <span class="c1">// that make up the dimension string.</span>
  <span class="c1">// If the dimension text is all on the same line, there is just one</span>
  <span class="c1">// rectangle needed to bound the text and that is the same as the</span>
  <span class="c1">// m_rect on the ON_Annotation2Text.</span>
  <span class="c1">// If the dimension has tolerances or for some other reason has more</span>
  <span class="c1">// than one line of text, m_text_rects is an array of 7 rects, one</span>
  <span class="c1">// each for the substrings that might be needed to display the dimension.</span>
  <span class="c1">// If some of the rects aren&#39;t used, they are empty at 0,0</span>
  <span class="c1">// The strings that correspond to these rectangles are generated from</span>
  <span class="c1">// info in the dimstyle</span>
  <span class="n">ON_RECT</span><span class="o">*</span> <span class="n">m_text_rects</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">m_distance_scale</span><span class="p">;</span>
  <span class="n">ON_3dPoint</span> <span class="n">m_modelspace_basepoint</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm">  class ON_Annotation2</span>

<span class="cm">    Description:</span>
<span class="cm">      Used to serialize definitions of annotation objects (dimensions, text, leaders, etc.).</span>
<span class="cm">      Virtual base class for annotation objects</span>
<span class="cm">      Replaces ON_Annotation</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_Annotation2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_Annotation2</span><span class="p">);</span>

  <span class="c1">// UNICODE symbol code to use for degrees, radius, diameter and plus/minus in dimensions</span>
  <span class="k">enum</span> <span class="n">SYMBOLS</span>
  <span class="p">{</span>
    <span class="n">degreesym</span> <span class="o">=</span> <span class="mi">176</span><span class="p">,</span>
    <span class="n">radiussym</span> <span class="o">=</span> <span class="sa">L</span><span class="sc">&#39;R&#39;</span><span class="p">,</span>
    <span class="n">diametersym</span> <span class="o">=</span> <span class="mi">216</span><span class="p">,</span>
    <span class="n">plusminussym</span> <span class="o">=</span> <span class="mi">177</span><span class="p">,</span>
  <span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_Annotation2</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_Annotation2</span><span class="p">();</span>
  <span class="c1">// C++ automatically provides the correct copy constructor and operator= .</span>
  <span class="c1">//ON_Annotation2(const ON_Annotation2&amp;);</span>
  <span class="c1">//ON_Annotation2&amp; operator=(const ON_Annotation2&amp;);</span>

  <span class="c1">// convert from old style annotation</span>
  <span class="n">ON_Annotation2</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Annotation</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_Annotation2</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Annotation</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Sets initial defaults</span>
  <span class="kt">void</span> <span class="nf">Create</span><span class="p">();</span>

  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>

  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// ON_Object overrides</span>
  <span class="c1">//</span>

  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">    Description: Writes the object to a file</span>

<span class="cm">    Returns:</span>
<span class="cm">      @untitled Table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span>
         <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description: Reads the object from a file</span>

<span class="cm">    Returns:</span>
<span class="cm">      @untitled Table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span>
         <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span>
       <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Returns: The Object Type of this object</span>
<span class="cm">  */</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// ON_Geometry overrides</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">    Returns the geometric dimension of the object ( usually 3)</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virtual ON_Geometry::Transform()</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry override</span>
  <span class="kt">bool</span> <span class="nf">EvaluatePoint</span><span class="p">(</span> <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_ObjRef</span><span class="o">&amp;</span> <span class="n">objref</span><span class="p">,</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// ON_Annotation2 interface</span>
  <span class="c1">//</span>

  <span class="c1">// Definitions of text justification</span>
  <span class="c1">// Not implemented on all annotation objects</span>
  <span class="k">enum</span> <span class="n">eTextJustification</span>
  <span class="p">{</span>
    <span class="n">tjUndefined</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">tjLeft</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">tjCenter</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">tjRight</span>  <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">tjBottom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">,</span>
    <span class="n">tjMiddle</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span><span class="p">,</span>
    <span class="n">tjTop</span>    <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">,</span>
    <span class="n">tjBottomLeft</span>   <span class="o">=</span> <span class="n">tjBottom</span> <span class="o">|</span> <span class="n">tjLeft</span><span class="p">,</span>
    <span class="n">tjBottomCenter</span> <span class="o">=</span> <span class="n">tjBottom</span> <span class="o">|</span> <span class="n">tjCenter</span><span class="p">,</span>
    <span class="n">tjBottomRight</span>  <span class="o">=</span> <span class="n">tjBottom</span> <span class="o">|</span> <span class="n">tjRight</span><span class="p">,</span>
    <span class="n">tjMiddleLeft</span>   <span class="o">=</span> <span class="n">tjMiddle</span> <span class="o">|</span> <span class="n">tjLeft</span><span class="p">,</span>
    <span class="n">tjMiddleCenter</span> <span class="o">=</span> <span class="n">tjMiddle</span> <span class="o">|</span> <span class="n">tjCenter</span><span class="p">,</span>
    <span class="n">tjMiddleRight</span>  <span class="o">=</span> <span class="n">tjMiddle</span> <span class="o">|</span> <span class="n">tjRight</span><span class="p">,</span>
    <span class="n">tjTopLeft</span>      <span class="o">=</span> <span class="n">tjTop</span>    <span class="o">|</span> <span class="n">tjLeft</span><span class="p">,</span>
    <span class="n">tjTopCenter</span>    <span class="o">=</span> <span class="n">tjTop</span>    <span class="o">|</span> <span class="n">tjCenter</span><span class="p">,</span>
    <span class="n">tjTopRight</span>     <span class="o">=</span> <span class="n">tjTop</span>    <span class="o">|</span> <span class="n">tjRight</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Query if the annotation object is a text object</span>
<span class="cm">    Parameters:</span>
<span class="cm">      none</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true    It is text</span>
<span class="cm">      false   Its not text</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsText</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Query if the annotation object is a leader</span>
<span class="cm">    Parameters:</span>
<span class="cm">      none</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true    It is a leader</span>
<span class="cm">      false   Its not a leader</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsLeader</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Query if the annotation object is a dimension</span>
<span class="cm">    Parameters:</span>
<span class="cm">      none</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true    It is a dimension</span>
<span class="cm">      false   Its not a dimension</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsDimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set or get the index in the appropriate table for either the font or</span>
<span class="cm">      dimstyle of this object</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] int  the new index (Set)</span>
<span class="cm">    Returns:</span>
<span class="cm">      int -  The index (Get)</span>
<span class="cm">    Remarks:</span>
<span class="cm">      If the object is a text object the index is of object&#39;s font in the Font Table</span>
<span class="cm">      If the object is anything else, the index is of the object&#39;s dimstyle in the DimStyle Table</span>
<span class="cm">      Derived objects can use FontIndex() and StyleIndex() to set/get these same values.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Index</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetIndex</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Dimension type</span>
<span class="cm">    Linear dim:  distance between arrow tips</span>
<span class="cm">    Radial dim:  radius or diameter depending on m_type value</span>
<span class="cm">    Angular dim: angle in degrees</span>
<span class="cm">    Leader:      ON_UNSET_VALUE</span>
<span class="cm">    Text:        ON_UNSET_VALUE</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">double</span> <span class="nf">NumericValue</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set  or Get the height of the text in this annotation</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] double new text height to set</span>
<span class="cm">    Returns:</span>
<span class="cm">      double Height of the text</span>
<span class="cm">    Remarks:</span>
<span class="cm">      Height is in model units</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetHeight</span><span class="p">(</span> <span class="kt">double</span><span class="p">);</span>
  <span class="kt">double</span> <span class="nf">Height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Sets or gets the object type member to a specific annotation type:</span>
<span class="cm">           dtDimLinear, dtDimAligned, dtDimAngular, etc.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] ON::eAnnotationType type - dtDimLinear, dtDimAligned, dtDimAngular, etc.</span>
<span class="cm">    Returns:</span>
<span class="cm">      ON::eAnnotationType of the object</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetType</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">eAnnotationType</span><span class="p">);</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">eAnnotationType</span> <span class="n">Type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set or get the plane for the object&#39;s ECS</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] ON_Plane&amp; plane in WCS</span>
<span class="cm">    Returns:</span>
<span class="cm">      const ON_Plane&amp; - the object&#39;s ECS plane in WCS coords</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetPlane</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">Plane</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Returns the number of definition points this object has</span>
<span class="cm">    Parameters:</span>
<span class="cm">      none</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      int   the object&#39;s point count</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">PointCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetPointCount</span><span class="p">(</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set or get the object&#39;s whole points array at once</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] ON_2dPointArray&amp; pts</span>
<span class="cm">    Returns:</span>
<span class="cm">      const ON_2dPointArray&amp; - ref to the object&#39;s point array</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetPoints</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_2dPointArray</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">ON_2dPointArray</span><span class="o">&amp;</span> <span class="n">Points</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set individual definition points for the annotation</span>
<span class="cm">    Parameters:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      [in] int index               index of the point to set in ECS 2d coordinates</span>
<span class="cm">      [in] const ON_2dPoint&amp; pt    the new point value</span>
<span class="cm">    Returns:</span>
<span class="cm">      ON_2dPoint   the point coordinates in ECS</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetPoint</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_2dPoint</span> <span class="nf">Point</span><span class="p">(</span> <span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>

<span class="cm">      Set or get the string value of the user text, with no substitution for &quot;&lt;&gt;&quot;</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] const wchar_t* string   the new value for UserText</span>
<span class="cm">    Returns:</span>
<span class="cm">      const ON_wString&amp;    The object&#39;s UserText</span>
<span class="cm">    Remarks:</span>
<span class="cm">      UserText is the string that gets printed when the dimensoin is drawn.</span>
<span class="cm">      If it contains the token &quot;&lt;&gt;&quot;, that token is replaced with the measured</span>
<span class="cm">      value for the dimension, formatted according to the DimStyle settings.</span>
<span class="cm">      &quot;&lt;&gt;&quot; is the default for linear dimensions.</span>
<span class="cm">      Other dimensions include &quot;&lt;&gt;&quot; in their default string</span>
<span class="cm">  */</span>

  <span class="c1">// OBSOLETE - call SetTextValue( text_value );</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">void</span> <span class="nf">SetUserText</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">text_value</span> <span class="p">);</span>

  <span class="c1">// OBSOLETE - call TextValue( text_value );</span>
  <span class="n">ON_DEPRECATED</span> <span class="k">const</span> <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">UserText</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Gets the value of the annotation text.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Value of the annotation text.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Annotation2Text::SetTextValue()</span>
<span class="cm">    ON_Annotation2Text::SetTextFormula()</span>
<span class="cm">    ON_Annotation2Text::TextFormula()</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This gets the literal value of the text, there is no</span>
<span class="cm">    substitution for any &quot;&lt;&gt;&quot; substrings.  When a dimension</span>
<span class="cm">    is drawn, any occurance of &quot;&lt;&gt;&quot; will be replaced</span>
<span class="cm">    with the measured value for the dimension and formatted</span>
<span class="cm">    according to the DimStyle settings.</span>

<span class="cm">    Annotation text values can be constant or the result</span>
<span class="cm">    of evaluating text formula containing %&lt;...&gt;%</span>
<span class="cm">    expressions. The ...TextValue() functions set</span>
<span class="cm">    and get the text&#39;s value.  The ...TextFormula()</span>
<span class="cm">    functions get and set the text&#39;s formula.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">TextValue</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets the value of the annotation text.  No changes</span>
<span class="cm">    are made to the text_value string.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_value - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    Value of the annotation text.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Annotation2Text::SetTextFormula()</span>
<span class="cm">    ON_Annotation2Text::TextValue()</span>
<span class="cm">    ON_Annotation2Text::TextFormula()</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Annotation text values can be constant or the result</span>
<span class="cm">    of evaluating text formula containing %&lt;...&gt;%</span>
<span class="cm">    expressions. The ...TextValue() functions set</span>
<span class="cm">    and get the text&#39;s value.  The ...TextFormula()</span>
<span class="cm">    functions get and set the text&#39;s formula.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetTextValue</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">text_value</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Gets the formula for the annotation text.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_value - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    Value of the annotation text.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Annotation2Text::SetTextValue()</span>
<span class="cm">    ON_Annotation2Text::TextValue()</span>
<span class="cm">    ON_Annotation2Text::TextFormula()</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Annotation text values can be constant or the result</span>
<span class="cm">    of evaluating text formula containing %&lt;...&gt;%</span>
<span class="cm">    expressions. The ...TextValue() functions set</span>
<span class="cm">    and get the text&#39;s value.  The ...TextFormula()</span>
<span class="cm">    functions get and set the text&#39;s formula.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">TextFormula</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets the formula for the annotation text.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_value - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    Value of the annotation text.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Annotation2Text::SetTextValue()</span>
<span class="cm">    ON_Annotation2Text::Value()</span>
<span class="cm">    ON_Annotation2Text::Formula()</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Annotation text values can be constant or the result</span>
<span class="cm">    of evaluating text formula containing %&lt;...&gt;%</span>
<span class="cm">    expressions. The ...TextValue() functions set</span>
<span class="cm">    and get the text&#39;s value.  The ...TextFormula()</span>
<span class="cm">    functions get and set the text&#39;s formula.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetTextFormula</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">s</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set or get a flag indication that the dimension text has been moved</span>
<span class="cm">      from the default location.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      bUserPositionedText - [in]</span>
<span class="cm">               true to indicate that the text has been placed by the user.</span>
<span class="cm">               false to indicate that it hasn&#39;t</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true    The text has been moved</span>
<span class="cm">      false   The text is in the default location</span>
<span class="cm">    Remarks:</span>
<span class="cm">      If the text is in the default location, it should be repositioned</span>
<span class="cm">      automatically when the dimension is adjusted.</span>
<span class="cm">      If it has been moved, it should not be automatically positioned.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetUserPositionedText</span><span class="p">(</span> <span class="kt">int</span> <span class="n">bUserPositionedText</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">UserPositionedText</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set or get the text display mode for the annotation</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] ON::eTextDisplayMode mode - new mode to set</span>
<span class="cm">    Returns:</span>
<span class="cm">      ON::eTextDisplayMode  - current mode</span>
<span class="cm">    Remarks:</span>
<span class="cm">      This is the way the text is oriented with respect to the dimension line or screen:</span>
<span class="cm">      Above line, In LIne, Horizontal</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetTextDisplayMode</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">eTextDisplayMode</span><span class="p">);</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">eTextDisplayMode</span> <span class="n">TextDisplayMode</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Gets a transform matrix to change from the object&#39;s 2d ECS to 3d WCS</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [out] xform   set to produce the ECS to WCS transform</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true    Success</span>
<span class="cm">      false   Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetECStoWCSXform</span><span class="p">(</span> <span class="n">ON_Xform</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Gets a transform matrix to change from to 3d WCS to the object&#39;s 2d ECS</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [out] xform - set to produce the WCS to ECS transform</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true    Success</span>
<span class="cm">      false   Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetWCStoECSXform</span><span class="p">(</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set the object&#39;s point array to a specified length</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] length - the new size of the array</span>
<span class="cm">    Returns:</span>
<span class="cm">      void</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">ReservePoints</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      static function to provide the default UserText string for the object</span>
<span class="cm">    Returns:</span>
<span class="cm">      const wchar_t* - the default string to use</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">DefaultText</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Convert back to the version of ON_Annotation used in Rhino 2</span>
<span class="cm">    Parameters:</span>
<span class="cm">      target [out] the old-style object</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true     Success</span>
<span class="cm">      False    Failure</span>
<span class="cm">    See Also:  ON_AngularDimension::ConvertBack()</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">void</span> <span class="nf">ConvertBack</span><span class="p">(</span> <span class="n">ON_Annotation</span><span class="o">&amp;</span> <span class="n">target</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set or Get the text justification</span>
<span class="cm">    Parameters:</span>
<span class="cm">      justification [in] See enum eJustification for meanings</span>
<span class="cm">    Returns:</span>
<span class="cm">      The justification for the text in this object</span>
<span class="cm">    Comments:</span>
<span class="cm">      This is not implemented on all annotation objects.</span>
<span class="cm">      The default SetJustification() does nothing</span>
<span class="cm">      The default Justification() always returns 0</span>

<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">void</span> <span class="nf">SetJustification</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">justification</span><span class="p">);</span>

  <span class="k">virtual</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">Justification</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get the transformation that maps the annotation&#39;s</span>
<span class="cm">      text to world coordinates.</span>
<span class="cm">      Added Oct 30, 07 LW</span>
<span class="cm">    Parameters:</span>
<span class="cm">      gdi_text_rect - [in]</span>
<span class="cm">              Windows gdi rect of text when it is drawn with</span>
<span class="cm">              LOGFONT lfHeight = ON_Font::normal_font_height.</span>
<span class="cm">      gdi_height_of_I - [in]</span>
<span class="cm">         Value returned by ON_Font::HeightOfI().</span>
<span class="cm">      dimstyle_textheight - [in]</span>
<span class="cm">         Height of text in world units.  If the annotation is</span>
<span class="cm">         an ON_TextEntity2, this is the m_textheight value.</span>
<span class="cm">         If the annotation is not an ON_TextEntity2, pass in</span>
<span class="cm">         the value returned by the dimension style&#39;s</span>
<span class="cm">         ON_DimStyle::TextHeight()</span>
<span class="cm">      dimstyle_textgap - [in]</span>
<span class="cm">         The value of the annotation&#39;s dimension style&#39;s</span>
<span class="cm">         ON_DimStyle::TextGap().</span>
<span class="cm">      dimstyle_textalignment - [in]</span>
<span class="cm">         ON::TextDisplayMode(ON_DimStyle::TextAlignment()).</span>
<span class="cm">      dimscale - [in]</span>
<span class="cm">         Global dimension scaling value.  If you are using the</span>
<span class="cm">         Rhino SDK, this value is returned by</span>
<span class="cm">         CRhinoDoc::Properties().AnnotationSettings().DimScale().</span>
<span class="cm">         If you are using the OpenNURBS IO toolkit, this value</span>
<span class="cm">         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.</span>
<span class="cm">      cameraX - [in]</span>
<span class="cm">         zero or the view&#39;s unit camera right vector</span>
<span class="cm">      cameraY - [in]</span>
<span class="cm">         zero or the view&#39;s unit camera up vector</span>
<span class="cm">      model_xform - [in] transforms the text&#39;s parent entity</span>
<span class="cm">         to world coordinates in case its instance geometry</span>
<span class="cm">         NULL == Identity</span>
<span class="cm">      text_xform - [out]</span>
<span class="cm">    Returns:</span>
<span class="cm">      True if text_xform is set.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetTextXform</span><span class="p">(</span>
        <span class="n">ON_RECT</span> <span class="n">gdi_text_rect</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">gdi_height_of_I</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">dimstyle_textheight</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">dimstyle_textgap</span><span class="p">,</span>
        <span class="n">ON</span><span class="o">::</span><span class="n">eTextDisplayMode</span> <span class="n">dimstyle_textalignment</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">dimscale</span><span class="p">,</span>
        <span class="n">ON_3dVector</span> <span class="n">cameraX</span><span class="p">,</span>
        <span class="n">ON_3dVector</span> <span class="n">cameraY</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">model_xform</span><span class="p">,</span>
        <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">text_xform</span> <span class="c1">// output</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>

<span class="cm">    This function has been replaced with a version that</span>
<span class="cm">    takes a model transform to transform block instance</span>
<span class="cm">    geometry to world coordinates  Oct 30, 07 LW</span>

<span class="cm">      Get the transformation that maps the annotation&#39;s</span>
<span class="cm">      text to world coordinates.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      gdi_text_rect - [in]</span>
<span class="cm">              Windows gdi rect of text when it is drawn with</span>
<span class="cm">              LOGFONT lfHeight = ON_Font::normal_font_height.</span>
<span class="cm">      gdi_height_of_I - [in]</span>
<span class="cm">         Value returned by ON_Font::HeightOfI().</span>
<span class="cm">      dimstyle_textheight - [in]</span>
<span class="cm">         Height of text in world units.  If the annotation is</span>
<span class="cm">         an ON_TextEntity2, this is the m_textheight value.</span>
<span class="cm">         If the annotation is not an ON_TextEntity2, pass in</span>
<span class="cm">         the value returned by the dimension style&#39;s</span>
<span class="cm">         ON_DimStyle::TextHeight()</span>
<span class="cm">      dimstyle_textgap - [in]</span>
<span class="cm">         The value of the annotation&#39;s dimension style&#39;s</span>
<span class="cm">         ON_DimStyle::TextGap().</span>
<span class="cm">      dimstyle_textalignment - [in]</span>
<span class="cm">         ON::TextDisplayMode(ON_DimStyle::TextAlignment()).</span>
<span class="cm">      dimscale - [in]</span>
<span class="cm">         Global dimension scaling value.  If you are using the</span>
<span class="cm">         Rhino SDK, this value is returned by</span>
<span class="cm">         CRhinoDoc::Properties().AnnotationSettings().DimScale().</span>
<span class="cm">         If you are using the OpenNURBS IO toolkit, this value</span>
<span class="cm">         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.</span>
<span class="cm">      cameraX - [in]</span>
<span class="cm">         zero or the view&#39;s unit camera right vector</span>
<span class="cm">      cameraY - [in]</span>
<span class="cm">         zero or the view&#39;s unit camera up vector</span>
<span class="cm">      xform - [out]</span>
<span class="cm">    Returns:</span>
<span class="cm">      True if xform is set.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetTextXform</span><span class="p">(</span>
        <span class="n">ON_RECT</span> <span class="n">gdi_text_rect</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">gdi_height_of_I</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">dimstyle_textheight</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">dimstyle_textgap</span><span class="p">,</span>
        <span class="n">ON</span><span class="o">::</span><span class="n">eTextDisplayMode</span> <span class="n">dimstyle_textalignment</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">dimscale</span><span class="p">,</span>
        <span class="n">ON_3dVector</span> <span class="n">cameraX</span><span class="p">,</span>
        <span class="n">ON_3dVector</span> <span class="n">cameraY</span><span class="p">,</span>
        <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get the transformation that maps the annotation&#39;s</span>
<span class="cm">      text to world coordinates.</span>
<span class="cm">      Oct 30, 07 LW</span>
<span class="cm">    Parameters:</span>
<span class="cm">      gdi_text_rect - [in]</span>
<span class="cm">              Windows gdi rect of text when it is drawn with</span>
<span class="cm">              LOGFONT lfHeight = ON_Font::normal_font_height.</span>
<span class="cm">      font - [in]</span>
<span class="cm">      dimstyle - [in]</span>
<span class="cm">      dimscale - [in]</span>
<span class="cm">         Global dimension scaling value.  If you are using the</span>
<span class="cm">         Rhino SDK, this value is returned by</span>
<span class="cm">         CRhinoDoc::Properties().AnnotationSettings().DimScale().</span>
<span class="cm">         If you are using the OpenNURBS IO toolkit, this value</span>
<span class="cm">         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.</span>
<span class="cm">      vp - [in]</span>
<span class="cm">      model_xform - [in] transforms the text&#39;s parent entity</span>
<span class="cm">         to world coordinates in case its instance geometry</span>
<span class="cm">         NULL == Identity</span>
<span class="cm">      text_xform - [out]</span>
<span class="cm">    Returns:</span>
<span class="cm">      True if text_xform is set.</span>
<span class="cm">  */</span>
  <span class="c1">//bool GetTextXform(</span>
  <span class="c1">//    const ON_RECT gdi_text_rect,</span>
  <span class="c1">//    const ON_Font&amp; font,</span>
  <span class="c1">//    const ON_DimStyle&amp; dimstyle,</span>
  <span class="c1">//    double dimscale,</span>
  <span class="c1">//    const ON_Viewport* vp,</span>
  <span class="c1">//    const ON_Xform* model_xform,</span>
  <span class="c1">//    ON_Xform&amp; text_xform  // output</span>
  <span class="c1">//    ) const;</span>
  <span class="kt">bool</span> <span class="nf">GetTextXform</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ON_RECT</span> <span class="n">gdi_text_rect</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Font</span><span class="o">&amp;</span> <span class="n">font</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_DimStyle</span><span class="o">*</span> <span class="n">dimstyle</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">dimscale</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Viewport</span><span class="o">*</span> <span class="n">vp</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">model_xform</span><span class="p">,</span>
      <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">text_xform</span>  <span class="c1">// output</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>

<span class="cm">    This function has been replaced with a version that</span>
<span class="cm">    takes a model transform because the viewport doesn&#39;t</span>
<span class="cm">    contain block instance transform info  Oct 30, 07 LW</span>

<span class="cm">      Get the transformation that maps the annotation&#39;s</span>
<span class="cm">      text to world coordinates.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      gdi_text_rect - [in]</span>
<span class="cm">              Windows gdi rect of text when it is drawn with</span>
<span class="cm">              LOGFONT lfHeight = ON_Font::normal_font_height.</span>
<span class="cm">      font - [in]</span>
<span class="cm">      dimstyle - [in]</span>
<span class="cm">      dimscale - [in]</span>
<span class="cm">         Global dimension scaling value.  If you are using the</span>
<span class="cm">         Rhino SDK, this value is returned by</span>
<span class="cm">         CRhinoDoc::Properties().AnnotationSettings().DimScale().</span>
<span class="cm">         If you are using the OpenNURBS IO toolkit, this value</span>
<span class="cm">         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.</span>
<span class="cm">      vp - [in]</span>
<span class="cm">      xform - [out]</span>
<span class="cm">    Returns:</span>
<span class="cm">      True if xform is set.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetTextXform</span><span class="p">(</span>
      <span class="n">ON_RECT</span> <span class="n">gdi_text_rect</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Font</span><span class="o">&amp;</span> <span class="n">font</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_DimStyle</span><span class="o">&amp;</span> <span class="n">dimstyle</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">dimscale</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Viewport</span><span class="o">*</span> <span class="n">vp</span><span class="p">,</span>
      <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the annotation plane coordinates (ECS) of the point</span>
<span class="cm">    that is used to position the text.  The relative position</span>
<span class="cm">    of the text to this points depends on the type of</span>
<span class="cm">    annotation, the dimstyle&#39;s text alignment flag, and the</span>
<span class="cm">    view projection.</span>
<span class="cm">    This point is not  the same as the base point of the text.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_point - [out];</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if text_point is set.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetTextPoint</span><span class="p">(</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="n">text_2d_point</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// enum for tyoe of annotation DimLinear, DimRadius, etc.</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">eAnnotationType</span> <span class="n">m_type</span><span class="p">;</span>

  <span class="c1">// m_textdisplaymode controls the orientation</span>
  <span class="c1">// of the text.</span>
  <span class="c1">// If m_textdisplaymode = dtHorizontal, then</span>
  <span class="c1">// the text is always horizontal and in the</span>
  <span class="c1">// view plane.  Otherwise it lies in m_plane.</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">eTextDisplayMode</span> <span class="n">m_textdisplaymode</span><span class="p">;</span>

  <span class="c1">// m_plane is the plane containing the annotation.</span>
  <span class="c1">// All parts of the annotation that are not</span>
  <span class="c1">// text lie in this plane. If</span>
  <span class="c1">// m_textdisplaymode != dtHorizontal, then</span>
  <span class="c1">// the text lies in the plane too.</span>
  <span class="c1">// (ECS reference plane in WCS coordinates.)</span>
  <span class="n">ON_Plane</span> <span class="n">m_plane</span><span class="p">;</span>

  <span class="c1">// Definition points for the dimension.</span>
  <span class="c1">// These are 2d coordinates in m_plane.</span>
  <span class="c1">// The location of these points depends on the</span>
  <span class="c1">// type of annotation class.  There is a comment</span>
  <span class="c1">// at the start of the definions for</span>
  <span class="c1">// ON_LinearDimension2, ON_RadialDimension2,</span>
  <span class="c1">// ON_AngularDimension2, ON_TextEntity2, and</span>
  <span class="c1">// ON_Leader2 that explains how the points are used.</span>
  <span class="n">ON_2dPointArray</span> <span class="n">m_points</span><span class="p">;</span>

  <span class="c1">// With the addition of tolerances and therefore multi-line</span>
  <span class="c1">// text, the ON_wString in m_usertext will hold multiple</span>
  <span class="c1">// strings with NULLs between them.</span>
  <span class="c1">// The strings will be in this order:</span>
  <span class="c1">// Result of expanding &quot;&lt;&gt;&quot;, or user override</span>
  <span class="c1">// Alternate dimension</span>
  <span class="c1">// Tolerance upper</span>
  <span class="c1">// Tolerance lower</span>
  <span class="c1">// Alt tolerance upper</span>
  <span class="c1">// Alt tolerance lower</span>
  <span class="c1">// Prefix</span>
  <span class="c1">// Suffix</span>
  <span class="c1">// Alt prefix</span>
  <span class="c1">// Alt suffix</span>
  <span class="c1">//</span>
  <span class="n">ON_Annotation2Text</span> <span class="n">m_usertext</span><span class="p">;</span>

  <span class="c1">// true: User has positioned text</span>
  <span class="c1">// false: use default location</span>
  <span class="kt">bool</span> <span class="n">m_userpositionedtext</span><span class="p">;</span>
  <span class="c1">// Added 13 Aug, 2010 - Lowell</span>
  <span class="c1">// This determines whether the object will be scaled according to detail</span>
  <span class="c1">// scale factor or by 1.0 in paperspace rather than by</span>
  <span class="c1">// dimscale or text scale.</span>
  <span class="c1">// For the first try this will only be used on text and its</span>
  <span class="c1">// here on the base class because it would fit and in case</span>
  <span class="c1">// its needed later on dimensions.</span>
  <span class="kt">bool</span> <span class="n">m_annotative_scale</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">m_reserved_b1</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">m_reserved_b2</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>

  <span class="c1">// For dimensions, this is the ON_DimStyle index</span>
  <span class="c1">// For text, its the ON_Font index</span>
  <span class="kt">int</span> <span class="n">m_index</span><span class="p">;</span>

  <span class="c1">// Text height in model units</span>
  <span class="c1">// This is used by text, but not by dimensions</span>
  <span class="c1">// Dimensions get their height from dimension styles</span>
  <span class="kt">double</span> <span class="n">m_textheight</span><span class="p">;</span>

  <span class="c1">// Left, Center, Right / Bottom, Middle, Top text justification</span>
  <span class="c1">// See eTextJustification above</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_justification</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Subclass of ON_Annotation2 to provide linear dimensions</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_LinearDimension2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Annotation2</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_LinearDimension2</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">    The annotation&#39;s dimstyle controls the position of TEXT,</span>
<span class="cm">    the size of the arrowheads, and the amount the ends of</span>
<span class="cm">    linear dimension&#39;s extension lines extend beyond the</span>
<span class="cm">    dimension lines.</span>

<span class="cm">    In the picture below, [n] means ON_Annotation2::m_points[n].</span>

<span class="cm">                                                     [2]</span>
<span class="cm">                                                      |</span>
<span class="cm">        |                                             |</span>
<span class="cm">       [1]-------------------------------------------[3]</span>
<span class="cm">        |                                             |</span>
<span class="cm">        |                       TEXT</span>
<span class="cm">        |                       [4]</span>
<span class="cm">       [0]</span>

<span class="cm">      The &quot;x&quot; and &quot;y&quot; coordinates of [0] must be (0.0, 0.0).</span>

<span class="cm">      The &quot;x&quot; coordinate of [1] = &quot;x&quot; of [0]</span>
<span class="cm">      The &quot;y&quot; coordinate of [1] can be any value.</span>

<span class="cm">      The &quot;x&quot; and &quot;y&quot; coordinates of [2] can be any value.</span>

<span class="cm">      The &quot;x&quot; coordinate of [3] = &quot;x&quot; coordinate of [2].</span>
<span class="cm">      The &quot;y&quot; coordinate of [3] = &quot;y&quot; coordinate of [1].</span>
<span class="cm">  */</span>

  <span class="k">enum</span> <span class="n">POINT_INDEX</span>
  <span class="p">{</span>
    <span class="c1">// Do not change these enum values.  They are saved in files as the</span>
    <span class="c1">// ON_COMPONENT_INDEX.m_index value.</span>
    <span class="c1">//</span>
    <span class="c1">// Indices of linear dimension definition points in</span>
    <span class="c1">// the m_points[] array</span>
    <span class="n">ext0_pt_index</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// end of first extension line</span>
    <span class="n">arrow0_pt_index</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// arrowhead tip on first extension line</span>
    <span class="n">ext1_pt_index</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// end of second extension line</span>
    <span class="n">arrow1_pt_index</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// arrowhead tip on second extension line</span>
    <span class="n">userpositionedtext_pt_index</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">dim_pt_count</span>     <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="c1">// number of m_points[] in an angular dim</span>

    <span class="c1">// Points calculated from values in m_points[]</span>
    <span class="n">text_pivot_pt</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="c1">// center of dimension text</span>
    <span class="n">dim_mid_pt</span>    <span class="o">=</span> <span class="mi">10001</span>  <span class="c1">// midpoint of dimension line</span>
  <span class="p">};</span>

  <span class="n">ON_LinearDimension2</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_LinearDimension2</span><span class="p">();</span>
  <span class="c1">// C++ automatically provides the correct copy constructor and operator= .</span>
  <span class="c1">//ON_LinearDimension2( const ON_LinearDimension2&amp; );</span>
  <span class="c1">//ON_LinearDimension2&amp; operator=(const ON_LinearDimension2&amp;);</span>

  <span class="c1">// overrides virtual ON_Geometry::Transform()</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Checks the linear dimension and repairs any point locations or flags</span>
<span class="cm">    that are not set correctly.</span>
<span class="cm">  Returns:</span>
<span class="cm">    0:  linear dimension is damaged beyond repair</span>
<span class="cm">    1:  linear dimension was perfect and nothing needed to be repaired.</span>
<span class="cm">    2:  linear dimension had flaws that were repaired.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Repair</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_2dPoint</span> <span class="nf">Dim2dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Dim3dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::IsValid</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Write</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Read</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// overrides virual ON_Geometry::GetBBox</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetTightBoundingBox</span>
  <span class="kt">bool</span> <span class="nf">GetTightBoundingBox</span><span class="p">(</span>
      <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">tight_bbox</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">xform</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Overrides virtual ON_Annotation2::NumericValue();</span>
<span class="cm">  Returns:</span>
<span class="cm">    distance between arrow tips</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">NumericValue</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or set the DimStyle index in the dimstyle table for the dimension</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] int  the new index (Set)</span>
<span class="cm">    Returns:</span>
<span class="cm">      int -  The current index (Get)</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">StyleIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetStyleIndex</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      static function to provide the default UserText string for the object</span>
<span class="cm">    Returns:</span>
<span class="cm">      const wchar_t* - the default string to use</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">DefaultText</span><span class="p">();</span>


<span class="c1">// 6-23-03 lw Added v2 file writing of annotation</span>
  <span class="kt">void</span> <span class="nf">GetV2Form</span><span class="p">(</span> <span class="n">ON_LinearDimension</span><span class="o">&amp;</span> <span class="n">dim</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">CreateFromV2</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ON_Annotation</span><span class="o">&amp;</span> <span class="n">v2_ann</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_3dmAnnotationSettings</span><span class="o">&amp;</span> <span class="n">settings</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">dimstyle_index</span>
      <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the annotation plane x coordinates of the dimension</span>
<span class="cm">    line. The y coordinate of the dimension line is m_ponts[1].y.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    gdi_text_rect - [in]</span>
<span class="cm">       Windows rect (left &lt; right, top &lt; bottom) that bounds text.</span>
<span class="cm">       The baseline of the text should be at y=0 in the rect coordinates.</span>
<span class="cm">    gdi_height_of_I - [in]</span>
<span class="cm">       Height of an I in the text in the same.</span>
<span class="cm">    gdi_to_world - [in]</span>
<span class="cm">       transform returned by ON_Annotation2::GetTextXform().</span>
<span class="cm">    dimstyle - [in]</span>
<span class="cm">      dimscale - [in]</span>
<span class="cm">    vp - [in]</span>
<span class="cm">    x - [out] plane x coordinates of the dimension line.</span>
<span class="cm">              The y coordinate = m_points[arrow0_pt_index].y</span>
<span class="cm">    bInside - [out] true if arrowheads go inside extension lines,</span>
<span class="cm">                    false if they go outside</span>
<span class="cm">  Returns:</span>
<span class="cm">    0: the input or class is not valid</span>
<span class="cm">    1: A single line from x[0] to x[1] with arrow heads at both ends.</span>
<span class="cm">        Arrowtips at x[4] &amp; x[5]</span>
<span class="cm">    2: Two lines from x[0] to x[1] and from x[1] to x[2].  The</span>
<span class="cm">        Arrowtips at x[4] &amp; x[5]</span>

<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetDimensionLineSegments</span><span class="p">(</span>
      <span class="n">ON_RECT</span> <span class="n">gdi_text_rect</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">gdi_height_of_I</span><span class="p">,</span>
      <span class="n">ON_Xform</span> <span class="n">gdi_to_world</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_DimStyle</span><span class="o">&amp;</span> <span class="n">dimstyle</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">dimscale</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Viewport</span><span class="o">*</span> <span class="n">vp</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
      <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">bInside</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">// Added for V5. 4/24/07 LW</span>
  <span class="c1">// Get the userdata extension for this dimension</span>
  <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">ON_DimensionExtra</span><span class="o">*</span> <span class="nf">DimensionExtension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>




<span class="p">};</span>

<span class="c1">//////////</span>
<span class="c1">// class ON_RadialDimension2</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_RadialDimension2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Annotation2</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_RadialDimension2</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">    The annotation&#39;s dimstyle controls the position of TEXT,</span>
<span class="cm">    and the size of the arrowheads.</span>

<span class="cm">    In the picture below, [n] means ON_Annotation2::m_points[n].</span>

<span class="cm">    Radial dimensions do not permit user positioned text</span>


<span class="cm">           knee</span>
<span class="cm">            [3]--------[2] TEXT</span>
<span class="cm">            /         (tail)</span>
<span class="cm">           /</span>
<span class="cm">          /</span>
<span class="cm">        [1] (arrow head here)</span>


<span class="cm">    + [0] = (usually at (0,0) = center of circle)</span>
<span class="cm">  */</span>

  <span class="k">enum</span> <span class="n">POINT_INDEX</span>
  <span class="p">{</span>
    <span class="c1">// Do not change these enum values.  They are saved in files as the</span>
    <span class="c1">// ON_COMPONENT_INDEX.m_index value.</span>
    <span class="c1">//</span>
    <span class="c1">// Indices of radial dimension definition points in</span>
    <span class="c1">// the m_points[] array</span>
    <span class="n">center_pt_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// location of + (usually at center of circle)</span>
    <span class="n">arrow_pt_index</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// arrow tip</span>
    <span class="n">tail_pt_index</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// end of radial dimension</span>
    <span class="n">knee_pt_index</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// number of m_points[] in a radial dim</span>
    <span class="n">dim_pt_count</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// number of m_points[] in a radial dim</span>

    <span class="c1">// Points calculated from values in m_points[]</span>
    <span class="n">text_pivot_pt</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="c1">// start/end of dimension text at tail</span>
  <span class="p">};</span>

  <span class="n">ON_RadialDimension2</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_RadialDimension2</span><span class="p">();</span>
  <span class="c1">// C++ automatically provides the correct copy constructor and operator= .</span>
  <span class="c1">//ON_RadialDimension2(const ON_RadialDimension2&amp;);</span>
  <span class="c1">//ON_RadialDimension2&amp; operator=(const ON_RadialDimension2&amp;);</span>

  <span class="c1">// overrides virtual ON_Geometry::Transform()</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_2dPoint</span> <span class="nf">Dim2dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Dim3dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">// overrides virual ON_Object::IsValid</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Write</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Read</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// overrides virual ON_Geometry::GetBBox</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetTightBoundingBox</span>
  <span class="kt">bool</span> <span class="nf">GetTightBoundingBox</span><span class="p">(</span>
      <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">tight_bbox</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">xform</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set the plane and definition points from WCS 3d input</span>
<span class="cm">    Parameters:</span>
<span class="cm">      center - [in] center of circle</span>
<span class="cm">      arrowtip - [in] 3d point on the circle at the dimension arrow tip</span>
<span class="cm">      xaxis - [in] x axis of the dimension&#39;s plane</span>
<span class="cm">      normal - [in] normal to the dimension&#39;s plane</span>
<span class="cm">      offset_distance - [in] distance from arrow tip to knee point</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CreateFromPoints</span><span class="p">(</span>
          <span class="n">ON_3dPoint</span> <span class="n">center</span><span class="p">,</span>
          <span class="n">ON_3dPoint</span> <span class="n">arrowtip</span><span class="p">,</span>
          <span class="n">ON_3dVector</span> <span class="n">xaxis</span><span class="p">,</span>
          <span class="n">ON_3dVector</span> <span class="n">normal</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">offset_distance</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Overrides virtual ON_Annotation2::NumericValue();</span>
<span class="cm">  Returns:</span>
<span class="cm">    If m_type is ON::dtDimDiameter, then the diameter</span>
<span class="cm">    is returned, othewise the radius is returned.</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">NumericValue</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or set the DimStyle index in the dimstyle table for the dimension</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] int  the new index (Set)</span>
<span class="cm">    Returns:</span>
<span class="cm">      int -  The current index (Get)</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">StyleIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetStyleIndex</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      static function to provide the default UserText string for the object</span>
<span class="cm">    Returns:</span>
<span class="cm">      const wchar_t* - the default string to use</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">DefaultDiameterText</span><span class="p">();</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">DefaultRadiusText</span><span class="p">();</span>

<span class="c1">// 6-23-03 lw Added v2 file writing of annotation</span>
  <span class="kt">void</span> <span class="nf">GetV2Form</span><span class="p">(</span> <span class="n">ON_RadialDimension</span><span class="o">&amp;</span> <span class="n">dim</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">CreateFromV2</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ON_Annotation</span><span class="o">&amp;</span> <span class="n">v2_ann</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_3dmAnnotationSettings</span><span class="o">&amp;</span> <span class="n">settings</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">dimstyle_index</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">GetArrowHeadDirection</span><span class="p">(</span> <span class="n">ON_2dVector</span><span class="o">&amp;</span> <span class="n">arrowhead_dir</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">GetArrowHeadTip</span><span class="p">(</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="n">arrowhead_tip</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">//////////</span>
<span class="c1">// class ON_AngularDimension2</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_AngularDimension2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Annotation2</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_AngularDimension2</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">    The annotation&#39;s dimstyle controls the position of TEXT,</span>
<span class="cm">    the size of the arrowheads, and the amount the ends of</span>
<span class="cm">    linear dimension&#39;s extension lines extend beyond the</span>
<span class="cm">    dimension lines.</span>

<span class="cm">    In the picture below, [n] means ON_Annotation2::m_points[n].</span>

<span class="cm">    [0] = if m_userpositionedtext=true, this is the center of text.</span>
<span class="cm">          If m_userpositionedtext=false, this point is not used and</span>
<span class="cm">          the center of the text is at the arc&#39;s midpoint.</span>

<span class="cm">    Always counter clockwise arc in m_plane with center = (0,0)</span>
<span class="cm">    [1] = a point somewhere on the line from the center through the start point.</span>
<span class="cm">          The distance from center to [1] can be any value.</span>
<span class="cm">    [2] = a point somewhere on the line from the center through the end point.</span>
<span class="cm">          The distance from center to [2] can be any value.</span>
<span class="cm">    [3] = a point on the interior of the arc.  The distance</span>
<span class="cm">          from (0,0) to [3] is the radius of the arc.</span>


<span class="cm">                  /</span>
<span class="cm">                [2]</span>
<span class="cm">                /</span>
<span class="cm">               /         [0]TEXT</span>
<span class="cm">              /</span>
<span class="cm">             /    [3]</span>
<span class="cm">     -----(0,0)----------[1]---</span>
<span class="cm">           /</span>
<span class="cm">          /</span>
<span class="cm">         /</span>

<span class="cm">  */</span>

  <span class="k">enum</span> <span class="n">POINT_INDEX</span>
  <span class="p">{</span>
    <span class="c1">// Do not change these enum values.  They are saved in files as the</span>
    <span class="c1">// ON_COMPONENT_INDEX.m_index value.</span>
    <span class="c1">//</span>
    <span class="c1">// Indices of angular dimension definition points in</span>
    <span class="c1">// the m_points[] array</span>
    <span class="n">userpositionedtext_pt_index</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">//</span>
    <span class="n">start_pt_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// point on the start ray (not necessarily on arc)</span>
    <span class="n">end_pt_index</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// point on the end ray (not necessarily on arc)</span>
    <span class="n">arc_pt_index</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// point on the interior of dimension arc</span>
    <span class="n">dim_pt_count</span>   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// number of m_points[] in an angular dim</span>

    <span class="c1">// Points calculated from values in m_points[]</span>
    <span class="n">text_pivot_pt</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="c1">// center of dimension text</span>
    <span class="n">arcstart_pt</span>   <span class="o">=</span> <span class="mi">10001</span><span class="p">,</span>
    <span class="n">arcend_pt</span>     <span class="o">=</span> <span class="mi">10002</span><span class="p">,</span>
    <span class="n">arcmid_pt</span>     <span class="o">=</span> <span class="mi">10003</span><span class="p">,</span>
    <span class="n">arccenter_pt</span>  <span class="o">=</span> <span class="mi">10004</span><span class="p">,</span> <span class="c1">// center of circle arc lies on</span>
    <span class="n">extension0_pt</span> <span class="o">=</span> <span class="mi">10005</span><span class="p">,</span> <span class="c1">// point where first extension line starts</span>
    <span class="n">extension1_pt</span> <span class="o">=</span> <span class="mi">10006</span>  <span class="c1">// point where second extension line starts</span>
  <span class="p">};</span>

  <span class="n">ON_AngularDimension2</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_AngularDimension2</span><span class="p">();</span>
  <span class="c1">// C++ copy constructor and operator= work fine.</span>
  <span class="c1">//ON_AngularDimension2(const ON_AngularDimension2&amp;);</span>
  <span class="c1">//ON_AngularDimension2&amp; operator=(const ON_AngularDimension2&amp;);</span>

  <span class="c1">// overrides virtual ON_Geometry::Transform()</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_2dPoint</span> <span class="nf">Dim2dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Dim3dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">// overrides virual ON_Object::IsValid</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetBBox</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetTightBoundingBox</span>
  <span class="kt">bool</span> <span class="nf">GetTightBoundingBox</span><span class="p">(</span>
      <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">tight_bbox</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">xform</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Read from or write to a file</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled Table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">file</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">file</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set the plane and definition points from 3d points</span>
<span class="cm">      in world coordinates.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      apex - [in] 3d apex of the dimension</span>
<span class="cm">                  (center of arc)</span>
<span class="cm">      p0 - [in] 3d point on first line</span>
<span class="cm">      p1 - [in] 3d point on second line</span>
<span class="cm">      arcpt - [in] 3d point on dimension arc</span>
<span class="cm">                   (determines radius of arc)</span>
<span class="cm">      Normal - [in] normal of the plane on which to make the dimension</span>
<span class="cm">                    (must be perpendicular to p0-apex and p1-apex)</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CreateFromPoints</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">apex</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">p0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">arcpt</span><span class="p">,</span>
    <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Normal</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Set the plane and definition points from a 3d arc.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      arc - [in]</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CreateFromArc</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Arc</span><span class="o">&amp;</span> <span class="n">arc</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">CreateFromV2</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ON_Annotation</span><span class="o">&amp;</span> <span class="n">v2_ann</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_3dmAnnotationSettings</span><span class="o">&amp;</span> <span class="n">settings</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">dimstyle_index</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">GetArc</span><span class="p">(</span> <span class="n">ON_Arc</span><span class="o">&amp;</span> <span class="n">arc</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">GetExtensionLines</span><span class="p">(</span><span class="n">ON_Line</span> <span class="n">extensions</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Set or get the measured angle in radians</span>
  <span class="kt">void</span> <span class="nf">SetAngle</span><span class="p">(</span> <span class="kt">double</span> <span class="n">angle</span><span class="p">);</span>
  <span class="kt">double</span> <span class="nf">Angle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetRadius</span><span class="p">(</span> <span class="kt">double</span> <span class="n">radius</span><span class="p">);</span>
  <span class="kt">double</span> <span class="nf">Radius</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Overrides virtual ON_Annotation2::NumericValue();</span>
<span class="cm">  Returns:</span>
<span class="cm">    Angle in degrees</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">NumericValue</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or set the DimStyle index in the dimstyle table for the dimension</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] int  the new index (Set)</span>
<span class="cm">    Returns:</span>
<span class="cm">      int -  The current index (Get)</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">StyleIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetStyleIndex</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      static function to provide the default UserText string for the object</span>
<span class="cm">    Returns:</span>
<span class="cm">      const wchar_t* - the default string to use</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">DefaultText</span><span class="p">();</span>


  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Convert back to the version of ON_Annotation used in Rhino 2</span>
<span class="cm">    Parameters:</span>
<span class="cm">      target [out] the old-style object</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true     Success</span>
<span class="cm">      False    Failure</span>
<span class="cm">    See Also:  ON_AnnotationObject::ConvertBack()</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">ConvertBack</span><span class="p">(</span> <span class="n">ON_AngularDimension2</span><span class="o">&amp;</span> <span class="n">target</span><span class="p">);</span>

<span class="c1">// 6-23-03 lw Added v2 file writing of annotation</span>
  <span class="kt">void</span> <span class="nf">GetV2Form</span><span class="p">(</span> <span class="n">ON_AngularDimension</span><span class="o">&amp;</span> <span class="n">dim</span><span class="p">);</span>

  <span class="kt">double</span> <span class="n">m_angle</span><span class="p">;</span>      <span class="c1">// angle being dimensioned</span>
  <span class="kt">double</span> <span class="n">m_radius</span><span class="p">;</span>     <span class="c1">// radius for dimension arc</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the annotation plane angles of the dimension arc.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    gdi_text_rect - [in] Windows rect (left &lt; right, top &lt; bottom)</span>
<span class="cm">       that bounds text.</span>
<span class="cm">    gdi_height_of_I - [in]</span>
<span class="cm">       Height of an I in the text.</span>
<span class="cm">    gdi_to_world - [in]</span>
<span class="cm">       transform returned by ON_Annotation2::GetTextXform().</span>
<span class="cm">    dimstyle - [in]</span>
<span class="cm">      dimscale - [in]</span>
<span class="cm">    vp - [in]</span>
<span class="cm">    a - [out]</span>
<span class="cm">      angles at the ends of the arc segment(s) and the arrow tips</span>
<span class="cm">    bInside - [out] true if arrowheads go inside, false if they go outside</span>
<span class="cm">  Returns:</span>
<span class="cm">    number of arc segments to draw</span>
<span class="cm">    0: the input or class is not valid</span>
<span class="cm">    1: A single arc from a[0] to a[1] with arrow heads at a[4] &amp; a[5].</span>
<span class="cm">    2: Two arcs from a[0] to a[1] &amp; from a[2] to a[3].</span>
<span class="cm">       Arrowheads are at a[4] &amp; a[5].</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetDimensionArcSegments</span><span class="p">(</span>
      <span class="n">ON_RECT</span> <span class="n">gdi_text_rect</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">gdi_height_of_I</span><span class="p">,</span>
      <span class="n">ON_Xform</span> <span class="n">gdi_to_world</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_DimStyle</span><span class="o">&amp;</span> <span class="n">dimstyle</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">dimscale</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Viewport</span><span class="o">*</span> <span class="n">vp</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
      <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">bInside</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get distance from dimension apex to extension line offset points</span>
<span class="cm">  Parameters:</span>
<span class="cm">    index - [in]  which distance to get</span>
<span class="cm">  Returns:</span>
<span class="cm">    Distance to offset point [index]</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">DimpointOffset</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set distance from dimension apex to extension line offset points</span>
<span class="cm">  Parameters:</span>
<span class="cm">    index  - [in]  which distance to set</span>
<span class="cm">    offset - [in] Value to set</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetDimpointOffset</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">};</span>



<span class="cm">/*</span>
<span class="cm">  class ON_LinearDimension2</span>

<span class="cm">  Description:</span>
<span class="cm">    Override od ON_Annotation2 to provide linear dimensions</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_OrdinateDimension2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Annotation2</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_OrdinateDimension2</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">    In the picture below, [n] means ON_Annotation2::m_points[n].</span>

<span class="cm">    Measures in X direction</span>

<span class="cm">                       [1]</span>
<span class="cm">                        |</span>
<span class="cm">                        |</span>
<span class="cm">                        |</span>
<span class="cm">                        |</span>
<span class="cm">                        |</span>
<span class="cm">                       [0]</span>
<span class="cm">       +</span>
<span class="cm"> [plane origin]                                      [plane origin]</span>
<span class="cm">                                                           +</span>

<span class="cm">      or - Measures in Y direction                                                   *---[1]</span>
<span class="cm">                                                                                    /</span>
<span class="cm">                                                                                   /</span>
<span class="cm">                   [0]--------------------[1]                   [0]---------------*</span>


<span class="cm">                                                                              * = calculated, not stored</span>


<span class="cm">       +</span>
<span class="cm"> [plane origin]</span>


<span class="cm">      The reference point of for the dimension is at the entity plane origin</span>
<span class="cm">      The &quot;x&quot; and &quot;y&quot; coordinates of [1] can be any value.</span>
<span class="cm">      The &quot;x&quot; and &quot;y&quot; coordinates of [2] can be any value.</span>
<span class="cm">      If Direction is &quot;x&quot;, the dimension measures along the &quot;x&quot; axis</span>
<span class="cm">      If Direction is &quot;y&quot;, the dimension measures along the &quot;y&quot; axis</span>
<span class="cm">      If Direction is &quot;x&quot; and [1][x] &lt;&gt; [0][x], an offset segment is drawn</span>
<span class="cm">      If Direction is &quot;y&quot; and [1][y] &lt;&gt; [0][y], an offset segment is drawn</span>
<span class="cm">      The dimension lines are always drawn in the X or Y directions of the entity plane</span>
<span class="cm">      The distance represented by the dimension is measured from the</span>
<span class="cm">        plane origin to point [0], parallel to the appropriate axis.</span>
<span class="cm">      The points of the offset segment are calculated rather than stored</span>
<span class="cm">  */</span>

  <span class="k">enum</span> <span class="n">POINT_INDEX</span>
  <span class="p">{</span>
    <span class="c1">// Do not change these enum values.  They are saved in files as the</span>
    <span class="c1">// ON_COMPONENT_INDEX.m_index value.</span>
    <span class="c1">//</span>
    <span class="c1">// Indices of linear dimension definition points in</span>
    <span class="c1">// the m_points[] array</span>
    <span class="n">definition_pt_index</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// First end of the dimension line</span>
    <span class="n">leader_end_pt_index</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// Other end of the leader (near the text)</span>
    <span class="n">dim_pt_count</span>           <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// Number of m_points[] in an ordinate dim</span>

    <span class="c1">// Points calculated from values in m_points[]</span>
    <span class="n">text_pivot_pt</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="c1">// Center of dimension text</span>
    <span class="n">offset_pt_0</span>   <span class="o">=</span> <span class="mi">10001</span><span class="p">,</span> <span class="c1">// First offset point  (nearest text)</span>
    <span class="n">offset_pt_1</span>   <span class="o">=</span> <span class="mi">10002</span>  <span class="c1">// Second offset point</span>
  <span class="p">};</span>

  <span class="k">enum</span> <span class="n">DIRECTION</span>
  <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1">// measures horizontally</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">// measures vertically</span>
  <span class="p">};</span>

  <span class="n">ON_OrdinateDimension2</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_OrdinateDimension2</span><span class="p">();</span>

  <span class="c1">// overrides virtual ON_Geometry::Transform()</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">    default_offset [in] - kink offset to use if m_kink_offset_0</span>
<span class="cm">                          or m_kink_offset_1 are ON_UNSET_VALUE</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_2dPoint</span> <span class="nf">Dim2dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span><span class="p">,</span>
       <span class="kt">double</span> <span class="n">default_offset</span> <span class="o">=</span> <span class="mf">1.0</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">    default_offset [in] - kink offset to use if m_kink_offset_0</span>
<span class="cm">                          or m_kink_offset_1 are ON_UNSET_VALUE</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Dim3dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span><span class="p">,</span>
       <span class="kt">double</span> <span class="n">default_offset</span> <span class="o">=</span> <span class="mf">1.0</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::IsValid</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetBBox</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmin</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmax</span><span class="p">,</span>
         <span class="n">ON_BOOL32</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetTightBoundingBox</span>
  <span class="kt">bool</span> <span class="nf">GetTightBoundingBox</span><span class="p">(</span>
      <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">tight_bbox</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">xform</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Read from or write to a file</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled Table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">file</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">file</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Overrides virtual ON_Annotation2::NumericValue();</span>
<span class="cm">  Returns:</span>
<span class="cm">    If Direction is &#39;X&#39;, x coordinate of point[1]</span>
<span class="cm">    If Direction is &#39;Y&#39;, y coordinate of point[1]</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">NumericValue</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or set the DimStyle index in the dimstyle table for the dimension</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] int  the new index (Set)</span>
<span class="cm">    Returns:</span>
<span class="cm">      int -  The current index (Get)</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">StyleIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetStyleIndex</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Gets the direction ( X or Y) that the ordinate dimension measures</span>
<span class="cm">      based on the relative location of the defining point and leader endpoint</span>
<span class="cm">    Returns:</span>
<span class="cm">      0: measures parallel to the entity plane x axis</span>
<span class="cm">      1: measures parallel to the entity plane y axis</span>
<span class="cm">    Remarks:</span>
<span class="cm">      This does not consider the dimension&#39;s explicit Direction setting</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">ImpliedDirection</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Gets or sets the direction ( X or Y) that the ordinate dimension measures</span>
<span class="cm">    Returns:</span>
<span class="cm">     -1: direction determined by dim point and leader point</span>
<span class="cm">      0: measures parallel to the entity plane x axis</span>
<span class="cm">      1: measures parallel to the entity plane y axis</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Direction</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetDirection</span><span class="p">(</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get the height of the text in this dimension</span>
<span class="cm">      by asking the dimension&#39;s dimstyle</span>
<span class="cm">    Returns:</span>
<span class="cm">      double Height of the text</span>
<span class="cm">    Remarks:</span>
<span class="cm">      Height is in model units</span>
<span class="cm">  double Height() const;</span>
<span class="cm">  */</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      static function to provide the default UserText string for the object</span>
<span class="cm">    Returns:</span>
<span class="cm">      const wchar_t* - the default string to use</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">DefaultText</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Returns or sets the offset distance parallel to the dimension</span>
<span class="cm">      line direction of from the text end of the dimension line to</span>
<span class="cm">      the offset point</span>
<span class="cm">      If the offset point hasn&#39;t been explicitly defined, returns</span>
<span class="cm">      ON_UNSET_VALUE and a default should be used to find the point.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      index [in] - which offset distance to return</span>
<span class="cm">                   (0 is closer to the text)</span>
<span class="cm">      offset [in] - the offset distance to set</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">KinkOffset</span><span class="p">(</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetKinkOffset</span><span class="p">(</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">double</span> <span class="n">offset</span><span class="p">);</span>


  <span class="kt">int</span> <span class="n">m_direction</span><span class="p">;</span>   <span class="c1">// -1 == underermined</span>
                     <span class="c1">//  0 == x direction</span>
                     <span class="c1">//  1 == y direction</span>

  <span class="c1">// kink offsets added 2-4-06 - LW</span>
  <span class="kt">double</span> <span class="n">m_kink_offset_0</span><span class="p">;</span>  <span class="c1">// from leader_end_point to first break point</span>
  <span class="kt">double</span> <span class="n">m_kink_offset_1</span><span class="p">;</span>  <span class="c1">// from first break point to second break point</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Calculates the 2d point locations of the dimension line kinks</span>

<span class="cm">    Parameters:</span>
<span class="cm">      p0, p1 [in] - End points of the dimension line</span>
<span class="cm">      direction [in] - orientation of the dimension</span>
<span class="cm">      default_offset [in] - Use this if offsets are ON_UNSET_VALUE</span>
<span class="cm">      k0, k1 [out] - The kink points</span>
<span class="cm">    Remarks:</span>
<span class="cm">      The offsets must be set to the right values before calling this, or</span>
<span class="cm">      If they are ON_UNSET_VALUE, they will be set to the defaults</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">CalcKinkPoints</span><span class="p">(</span> <span class="n">ON_2dPoint</span> <span class="n">p0</span><span class="p">,</span> <span class="n">ON_2dPoint</span> <span class="n">p1</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">double</span> <span class="n">default_offset</span><span class="p">,</span>
                       <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="n">k0</span><span class="p">,</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="n">k1</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">};</span>



<span class="c1">//////////</span>
<span class="c1">// class ON_TextEntity2</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_TextEntity2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Annotation2</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_TextEntity2</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_TextEntity2</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_TextEntity2</span><span class="p">();</span>

  <span class="c1">// overrides virual ON_Object::IsValid</span>
  <span class="c1">// Text entities with strings that contain no &quot;printable&quot; characters</span>
  <span class="c1">// are considered to be NOT valid.</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Write</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Read</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// overrides virtual ON_Geometry::Transform()</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="c1">// overrides virual ON_Geometry::GetBBox</span>
  <span class="c1">// This just adds the text base point to the box</span>
  <span class="c1">// There is no calculation of the size of the text or its bounds</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetTightBoundingBox</span>
  <span class="c1">// This just adds the text base point to the box</span>
  <span class="c1">// There is no calculation of the size of the text or its bounds</span>
  <span class="kt">bool</span> <span class="nf">GetTightBoundingBox</span><span class="p">(</span>
      <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">tight_bbox</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">xform</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or set the Font index in the Font Table for the text</span>

<span class="cm">    Parameters:</span>
<span class="cm">      [in] int  the new index (Set)</span>

<span class="cm">    Returns:</span>
<span class="cm">      int -  The current index (Get)</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">FontIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetFontIndex</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

<span class="c1">// 6-23-03 lw Added v2 file writing of annotation</span>
  <span class="kt">void</span> <span class="nf">GetV2Form</span><span class="p">(</span> <span class="n">ON_TextEntity</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">SetJustification</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">justification</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">Justification</span><span class="p">();</span>

  <span class="c1">// Determines whether or not to draw a Text Mask</span>
  <span class="kt">bool</span> <span class="nf">DrawTextMask</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetDrawTextMask</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bDraw</span><span class="p">);</span>

  <span class="c1">// Determines where to get the color to draw a Text Mask</span>
  <span class="c1">// 0: Use background color of the viewport.  Initially, gradient backgrounds will not be supported</span>
  <span class="c1">// 1: Use the ON_Color returned by MaskColor()</span>
  <span class="kt">int</span> <span class="nf">MaskColorSource</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetMaskColorSource</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">);</span>

  <span class="n">ON_Color</span> <span class="nf">MaskColor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// Only works right if MaskColorSource returns 1.</span>
                               <span class="c1">// Does not return viewport background color</span>
  <span class="kt">void</span> <span class="nf">SetMaskColor</span><span class="p">(</span><span class="n">ON_Color</span> <span class="n">color</span><span class="p">);</span>

  <span class="c1">// Offset for the border around text to the rectangle used to draw the mask</span>
  <span class="c1">// This number * CRhinoAnnotation::TextHeight() for the text is the offset</span>
  <span class="c1">// on each side of the tight rectangle around the text characters to the mask rectangle.</span>
  <span class="kt">double</span> <span class="nf">MaskOffsetFactor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetMaskOffsetFactor</span><span class="p">(</span><span class="kt">double</span> <span class="n">offset</span><span class="p">);</span>

  <span class="c1">// Scale annotation according to detail scale factor in paperspace</span>
  <span class="c1">// or by 1.0 in paperspace and not in a detail</span>
  <span class="c1">// Otherwise, dimscale or text scale is used</span>
  <span class="kt">bool</span> <span class="nf">AnnotativeScaling</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetAnnotativeScaling</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">//////////</span>
<span class="c1">// class ON_Leader2</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_Leader2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Annotation2</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_Leader2</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">    The annotation&#39;s dimstyle controls the position of TEXT,</span>
<span class="cm">    the size of the arrowheads, and the amount the ends of</span>
<span class="cm">    linear dimension&#39;s extension lines extend beyond the</span>
<span class="cm">    dimension lines.</span>

<span class="cm">    Leaders:</span>

<span class="cm">      Polyline with N=m_points.Count() points (N &gt;= 2).</span>

<span class="cm">                      [N-2] ----- [N-1] TEXT</span>
<span class="cm">                        /         (tail)</span>
<span class="cm">                       /</span>
<span class="cm">                      /</span>
<span class="cm">            [1]------[2]</span>
<span class="cm">            /</span>
<span class="cm">           /</span>
<span class="cm">          /</span>
<span class="cm">        [0] (arrow)</span>

<span class="cm">      Leaders ignore the m_userpositionedtext setting.  If the</span>
<span class="cm">      default leader text handling is not adequate, then use</span>
<span class="cm">      a leader with no text and an ON_TextEntity2.</span>
<span class="cm">  */</span>

  <span class="k">enum</span> <span class="n">POINT_INDEX</span>
  <span class="p">{</span>
    <span class="c1">// Do not change these enum values.  They are saved in files as the</span>
    <span class="c1">// ON_COMPONENT_INDEX.m_index value.</span>
    <span class="c1">//</span>
    <span class="c1">// Indices of leader definition points in</span>
    <span class="c1">// the m_points[] array</span>
    <span class="n">arrow_pt_index</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// arrow tip</span>

    <span class="c1">// Points calculated from values in m_points[]</span>
    <span class="n">text_pivot_pt</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="c1">// start/end of dimension text at tail</span>
    <span class="n">tail_pt</span>       <span class="o">=</span> <span class="mi">10001</span>
  <span class="p">};</span>

  <span class="c1">// Constructors</span>
  <span class="n">ON_Leader2</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_Leader2</span><span class="p">();</span>
  <span class="c1">// C++ automatically provides the correct copy constructor and operator= .</span>
  <span class="c1">//ON_Leader2(const ON_Leader2&amp;);</span>
  <span class="c1">//ON_Leader2&amp; operator=(const ON_Leader2&amp;);</span>

  <span class="c1">// overrides virtual ON_Geometry::Transform()</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_2dPoint</span> <span class="nf">Dim2dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the m_plane coordinates of the dimension point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_index - [in] One of the POINT_INDEX enum values</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d point or ON_UNSET_POINT if point_index or m_points[]</span>
<span class="cm">    array is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Dim3dPoint</span><span class="p">(</span>
       <span class="kt">int</span> <span class="n">point_index</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::IsValid</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Write</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Object::Read</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// overrides virual ON_Geometry::GetBBox</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virual ON_Geometry::GetTightBoundingBox</span>
  <span class="kt">bool</span> <span class="nf">GetTightBoundingBox</span><span class="p">(</span>
      <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">tight_bbox</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">xform</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Add or delete points to the leader</span>
<span class="cm">    Parameters:</span>
<span class="cm">      index [in] the point to delete</span>
<span class="cm">      point [in]  The point to add</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true     Success</span>
<span class="cm">      False    Failure</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">AddPoint</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">RemovePoint</span><span class="p">(</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Converts an ON_Leader2 to the v2 form ON_Leader</span>
<span class="cm">    Parameters:</span>
<span class="cm">      leader [out] - the result of the conversion</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">GetV2Form</span><span class="p">(</span> <span class="n">ON_Leader</span><span class="o">&amp;</span> <span class="n">leader</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">CreateFromV2</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ON_Annotation</span><span class="o">&amp;</span> <span class="n">v2_ann</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_3dmAnnotationSettings</span><span class="o">&amp;</span> <span class="n">settings</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">dimstyle_index</span>
      <span class="p">);</span>

<span class="c1">// April 22, 2010 Lowell - Added to support right justified text on left pointing leader tails rr64292</span>
  <span class="kt">bool</span> <span class="nf">GetTextDirection</span><span class="p">(</span> <span class="n">ON_2dVector</span><span class="o">&amp;</span> <span class="n">text_dir</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">GetArrowHeadDirection</span><span class="p">(</span> <span class="n">ON_2dVector</span><span class="o">&amp;</span> <span class="n">arrowhead_dir</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">GetArrowHeadTip</span><span class="p">(</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="n">arrowhead_tip</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm">  A simple dot with text that doesn&#39;t rotate witn the world axes</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_TextDot</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_TextDot</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_TextDot</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_TextDot</span><span class="p">();</span>
  <span class="c1">// C++ automatically provides the correct copy constructor and operator= .</span>
  <span class="c1">//ON_TextDot( const ON_TextDot&amp; src);</span>
  <span class="c1">//ON_TextDot&amp; operator=( const ON_TextDot&amp; src);</span>

  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span>

  <span class="c1">//---------------------------</span>
  <span class="c1">// ON_Object overrides</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Paramters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief english description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description: Write data values to a text file for debugging</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="n">log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description: Writes the object to a file</span>

<span class="cm">    Returns:</span>
<span class="cm">      @untitled Table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">ar</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description: Reads the object from a file</span>

<span class="cm">    Returns:</span>
<span class="cm">      @untitled Table</span>
<span class="cm">      true     Success</span>
<span class="cm">      false    Failure</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">ar</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">    Returns: The Object Type of this object</span>
<span class="cm">  */</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//---------------------------</span>
  <span class="c1">// ON_Geometry overrides</span>

  <span class="cm">/*</span>
<span class="cm">    Returns the geometric dimension of the object ( usually 3)</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get a bounding 3d WCS box of the object</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in/out] double* boxmin - pointer to dim doubles for min box corner</span>
<span class="cm">      [in/out] double* boxmax - pointer to dim doubles for max box corner</span>
<span class="cm">      [in] ON_BOOL32 growbox   - true to grow the existing box,</span>
<span class="cm">                            false ( the default) to reset the box</span>
<span class="cm">    Returns:</span>
<span class="cm">      true = Success</span>
<span class="cm">      false = Failure</span>
<span class="cm">    Remarks:</span>
<span class="cm">      Since the bounding box of this entity changes size at different</span>
<span class="cm">      zoom levels, the bounding box is a point at the definition point</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span> <span class="kt">double</span><span class="o">*</span> <span class="n">box_min</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">box_max</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">grow_box</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Transform the object by a 4x4 xform matrix</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] xform  - An ON_Xform with the transformation information</span>
<span class="cm">    Returns:</span>
<span class="cm">      true = Success</span>
<span class="cm">      false = Failure</span>
<span class="cm">    Remarks:</span>
<span class="cm">      The object has been transformed when the function returns</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span><span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::IsDeformable() override</span>
  <span class="kt">bool</span> <span class="nf">IsDeformable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::MakeDeformable() override</span>
  <span class="kt">bool</span> <span class="nf">MakeDeformable</span><span class="p">();</span>

  <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">Point</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetPoint</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">Height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetHeight</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">TextString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetTextString</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">string</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">FontFace</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">SetFontFace</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">face</span><span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or Set whether the dot is drawn &quot;On Top&quot; of other geometry</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] bTop  bool - It is or isn&#39;t on top</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true - on top</span>
<span class="cm">      false - not on top</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetAlwaysOnTop</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bTop</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">AlwaysOnTop</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or Set whether the dot is drawn with a transparent background</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] bTransparent  bool - It is or isn&#39;t transparent</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true - transparent</span>
<span class="cm">      false - not transparent</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetTransparent</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bTransparent</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Transparent</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or Set whether the dot is drawn with Bold text</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] bBold  bool - It is or isn&#39;t Bold</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true - Bold</span>
<span class="cm">      false - not Bold</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetBold</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bBold</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Bold</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Get or Set whether the dot is drawn with Italic text</span>
<span class="cm">    Parameters:</span>
<span class="cm">      [in] bItalic  bool - It is or isn&#39;t Italic</span>
<span class="cm">    Returns:</span>
<span class="cm">      @untitled table</span>
<span class="cm">      true - Italic</span>
<span class="cm">      false - not Italic</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetItalic</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bItalic</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Italic</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>


  <span class="n">ON_3dPoint</span> <span class="n">m_point</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_height</span><span class="p">;</span>        <span class="c1">// in points</span>
  <span class="n">ON_wString</span> <span class="n">m_text</span><span class="p">;</span>
  <span class="n">ON_wString</span> <span class="n">m_fontface</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_display</span><span class="p">;</span>       <span class="c1">// some future display flags -</span>
<span class="p">};</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_arc.h.html" class="btn btn-neutral float-right" title="File opennurbs_arc.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_annotation2.h.html" class="btn btn-neutral float-left" title="File opennurbs_annotation2.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>