

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_math.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_matrix.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_matrix.h.html" />
    <link rel="prev" title="File opennurbs_math.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_math.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_math.h.html">File opennurbs_math.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_math.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_math.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-math-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-math-h"></span><h1>Program Listing for File opennurbs_math.h<a class="headerlink" href="#program-listing-for-file-opennurbs-math-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_math.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-math-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_math.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="cp">#if !defined(ON_MATH_INC_)</span>
<span class="cp">#define ON_MATH_INC_</span>

<span class="k">class</span> <span class="nc">ON_3dVector</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Interval</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Line</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Arc</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Plane</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Class for carefully adding long list of numbers.</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_Sum</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calls ON_Sum::Begin(x)</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calls ON_Sum::Plus(x);</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calls ON_Sum::Plus(-x);</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Creates a sum that is ready to be used.</span>
<span class="cm">  */</span>
  <span class="n">ON_Sum</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If a sum is being used more than once, call Begin()</span>
<span class="cm">    before starting each sum.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    starting_value - [in] Initial value of sum.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Begin</span><span class="p">(</span> <span class="kt">double</span> <span class="n">starting_value</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add x to the current sum.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    x - [in] value to add to the current sum.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Plus</span><span class="p">(</span> <span class="kt">double</span> <span class="n">x</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calculates the total sum.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    error_estimate - [out] if not NULL, the returned value of</span>
<span class="cm">       *error_estimate is an estimate of the error in the sum.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Total of the sum.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    You can get subtotals by mixing calls to Plus() and Total().</span>
<span class="cm">    In delicate sums, some precision may be lost in the final</span>
<span class="cm">    total if you call Total() to calculate subtotals.</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">Total</span><span class="p">(</span> <span class="kt">double</span><span class="o">*</span> <span class="n">error_estimate</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of summands.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SummandCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">sum1_max_count</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
    <span class="n">sum2_max_count</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">sum3_max_count</span><span class="o">=</span><span class="mi">1024</span>
  <span class="p">};</span>
  <span class="kt">double</span> <span class="n">m_sum_err</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">m_pos_sum</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">m_neg_sum</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">m_zero_count</span><span class="p">;</span> <span class="c1">// number of zeros added</span>
  <span class="kt">int</span> <span class="n">m_pos_count</span><span class="p">;</span> <span class="c1">// number of positive numbers added</span>
  <span class="kt">int</span> <span class="n">m_neg_count</span><span class="p">;</span> <span class="c1">// number of negative numbers added</span>

  <span class="kt">int</span> <span class="n">m_pos_sum1_count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_pos_sum2_count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_pos_sum3_count</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">m_pos_sum1</span><span class="p">[</span><span class="n">sum1_max_count</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">m_pos_sum2</span><span class="p">[</span><span class="n">sum2_max_count</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">m_pos_sum3</span><span class="p">[</span><span class="n">sum3_max_count</span><span class="p">];</span>

  <span class="kt">int</span> <span class="n">m_neg_sum1_count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_neg_sum2_count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_neg_sum3_count</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">m_neg_sum1</span><span class="p">[</span><span class="n">sum1_max_count</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">m_neg_sum2</span><span class="p">[</span><span class="n">sum2_max_count</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">m_neg_sum3</span><span class="p">[</span><span class="n">sum3_max_count</span><span class="p">];</span>

  <span class="kt">double</span> <span class="nf">SortAndSum</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Abstract function with an arbitrary number of parameters</span>
<span class="cm">  and values.  ON_Evaluator is used to pass functions to</span>
<span class="cm">  local solvers.</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_Evaluator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Construction of the class for a function that takes</span>
<span class="cm">    parameter_count input functions and returns</span>
<span class="cm">    value_count values.  If the domain is infinite, pass</span>
<span class="cm">    a NULL for the domain[] and periodic[] arrays.  If</span>
<span class="cm">    the domain is finite, pass a domain[] array with</span>
<span class="cm">    parameter_count increasing intervals.  If one or more of</span>
<span class="cm">    the parameters is periodic, pass the fundamental domain</span>
<span class="cm">    in the domain[] array and a true in the periodic[] array.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    parameter_count - [in] &gt;= 1.  Number of input parameters</span>
<span class="cm">    value_count - [in] &gt;= 1.  Number of output values.</span>
<span class="cm">    domain - [in] If not NULL, then this is an array</span>
<span class="cm">                  of parameter_count increasing intervals</span>
<span class="cm">                  that defines the domain of the function.</span>
<span class="cm">    periodic - [in] if not NULL, then this is an array of</span>
<span class="cm">                parameter_count bools where b[i] is true if</span>
<span class="cm">                the i-th parameter is periodic.  Valid</span>
<span class="cm">                increasing finite domains must be specificed</span>
<span class="cm">                when this parameter is not NULL.</span>
<span class="cm">  */</span>
  <span class="n">ON_Evaluator</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">parameter_count</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">value_count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">*</span> <span class="n">domain</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">bool</span><span class="o">*</span> <span class="n">periodic</span>
    <span class="p">);</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">ON_Evaluator</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Evaluate the function that takes m_parameter_count parameters</span>
<span class="cm">    and returns a m_value_count dimensional point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    parameters - [in] array of m_parameter_count evaluation parameters</span>
<span class="cm">    values - [out] array of m_value_count function values</span>
<span class="cm">    jacobian - [out] If NULL, simply evaluate the value of the function.</span>
<span class="cm">                     If not NULL, this is the jacobian of the function.</span>
<span class="cm">                     jacobian[i][j] = j-th partial of the i-th value</span>
<span class="cm">                     0 &lt;= i &lt; m_value_count,</span>
<span class="cm">                     0 &lt;= j &lt; m_parameter_count</span>
<span class="cm">                     If not NULL, then all the memory for the</span>
<span class="cm">                     jacobian is allocated, you just need to fill</span>
<span class="cm">                     in the answers.</span>
<span class="cm">  Example:</span>
<span class="cm">    If f(u,v) = square of the distance from a fixed point P to a</span>
<span class="cm">    surface evaluated at (u,v), then</span>

<span class="cm">          values[0] = (S-P)o(S-P)</span>
<span class="cm">          jacobian[0] = ( 2*(Du o (S-P)), 2*(Dv o (S-P)) )</span>

<span class="cm">    where S, Du, Dv = surface point and first partials evaluated</span>
<span class="cm">    at u=parameters[0], v = parameters[1].</span>

<span class="cm">    If the function takes 3 parameters, say (x,y,z), and returns</span>
<span class="cm">    two values, say f(x,y,z) and g(z,y,z), then</span>

<span class="cm">          values[0] = f(x,y,z)</span>
<span class="cm">          values[1] = g(x,y,z)</span>

<span class="cm">          jacobian[0] = (DfDx, DfDy, DfDz)</span>
<span class="cm">          jacobian[1] = (DgDx, DgDy, DgDz)</span>

<span class="cm">    where dfx denotes the first partial of f with respect to x.</span>

<span class="cm">  Returns:</span>
<span class="cm">    0 = unable to evaluate</span>
<span class="cm">    1 = successful evaluation</span>
<span class="cm">    2 = found answer, terminate search</span>
<span class="cm">  */</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Evaluate</span><span class="p">(</span>
       <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
       <span class="kt">double</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span>
       <span class="kt">double</span><span class="o">**</span> <span class="n">jacobian</span>
       <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    OPTIONAL ability to evaluate the hessian in the case when</span>
<span class="cm">    m_value_count is one.  If your function has more that</span>
<span class="cm">    one value or it is not feasable to evaluate the hessian,</span>
<span class="cm">    then do not override this function.  The default implementation</span>
<span class="cm">    returns -1.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    parameters - [in] array of m_parameter_count evaluation parameters</span>
<span class="cm">    value - [out] value of the function (one double)</span>
<span class="cm">    gradient - [out] The gradient of the function.  This is a vector</span>
<span class="cm">                     of length m_parameter_count; gradient[i] is</span>
<span class="cm">                     the first partial of the function with respect to</span>
<span class="cm">                     the i-th parameter.</span>
<span class="cm">    hessian - [out] The hessian of the function. This is an</span>
<span class="cm">                    m_parameter_count x m_parameter_count</span>
<span class="cm">                    symmetric matrix: hessian[i][j] is the</span>
<span class="cm">                    second partial of the function with respect</span>
<span class="cm">                    to the i-th and j-th parameters.  The evaluator</span>
<span class="cm">                    is responsible for filling in both the upper</span>
<span class="cm">                    and lower triangles.  Since the matrix is</span>
<span class="cm">                    symmetrix, you should do something like evaluate</span>
<span class="cm">                    the upper triangle and copy the values to the</span>
<span class="cm">                    lower tiangle.</span>
<span class="cm">  Returns:</span>
<span class="cm">   -1 = Hessian evaluation not available.</span>
<span class="cm">    0 = unable to evaluate</span>
<span class="cm">    1 = successful evaluation</span>
<span class="cm">    2 = found answer, terminate search</span>
<span class="cm">  */</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">EvaluateHessian</span><span class="p">(</span>
       <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
       <span class="kt">double</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span>
       <span class="kt">double</span><span class="o">*</span> <span class="n">gradient</span><span class="p">,</span>
       <span class="kt">double</span><span class="o">**</span> <span class="n">hessian</span>
       <span class="p">);</span>

  <span class="c1">// Number of the function&#39;s input parameters. This number</span>
  <span class="c1">// is &gt;= 1 and is specified in the constructor.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">m_parameter_count</span><span class="p">;</span>

  <span class="c1">// Number of the function&#39;s output values. This number</span>
  <span class="c1">// is &gt;= 1 and is specified in the constructor.</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">m_value_count</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Functions can have finite or infinite domains. Finite domains</span>
<span class="cm">    are specified by passing the domain[] array to the constructor</span>
<span class="cm">    or filling in the m_domain[] member variable.  If</span>
<span class="cm">    m_domain.Count() == m_parameter_count &gt; 0, then the function</span>
<span class="cm">    has finite domains.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the domain of the function is finite.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">FiniteDomain</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If a function has a periodic parameter, then the m_domain</span>
<span class="cm">    interval for that parameter is the fundamental domain and</span>
<span class="cm">    the m_bPeriodicParameter bool for that parameter is true.</span>
<span class="cm">    A parameter is periodic if, and only if,</span>
<span class="cm">    m_domain.Count() == m_parameter_count, and</span>
<span class="cm">    m_bPeriodicParameter.Count() == m_parameter_count, and</span>
<span class="cm">    m_bPeriodicParameter[parameter_index] is true.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the function parameter is periodic.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Periodic</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">parameter_index</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If a function has a periodic parameter, then the m_domain</span>
<span class="cm">    interval for that parameter is the fundamental domain and</span>
<span class="cm">    the m_bPeriodicParameter bool for that parameter is true.</span>
<span class="cm">    A parameter is periodic if, and only if,</span>
<span class="cm">    m_domain.Count() == m_parameter_count, and</span>
<span class="cm">    m_bPeriodicParameter.Count() == m_parameter_count, and</span>
<span class="cm">    m_bPeriodicParameter[parameter_index] is true.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The domain of the parameter.  If the domain is infinite,</span>
<span class="cm">    the (-1.0e300, +1.0e300) is returned.</span>
<span class="cm">  */</span>
  <span class="n">ON_Interval</span> <span class="nf">Domain</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">parameter_index</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">// If the function has a finite domain or periodic</span>
  <span class="c1">// parameters, then m_domain[] is an array of</span>
  <span class="c1">// m_parameter_count finite increasing intervals.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Interval</span><span class="o">&gt;</span> <span class="n">m_domain</span><span class="p">;</span>

  <span class="c1">// If the function has periodic parameters, then</span>
  <span class="c1">// m_bPeriodicParameter[] is an array of m_parameter_count</span>
  <span class="c1">// bools.  If m_bPeriodicParameter[i] is true, then</span>
  <span class="c1">// the i-th parameter is periodic and m_domain[i] is</span>
  <span class="c1">// the fundamental domain for that parameter.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">m_bPeriodicParameter</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">ON_Evaluator</span><span class="p">();</span> <span class="c1">// prohibit default constructor</span>
  <span class="n">ON_Evaluator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Evaluator</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// prohibit operator= (can&#39;t copy const members)</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Test a double to make sure it is a valid number.</span>
<span class="cm">Returns:</span>
<span class="cm">  True if x != ON_UNSET_VALUE and _finite(x) is true.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IsValid</span><span class="p">(</span> <span class="kt">double</span> <span class="n">x</span> <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IsValidFloat</span><span class="p">(</span> <span class="kt">float</span> <span class="n">x</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">class ON_CLASS ON_TimeLimit</span>
<span class="cm">{</span>
<span class="cm">  ON_TimeLimit();</span>
<span class="cm">  ON_TimeLimit(ON__UINT64 time_limit_seconds);</span>
<span class="cm">  void SetTimeLimit(ON__UINT64 time_limit_seconds);</span>
<span class="cm">  bool Continue() const;</span>
<span class="cm">  bool IsSet() const;</span>
<span class="cm">private:</span>
<span class="cm">  ON__UINT64 m_time_limit[2];</span>
<span class="cm">};</span>
<span class="cm">*/</span>

<span class="c1">// The ON_IS_FINITE and ON_IS_VALID defines are much faster</span>
<span class="c1">// than calling ON_IsValid(), but need to be used when</span>
<span class="c1">// the macro expansion works.</span>

<span class="cp">#if   defined(ON_LITTLE_ENDIAN)</span>

<span class="c1">// works on little endian CPUs with IEEE doubles</span>
<span class="cp">#define ON_IS_FINITE(x) (0x7FF0 != (*((unsigned short*)(&amp;x) + 3) &amp; 0x7FF0))</span>
<span class="cp">#define ON_IS_VALID(x)  (x != ON_UNSET_VALUE &amp;&amp; 0x7FF0 != (*((unsigned short*)(&amp;x) + 3) &amp; 0x7FF0))</span>
<span class="cp">#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT)</span>
<span class="c1">//TODO - ADD FAST ugly bit check#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT &amp;&amp; 0x7FF0 != (*((unsigned short*)(&amp;x) + 3) &amp; 0x7FF0))</span>

<span class="cp">#elif defined(ON_BIG_ENDIAN)</span>

<span class="c1">// works on big endian CPUs with IEEE doubles</span>
<span class="cp">#define ON_IS_FINITE(x) (0x7FF0 != (*((unsigned short*)(&amp;x)) &amp; 0x7FF0))</span>
<span class="cp">#define ON_IS_VALID(x)  (x != ON_UNSET_VALUE &amp;&amp; 0x7FF0 != (*((unsigned short*)(&amp;x)) &amp; 0x7FF0))</span>
<span class="cp">#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT)</span>
<span class="c1">//TODO - ADD FAST ugly bit check#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT &amp;&amp; 0x7FF0 != (*((unsigned short*)(&amp;x) + 3) &amp; 0x7FF0))</span>

<span class="cp">#else</span>

<span class="c1">// Returns true if x is a finite double.  Specifically,</span>
<span class="c1">// _finite returns a nonzero value (true) if its argument x</span>
<span class="c1">// is not infinite, that is, if -INF &lt; x &lt; +INF.</span>
<span class="c1">// It returns 0 (false) if the argument is infinite or a NaN.</span>
<span class="c1">//</span>
<span class="c1">// If you are trying to compile opennurbs on a platform</span>
<span class="c1">// that does not support finite(), then see if you can</span>
<span class="c1">// use _fpclass(), fpclass(), _isnan(), or isnan().  If</span>
<span class="c1">// you can&#39;t find anything, then just set this</span>
<span class="c1">// function to return true.</span>

<span class="cp">#if defined(_GNU_SOURCE)</span>
<span class="c1">// if you are using an older version of gcc, use finite()</span>
<span class="c1">//#define ON_IS_FINITE(x) (finite(x)?true:false)</span>
<span class="cp">#define ON_IS_FINITE(x) (isfinite(x)?true:false)</span>
<span class="cp">#else</span>
<span class="cp">#define ON_IS_FINITE(x) (_finite(x)?true:false)</span>
<span class="cp">#endif</span>

<span class="cp">#define ON_IS_VALID(x)  (x != ON_UNSET_VALUE &amp;&amp; ON_IS_FINITE(x))</span>
<span class="cp">#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT &amp;&amp; ON_IS_FINITE(x))</span>

<span class="cp">#endif</span>


<span class="n">ON_DECL</span>
<span class="kt">float</span> <span class="nf">ON_ArrayDotProduct</span><span class="p">(</span> <span class="c1">// returns AoB</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arrays</span> <span class="p">(</span><span class="n">can</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>
          <span class="k">const</span> <span class="kt">float</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="k">const</span> <span class="kt">float</span><span class="o">*</span>  <span class="c1">// B[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">void</span>   <span class="nf">ON_ArrayScale</span><span class="p">(</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arrays</span> <span class="p">(</span><span class="n">can</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>
          <span class="kt">float</span><span class="p">,</span>        <span class="c1">// a</span>
          <span class="k">const</span> <span class="kt">float</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="kt">float</span><span class="o">*</span>        <span class="c1">// returns a*A[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">void</span>   <span class="nf">ON_Array_aA_plus_B</span><span class="p">(</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arrays</span> <span class="p">(</span><span class="n">can</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>
          <span class="kt">float</span><span class="p">,</span>        <span class="c1">// a</span>
          <span class="k">const</span> <span class="kt">float</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="k">const</span> <span class="kt">float</span><span class="o">*</span><span class="p">,</span> <span class="c1">// B[]</span>
          <span class="kt">float</span><span class="o">*</span>        <span class="c1">// returns a*A[] + B[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_ArrayDotProduct</span><span class="p">(</span> <span class="c1">// returns AoB</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arrays</span> <span class="p">(</span><span class="n">can</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// B[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_ArrayDotDifference</span><span class="p">(</span> <span class="o">//</span> <span class="n">returns</span> <span class="n">A</span> <span class="n">o</span> <span class="p">(</span> <span class="n">B</span> <span class="o">-</span> <span class="n">C</span> <span class="p">)</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// size of arrays (can be zero)</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// B[]</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// C[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_ArrayMagnitude</span><span class="p">(</span> <span class="o">//</span> <span class="n">returns</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">AoA</span><span class="p">)</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// size of arrays (can be zero)</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// A[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_ArrayMagnitudeSquared</span><span class="p">(</span> <span class="c1">// returns AoA</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arrays</span> <span class="p">(</span><span class="n">can</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// A[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_ArrayDistance</span><span class="p">(</span> <span class="o">//</span> <span class="n">returns</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">A</span><span class="o">-</span><span class="n">B</span><span class="p">)</span><span class="n">o</span><span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">B</span><span class="p">))</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// size of arrays (can be zero)</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// B[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_ArrayDistanceSquared</span><span class="p">(</span> <span class="o">//</span> <span class="n">returns</span> <span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">B</span><span class="p">)</span><span class="n">o</span><span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">B</span><span class="p">)</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// size of arrays (can be zero)</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// B[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">void</span>   <span class="nf">ON_ArrayScale</span><span class="p">(</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arrays</span> <span class="p">(</span><span class="n">can</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>
          <span class="kt">double</span><span class="p">,</span>        <span class="c1">// a</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="kt">double</span><span class="o">*</span>        <span class="c1">// returns a*A[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">void</span>   <span class="nf">ON_Array_aA_plus_B</span><span class="p">(</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arrays</span> <span class="p">(</span><span class="n">can</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>
          <span class="kt">double</span><span class="p">,</span>        <span class="c1">// a</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// A[]</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// B[]</span>
          <span class="kt">double</span><span class="o">*</span>        <span class="c1">// returns a*A[] + B[]</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">int</span>    <span class="nf">ON_SearchMonotoneArray</span><span class="p">(</span> <span class="c1">// find a value in an increasing array</span>
          <span class="c1">// returns  -1: t &lt; array[0]</span>
          <span class="o">//</span>           <span class="nl">i</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
          <span class="c1">//    length-1: t == array[length-1]</span>
          <span class="c1">//      length: t &gt;= array[length-1]</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// array[]</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// length of array</span>
          <span class="kt">double</span>         <span class="c1">// t = value to search for</span>
          <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Compute a binomial coefficient.</span>
<span class="cm">Parameters:</span>
<span class="cm">  i - [in]</span>
<span class="cm">  j - [in]</span>
<span class="cm">Returns:</span>
<span class="cm">  (i+j)!/(i!j!), if 0 &lt;= i and 0 &lt;= j, and 0 otherwise.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_TrinomialCoefficient()</span>
<span class="cm">Remarks:</span>
<span class="cm">  If (i+j) &lt;= 52, this function is fast and returns the exact</span>
<span class="cm">  value of the binomial coefficient.</span>

<span class="cm">  For (i+j) &gt; 52, the coefficient is computed recursively using</span>
<span class="cm">  the formula  bc(i,j) = bc(i-1,j) + bc(i,j-1).</span>
<span class="cm">  For (i+j) much larger than 60, this is inefficient.</span>
<span class="cm">  If you need binomial coefficients for large i and j, then you</span>
<span class="cm">  should probably be using something like Stirling&#39;s Formula.</span>
<span class="cm">  (Look up &quot;Stirling&quot; or &quot;Gamma function&quot; in a calculus book.)</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_BinomialCoefficient</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">j</span>
          <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Compute a trinomial coefficient.</span>
<span class="cm">Parameters:</span>
<span class="cm">  i - [in]</span>
<span class="cm">  j - [in]</span>
<span class="cm">  k - [in]</span>
<span class="cm">Returns:</span>
<span class="cm">  (i+j+k)!/(i!j!k!), if 0 &lt;= i, 0 &lt;= j and 0&lt;= k, and 0 otherwise.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BinomialCoefficient()</span>
<span class="cm">Remarks:</span>
<span class="cm">  The trinomial coefficient is computed using the formula</span>

<span class="cm">          (i+j+k)!      (i+j+k)!       (j+k)!</span>
<span class="cm">          --------   =  --------   *  -------</span>
<span class="cm">          i! j! k!      i! (j+k)!      j! k!</span>

<span class="cm">                      = ON_BinomialCoefficient(i,j+k)*ON_BinomialCoefficient(j,k)</span>

<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_TrinomialCoefficient</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">j</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">k</span>
          <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_GetParameterTolerance</span><span class="p">(</span>
        <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="c1">// domain</span>
        <span class="kt">double</span><span class="p">,</span>          <span class="c1">// parameter in domain</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="o">//</span> <span class="n">parameter</span> <span class="n">tolerance</span> <span class="p">(</span><span class="n">tminus</span><span class="p">,</span> <span class="n">tplus</span><span class="p">)</span> <span class="n">returned</span> <span class="n">here</span>
        <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_IsValidPointList</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
        <span class="k">const</span> <span class="kt">float</span><span class="o">*</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_IsValidPointList</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Determine if a list of points is planar.</span>
<span class="cm">Parameters:</span>
<span class="cm">  bRational - [in]</span>
<span class="cm">    false if the points are euclidean (x,y,z)</span>
<span class="cm">    true if the points are homogeneous rational (x,y,z,w)</span>
<span class="cm">  point_count - [in]</span>
<span class="cm">    number of points</span>
<span class="cm">  point_stride - [in]</span>
<span class="cm">    number of doubles between point x coordinates</span>
<span class="cm">    first point&#39;s x coordinate = points[0],</span>
<span class="cm">    second point&#39;s x coordinate = points[point_stride],...</span>
<span class="cm">  points - [in]</span>
<span class="cm">    point coordinates (3d or 4d homogeneous rational)</span>
<span class="cm">  boxMin - [in]</span>
<span class="cm">  boxMax - [in]</span>
<span class="cm">    optional 3d bounding box - pass nulls if not readily available</span>
<span class="cm">  tolerance - [in] &gt;= 0.0</span>
<span class="cm">  plane_equation0 - [in]</span>
<span class="cm">    If you want to test for planarity in a specific plane,</span>
<span class="cm">    pass the plane equation in here.  If you want to find</span>
<span class="cm">    a plane containing the points, pass null here.</span>
<span class="cm">  plane_equation - [out]</span>
<span class="cm">    If this point is not null, then the equation of the plane</span>
<span class="cm">    containing the points is retuened here.</span>
<span class="cm">Returns:</span>
<span class="cm">  0 - points are not coplanar to the specified tolerance</span>
<span class="cm">  1 - points are coplanar to the specified tolerance</span>
<span class="cm">  2 - points are colinear to the specified tolerance</span>
<span class="cm">      (in this case, plane_equation is not a unique answer)</span>
<span class="cm">  3 - points are coincident to the specified tolerance</span>
<span class="cm">      (in this case, plane_equation is not a unique answer)</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_IsPointListPlanar</span><span class="p">(</span>
    <span class="kt">bool</span> <span class="n">bRational</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">stride</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">boxMin</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">boxMax</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">tolerance</span><span class="p">,</span>
    <span class="n">ON_PlaneEquation</span><span class="o">*</span> <span class="n">plane_equation</span>
    <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_IsValidPointGrid</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_count0, point_count1,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_stride0, point_stride1,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_ReversePointList</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
        <span class="kt">double</span><span class="o">*</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_ReversePointGrid</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_count0, point_count1,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_stride0, point_stride1,</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
        <span class="kt">int</span>       <span class="c1">// dir = 0 or 1</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_SwapPointListCoordinates</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// count</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// stride</span>
        <span class="kt">float</span><span class="o">*</span><span class="p">,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="c1">// coordinates to swap</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_SwapPointListCoordinates</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// count</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// stride</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="c1">// coordinates to swap</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_SwapPointGridCoordinates</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_count0, point_count1,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_stride0, point_stride1,</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="c1">// coordinates to swap</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_TransformPointList</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
        <span class="kt">float</span><span class="o">*</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_TransformPointList</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_TransformPointGrid</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>      <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span>     <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_count0, point_count1,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_stride0, point_stride1,</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_TransformVectorList</span><span class="p">(</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
       <span class="kt">float</span><span class="o">*</span><span class="p">,</span>
       <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span>
       <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_TransformVectorList</span><span class="p">(</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
       <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
       <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span>
       <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in]</span>
<span class="cm">    &gt;= 1</span>
<span class="cm">  is_rat - [in]</span>
<span class="cm">    true if the points are rational and points[dim] is the &quot;weight&quot;</span>
<span class="cm">  pointA - [in]</span>
<span class="cm">  pointB - [in]</span>
<span class="cm">    point coordinates</span>
<span class="cm">Returns:</span>
<span class="cm">  True if the input is valid and for each coordinate pair,</span>
<span class="cm">  |a-b| &lt;= ON_ZERO_TOLERANCE</span>
<span class="cm">  or |a-b| &lt;= (fabs(a)+fabs(b))*ON_RELATIVE_TOLERANCE.</span>
<span class="cm">  False otherwise.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_PointsAreCoincident</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">is_rat</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">pointA</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">pointB</span>
    <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description</span>
<span class="cm">  See ON_PointsAreCoincident() for a description of when opennurbs</span>
<span class="cm">  considers two points to be conincident.</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in]</span>
<span class="cm">    &gt;= 1</span>
<span class="cm">  is_rat - [in]</span>
<span class="cm">    true if the points are rational and points[dim] is the &quot;weight&quot;</span>
<span class="cm">  point_count - [in]</span>
<span class="cm">    number of points &gt;= 2</span>
<span class="cm">  point_stride - [in]</span>
<span class="cm">    &gt;= (0 != is_rat) ? (dim+1) : dim</span>
<span class="cm">  points - [in]</span>
<span class="cm">    point coordinates</span>
<span class="cm">Returns:</span>
<span class="cm">  True if the first and last points are coincident and all other</span>
<span class="cm">  points in the list are coincident with the previous point.</span>
<span class="cm">  False if there are points that are not coincident or</span>
<span class="cm">  point_count &lt; 2 or other input parameters are invalid.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_PointsAreCoincident</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">is_rat</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">point_count</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">point_stride</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">points</span>
    <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_ComparePoint</span><span class="p">(</span> <span class="c1">// returns</span>
                              <span class="c1">// -1: first &lt; second</span>
                              <span class="c1">//  0: first == second</span>
                              <span class="c1">// +1: first &gt; second</span>
          <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>            <span class="o">//</span> <span class="n">dim</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">ON_BOOL32</span> <span class="n">israt</span><span class="p">,</span>    <span class="c1">// true for rational CVs</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">cv0</span><span class="p">,</span>  <span class="c1">// first CV</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">cv1</span>   <span class="c1">// secont CV</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_ComparePointList</span><span class="p">(</span> <span class="c1">// returns</span>
                              <span class="c1">// -1: first &lt; second</span>
                              <span class="c1">//  0: first == second</span>
                              <span class="c1">// +1: first &gt; second</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">dim</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">ON_BOOL32</span><span class="p">,</span>          <span class="c1">// true for rational CVs</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// count</span>
          <span class="c1">// first point list</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// stride</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// point</span>
          <span class="c1">// second point list</span>
          <span class="kt">int</span><span class="p">,</span>           <span class="c1">// stride</span>
          <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// point</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_IsPointListClosed</span><span class="p">(</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// true for homogeneos rational points</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// count</span>
       <span class="kt">int</span><span class="p">,</span>  <span class="c1">// stride</span>
       <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>
       <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_IsPointGridClosed</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>  <span class="c1">// dim</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for homogeneous rational points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_count0, point_count1,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// point_stride0, point_stride1,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span>
        <span class="kt">int</span>       <span class="c1">// dir = 0 or 1</span>
       <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_SolveQuadraticEquation</span><span class="p">(</span> <span class="c1">// solve a*X^2 + b*X + c = 0</span>
        <span class="o">//</span> <span class="n">returns</span> <span class="mi">0</span><span class="o">:</span> <span class="n">two</span> <span class="n">distinct</span> <span class="n">real</span> <span class="n">roots</span> <span class="p">(</span><span class="n">r0</span> <span class="o">&lt;</span> <span class="n">r1</span><span class="p">)</span>
        <span class="c1">//         1: one real root (r0 = r1)</span>
        <span class="c1">//         2: two complex conjugate roots (r0 +/- (r1)*sqrt(-1))</span>
        <span class="c1">//        -1: failure - a = 0, b != 0        (r0 = r1 = -c/b)</span>
        <span class="c1">//        -2: failure - a = 0, b  = 0 c != 0 (r0 = r1 = 0.0)</span>
        <span class="c1">//        -3: failure - a = 0, b  = 0 c  = 0 (r0 = r1 = 0.0)</span>
       <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="c1">// a, b, c</span>
       <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span>        <span class="c1">// roots r0 and r1 returned here</span>
       <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_SolveTriDiagonal</span><span class="p">(</span> <span class="o">//</span> <span class="n">solve</span> <span class="n">TriDiagMatrix</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="p">)</span><span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="n">d</span>
        <span class="kt">int</span><span class="p">,</span>               <span class="c1">// dimension of d and X (&gt;=1)</span>
        <span class="kt">int</span><span class="p">,</span>               <span class="c1">// number of equations (&gt;=2)</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>           <span class="c1">// a[n-1] = sub-diagonal (a is modified)</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span>     <span class="c1">// b[n] = diagonal</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>           <span class="c1">// c[n-1] = supra-diagonal</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span>     <span class="c1">// d[n*dim]</span>
        <span class="kt">double</span><span class="o">*</span>            <span class="c1">// X[n*dim] = unknowns</span>
        <span class="p">);</span>

<span class="c1">// returns rank - if rank != 2, system is under determined</span>
<span class="c1">// If rank = 2, then solution to</span>
<span class="c1">//</span>
<span class="c1">//          a00*x0 + a01*x1 = b0,</span>
<span class="c1">//          a10*x0 + a11*x1 = b1</span>
<span class="c1">//</span>
<span class="c1">// is returned</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Solve2x2</span><span class="p">(</span>
        <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span>   <span class="c1">// a00 a01 = first row of 2x2 matrix</span>
        <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span>   <span class="c1">// a10 a11 = second row of 2x2 matrix</span>
        <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span>   <span class="c1">// b0 b1</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// x0, x1 if not NULL, then solution is returned here</span>
        <span class="kt">double</span><span class="o">*</span>           <span class="c1">// if not NULL, then pivot_ratio returned here</span>
        <span class="p">);</span>

<span class="c1">// Description:</span>
<span class="c1">//   Solves a system of 3 linear equations and 2 unknowns.</span>
<span class="c1">//</span>
<span class="c1">//          x*col0[0] + y*col1[0] = d0</span>
<span class="c1">//          x*col0[1] + y*col1[1] = d0</span>
<span class="c1">//          x*col0[2] + y*col1[2] = d0</span>
<span class="c1">//</span>
<span class="c1">// Parameters:</span>
<span class="c1">//   col0 - [in] coefficents for &quot;x&quot; unknown</span>
<span class="c1">//   col1 - [in] coefficents for &quot;y&quot; unknown</span>
<span class="c1">//   d0 - [in] constants</span>
<span class="c1">//   d1 - [in]</span>
<span class="c1">//   d2 - [in]</span>
<span class="c1">//   x - [out]</span>
<span class="c1">//   y - [out]</span>
<span class="c1">//   error - [out]</span>
<span class="c1">//   pivot_ratio - [out]</span>
<span class="c1">//</span>
<span class="c1">// Returns:</span>
<span class="c1">//   rank of the system.</span>
<span class="c1">//   If rank != 2, system is under determined</span>
<span class="c1">//   If rank = 2, then the solution is</span>
<span class="c1">//</span>
<span class="c1">//         (*x)*[col0] + (*y)*[col1]</span>
<span class="c1">//         + (*error)*((col0 X col1)/|col0 X col1|)</span>
<span class="c1">//         = (d0,d1,d2).</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Solve3x2</span><span class="p">(</span>
        <span class="k">const</span> <span class="kt">double</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="c1">// col0</span>
        <span class="k">const</span> <span class="kt">double</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="c1">// col1</span>
        <span class="kt">double</span><span class="p">,</span>  <span class="c1">// d0</span>
        <span class="kt">double</span><span class="p">,</span>  <span class="c1">// d1</span>
        <span class="kt">double</span><span class="p">,</span>  <span class="c1">// d2</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// x</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// y</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// error</span>
        <span class="kt">double</span><span class="o">*</span>  <span class="c1">// pivot_ratio</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Use Gauss-Jordan elimination with full pivoting to solve</span>
<span class="cm">  a system of 3 linear equations and 3 unknowns(x,y,z)</span>

<span class="cm">        x*row0[0] + y*row0[1] + z*row0[2] = d0</span>
<span class="cm">        x*row1[0] + y*row1[1] + z*row1[2] = d1</span>
<span class="cm">        x*row2[0] + y*row2[1] + z*row2[2] = d2</span>

<span class="cm">Parameters:</span>
<span class="cm">    row0 - [in] first row of 3x3 matrix</span>
<span class="cm">    row1 - [in] second row of 3x3 matrix</span>
<span class="cm">    row2 - [in] third row of 3x3 matrix</span>
<span class="cm">    d0 - [in]</span>
<span class="cm">    d1 - [in]</span>
<span class="cm">    d2 - [in] (d0,d1,d2) right hand column of system</span>
<span class="cm">    x_addr - [in] first unknown</span>
<span class="cm">    y_addr - [in] second unknown</span>
<span class="cm">    z_addr - [in] third unknown</span>
<span class="cm">    pivot_ratio - [out] if not NULL, the pivot ration is</span>
<span class="cm">         returned here.  If the pivot ratio is &quot;small&quot;,</span>
<span class="cm">         then the matrix may be singular or ill</span>
<span class="cm">         conditioned. You should test the results</span>
<span class="cm">         before you use them.  &quot;Small&quot; depends on the</span>
<span class="cm">         precision of the input coefficients and the</span>
<span class="cm">         use of the solution.  If you can&#39;t figure out</span>
<span class="cm">         what &quot;small&quot; means in your case, then you</span>
<span class="cm">         must check the solution before you use it.</span>

<span class="cm">Returns:</span>
<span class="cm">    The rank of the 3x3 matrix (0,1,2, or 3)</span>
<span class="cm">    If ON_Solve3x3() is successful (returns 3), then</span>
<span class="cm">    the solution is returned in</span>
<span class="cm">    (*x_addr, *y_addr, *z_addr)</span>
<span class="cm">    and *pivot_ratio = min(|pivots|)/max(|pivots|).</span>
<span class="cm">    If the return code is &lt; 3, then (0,0,0) is returned</span>
<span class="cm">    as the &quot;solution&quot;.</span>

<span class="cm">See Also:</span>
<span class="cm">  ON_Solve2x2</span>
<span class="cm">  ON_Solve3x2</span>
<span class="cm">  ON_Solve4x4</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Solve3x3</span><span class="p">(</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="n">row0</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="n">row1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="n">row2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="kt">double</span> <span class="n">d0</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">d1</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">d2</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">x_addr</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">y_addr</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">z_addr</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">pivot_ratio</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Use Gauss-Jordan elimination with full pivoting to solve</span>
<span class="cm">  a system of 4 linear equations and 4 unknowns(x,y,z,w)</span>

<span class="cm">        x*row0[0] + y*row0[1] + z*row0[2] + w*row0[3] = d0</span>
<span class="cm">        x*row1[0] + y*row1[1] + z*row1[2] + w*row1[3] = d1</span>
<span class="cm">        x*row2[0] + y*row2[1] + z*row2[2] + w*row2[3] = d2</span>
<span class="cm">        x*row3[0] + y*row3[1] + z*row3[2] + w*row3[2] = d3</span>

<span class="cm">Parameters:</span>
<span class="cm">    row0 - [in] first row of 4x4 matrix</span>
<span class="cm">    row1 - [in] second row of 4x4 matrix</span>
<span class="cm">    row2 - [in] third row of 4x4 matrix</span>
<span class="cm">    row3 - [in] forth row of 4x4 matrix</span>
<span class="cm">    d0 - [in]</span>
<span class="cm">    d1 - [in]</span>
<span class="cm">    d2 - [in]</span>
<span class="cm">    d3 - [in] (d0,d1,d2,d3) right hand column of system</span>
<span class="cm">    x_addr - [in] first unknown</span>
<span class="cm">    y_addr - [in] second unknown</span>
<span class="cm">    z_addr - [in] third unknown</span>
<span class="cm">    w_addr - [in] forth unknown</span>
<span class="cm">    pivot_ratio - [out] if not NULL, the pivot ration is</span>
<span class="cm">         returned here.  If the pivot ratio is &quot;small&quot;,</span>
<span class="cm">         then the matrix may be singular or ill</span>
<span class="cm">         conditioned. You should test the results</span>
<span class="cm">         before you use them.  &quot;Small&quot; depends on the</span>
<span class="cm">         precision of the input coefficients and the</span>
<span class="cm">         use of the solution.  If you can&#39;t figure out</span>
<span class="cm">         what &quot;small&quot; means in your case, then you</span>
<span class="cm">         must check the solution before you use it.</span>

<span class="cm">Returns:</span>
<span class="cm">    The rank of the 4x4 matrix (0,1,2,3, or 4)</span>
<span class="cm">    If ON_Solve4x4() is successful (returns 4), then</span>
<span class="cm">    the solution is returned in</span>
<span class="cm">    (*x_addr, *y_addr, *z_addr, *w_addr)</span>
<span class="cm">    and *pivot_ratio = min(|pivots|)/max(|pivots|).</span>
<span class="cm">    If the return code is &lt; 4, then, it a solution exists,</span>
<span class="cm">    on is returned.  However YOU MUST CHECK THE SOLUTION</span>
<span class="cm">    IF THE RETURN CODE IS &lt; 4.</span>

<span class="cm">See Also:</span>
<span class="cm">  ON_Solve2x2</span>
<span class="cm">  ON_Solve3x2</span>
<span class="cm">  ON_Solve3x3</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span>
<span class="nf">ON_Solve4x4</span><span class="p">(</span>
          <span class="k">const</span> <span class="kt">double</span> <span class="n">row0</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
          <span class="k">const</span> <span class="kt">double</span> <span class="n">row1</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
          <span class="k">const</span> <span class="kt">double</span> <span class="n">row2</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
          <span class="k">const</span> <span class="kt">double</span> <span class="n">row3</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
          <span class="kt">double</span> <span class="n">d0</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">d1</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">d2</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">d3</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">*</span> <span class="n">x_addr</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">*</span> <span class="n">y_addr</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">*</span> <span class="n">z_addr</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">*</span> <span class="n">w_addr</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">*</span> <span class="n">pivot_ratio</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Use Gauss-Jordan elimination to find a numerical</span>
<span class="cm">  solution to M*X = B where M is a n x n matrix,</span>
<span class="cm">  B is a known n-dimensional vector and X is</span>
<span class="cm">  an unknown.</span>
<span class="cm">Paramters:</span>
<span class="cm">  bFullPivot - [in] if true, full pivoting is used,</span>
<span class="cm">    otherwise partial pivoting is used.  In rare</span>
<span class="cm">    cases full pivoting can produce a more accurate</span>
<span class="cm">    answer and never produces a less accurate answer.</span>
<span class="cm">    However full pivoting is slower.  If speed is an</span>
<span class="cm">    issue, then experiement with bFullPivot=false</span>
<span class="cm">    and see if it makes a difference.  Otherwise,</span>
<span class="cm">    set it to true.</span>
<span class="cm">  bNormalize - [in]</span>
<span class="cm">    If bNormalize is true, then the rows of the</span>
<span class="cm">    matrix are scaled so the sum of their squares</span>
<span class="cm">    is one.  This doesn&#39;t make the solution more</span>
<span class="cm">    accurate but in some cases it makes the pivot</span>
<span class="cm">    ratio more meaningful.  Set bNormalize to</span>
<span class="cm">    false unless you have a reason for setting it</span>
<span class="cm">    to true.</span>
<span class="cm">  n - [in] size of the matrix and vectors.</span>
<span class="cm">  M - [in] n x n matrix.  The values in M are</span>
<span class="cm">    changed as the solution is calculated.</span>
<span class="cm">    If you need to preserve M for future use,</span>
<span class="cm">    pass in a copy.</span>
<span class="cm">  B - [in] n-dimensional vector.  The values in</span>
<span class="cm">    B are changed as the solution is calculated.</span>
<span class="cm">    If you need to preserve B for future use,</span>
<span class="cm">    pass in a copy.</span>
<span class="cm">  X - [out] solution to M*X = B.</span>
<span class="cm">Returns:</span>
<span class="cm">  If the returned value is &lt;= 0.0, the input matrix</span>
<span class="cm">  has rank &lt; n and no solution is returned in X.</span>
<span class="cm">  If the returned value is &gt; 0.0, then a solution is</span>
<span class="cm">  returned in X and the returned value is the ratio</span>
<span class="cm">  (minimum pivot)/(maximum pivot).  This value is</span>
<span class="cm">  called the pivot ratio and will be denoted &quot;pr&quot;</span>
<span class="cm">  the discussion below. If pr &lt;= 1e-15, then</span>
<span class="cm">  M was nearly degenerate and the solution should be</span>
<span class="cm">  used with caution.  If an accurate solution is</span>
<span class="cm">  critcial, then check the solution anytime pr &lt;= 1e-10</span>
<span class="cm">  In general, the difference between M*X and B will be</span>
<span class="cm">  reasonably small.  However, when the pr is small</span>
<span class="cm">  there tend to be vector E, substantually different</span>
<span class="cm">  from zero, such that M*(X+E) - B is also reasonably</span>
<span class="cm">  small.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_Solve2x2</span>
<span class="cm">  ON_Solve3x3</span>
<span class="cm">  ON_Solve4x4</span>
<span class="cm">  ON_Solve3x2</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_SolveNxN</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bFullPivot</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bNormalize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">M</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">B</span><span class="p">[],</span> <span class="kt">double</span> <span class="n">X</span><span class="p">[]);</span>


<span class="c1">// return false if determinant is (nearly) singular</span>
<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_EvJacobian</span><span class="p">(</span>
        <span class="kt">double</span><span class="p">,</span> <span class="c1">// ds o ds</span>
        <span class="kt">double</span><span class="p">,</span> <span class="c1">// ds o dt</span>
        <span class="kt">double</span><span class="p">,</span> <span class="c1">// dt o dt</span>
        <span class="kt">double</span><span class="o">*</span> <span class="o">//</span> <span class="n">jacobian</span> <span class="o">=</span> <span class="n">determinant</span> <span class="p">(</span> <span class="n">ds_o_ds</span> <span class="n">dt_o_dt</span> <span class="o">/</span> <span class="n">ds_o_dt</span> <span class="n">ds_o_dt</span> <span class="p">)</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Finds scalars x and y so that the component of V in the plane</span>
<span class="cm">  of A and B is x*A + y*B.</span>
<span class="cm">Parameters:</span>
<span class="cm">  V - [in]</span>
<span class="cm">  A - [in] nonzero and not parallel to B</span>
<span class="cm">  B - [in] nonzero and not parallel to A</span>
<span class="cm">  x - [out]</span>
<span class="cm">  y - [out]</span>
<span class="cm">Returns:</span>
<span class="cm">  1 - The rank of the problem is 2.  The decomposition is unique.</span>
<span class="cm">  0 - The rank less than 2.  Either there is no solution or there</span>
<span class="cm">      are infinitely many solutions.</span>

<span class="cm">See Also:</span>
<span class="cm">  ON_Solve2x2</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_DecomposeVector</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">V</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">B</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">y</span>
        <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">   Evaluate partial derivatives of surface unit normal</span>
<span class="cm">Parameters:</span>
<span class="cm">  ds - [in]</span>
<span class="cm">  dt - [in] surface first partial derivatives</span>
<span class="cm">  dss - [in]</span>
<span class="cm">  dst - [in]</span>
<span class="cm">  dtt - [in] surface second partial derivatives</span>
<span class="cm">  ns - [out]</span>
<span class="cm">  nt - [out] First partial derivatives of surface unit normal</span>
<span class="cm">             (If the Jacobian is degenerate, ns and nt are set to zero.)</span>
<span class="cm">Returns:</span>
<span class="cm">  true if Jacobian is nondegenerate</span>
<span class="cm">  false if Jacobian is degenerate</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_EvNormalPartials</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">ds</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">dt</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">dss</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">dtt</span><span class="p">,</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">ns</span><span class="p">,</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">nt</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span>
<span class="nf">ON_Pullback3dVector</span><span class="p">(</span> <span class="c1">// use to pull 3d vector back to surface parameter space</span>
      <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span>   <span class="c1">// 3d vector</span>
      <span class="kt">double</span><span class="p">,</span>              <span class="c1">// signed distance from vector location to closet point on surface</span>
                                    <span class="c1">// &lt; 0 if point is below with respect to Du x Dv</span>
      <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span>     <span class="c1">// ds      surface first partials</span>
      <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span>     <span class="c1">// dt</span>
      <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span>     <span class="c1">// dss     surface 2nd partials</span>
      <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span>     <span class="o">//</span> <span class="n">dst</span>     <span class="p">(</span><span class="n">used</span> <span class="n">only</span> <span class="n">when</span> <span class="n">dist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span>     <span class="c1">// dtt</span>
      <span class="n">ON_2dVector</span><span class="o">&amp;</span>            <span class="c1">// pullback</span>
      <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span>
<span class="nf">ON_GetParameterTolerance</span><span class="p">(</span>
        <span class="kt">double</span><span class="p">,</span>   <span class="c1">// t0      domain</span>
        <span class="kt">double</span><span class="p">,</span>   <span class="c1">// t1</span>
        <span class="kt">double</span><span class="p">,</span>   <span class="c1">// t       parameter in domain</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>  <span class="o">//</span> <span class="n">tminus</span>  <span class="n">parameter</span> <span class="n">tolerance</span> <span class="p">(</span><span class="n">tminus</span><span class="p">,</span> <span class="n">tplus</span><span class="p">)</span> <span class="n">returned</span> <span class="n">here</span>
        <span class="kt">double</span><span class="o">*</span>   <span class="c1">// tplus</span>
        <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_EvNormal</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// limit_dir 0=default,1=from quadrant I, 2 = from quadrant II, ...</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="o">//</span> <span class="n">first</span> <span class="n">partials</span> <span class="p">(</span><span class="n">Du</span><span class="p">,</span><span class="n">Dv</span><span class="p">)</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// optional second partials (Duu, Duv, Dvv)</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="c1">// unit normal returned here</span>
        <span class="p">);</span>

<span class="c1">// returns false if first returned tangent is zero</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvTangent</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// first derivative</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// second derivative</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span>        <span class="c1">// Unit tangent returned here</span>
        <span class="p">);</span>

<span class="c1">// returns false if first derivtive is zero</span>
<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_EvCurvature</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// first derivative</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// second derivative</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span>       <span class="c1">// Unit tangent returned here</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span>        <span class="c1">// Curvature returned here</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_EvPrincipalCurvatures</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// Ds,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// Dt,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// Dss,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// Dst,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// Dtt,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="o">//</span> <span class="n">N</span><span class="p">,</span>   <span class="o">//</span> <span class="n">unit</span> <span class="n">normal</span> <span class="n">to</span> <span class="n">surface</span> <span class="p">(</span><span class="n">use</span> <span class="n">ON_EvNormal</span><span class="p">())</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// gauss,  // = Gaussian curvature = kappa1*kappa2</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// mean,   // = mean curvature = (kappa1+kappa2)/2</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// kappa1, // = largest principal curvature value (may be negative)</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// kappa2, // = smallest principal curvature value (may be negative)</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// K1,     // kappa1 unit principal curvature direction</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span>  <span class="c1">// K2      // kappa2 unit principal curvature direction</span>
                        <span class="c1">// output K1,K2,N is right handed frame</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_EvPrincipalCurvatures</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// Ds,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// Dt,</span>
        <span class="kt">double</span> <span class="n">l</span><span class="p">,</span> <span class="c1">// Dss*N Second fundamental form coefficients</span>
        <span class="kt">double</span> <span class="n">m</span><span class="p">,</span> <span class="c1">// Dst*N,</span>
        <span class="kt">double</span> <span class="n">n</span><span class="p">,</span> <span class="c1">// Dtt*N,</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="o">//</span> <span class="n">N</span><span class="p">,</span>   <span class="o">//</span> <span class="n">unit</span> <span class="n">normal</span> <span class="n">to</span> <span class="n">surface</span> <span class="p">(</span><span class="n">use</span> <span class="n">ON_EvNormal</span><span class="p">())</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// gauss,  // = Gaussian curvature = kappa1*kappa2</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// mean,   // = mean curvature = (kappa1+kappa2)/2</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// kappa1, // = largest principal curvature value (may be negative)</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// kappa2, // = smallest principal curvature value (may be negative)</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// K1,     // kappa1 unit principal curvature direction</span>
        <span class="n">ON_3dVector</span><span class="o">&amp;</span>  <span class="c1">// K2      // kappa2 unit principal curvature direction</span>
                        <span class="c1">// output K1,K2,N is right handed frame</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Evaluate sectional curvature from surface derivatives and</span>
<span class="cm">  section plane normal.</span>
<span class="cm">Parameters:</span>
<span class="cm">  S10, S01 - [in]</span>
<span class="cm">    surface 1st partial derivatives</span>
<span class="cm">  S20, S11, S02 - [in]</span>
<span class="cm">    surface 2nd partial derivatives</span>
<span class="cm">  planeNormal - [in]</span>
<span class="cm">    unit normal to section plane</span>
<span class="cm">  K - [out] Sectional curvature</span>
<span class="cm">    Curvature of the intersection curve of the surface</span>
<span class="cm">    and plane through the surface point where the partial</span>
<span class="cm">    derivatives were evaluationed.</span>
<span class="cm">Returns:</span>
<span class="cm">  True if successful.</span>
<span class="cm">  False if first partials are not linearly independent, in</span>
<span class="cm">  which case the K is set to zero.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvSectionalCurvature</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">S10</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">S01</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">S20</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">S11</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">S02</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">planeNormal</span><span class="p">,</span>
    <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">K</span>
    <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="n">ON_3dVector</span> <span class="nf">ON_NormalCurvature</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="o">//</span> <span class="n">surface</span> <span class="mi">1</span><span class="n">rst</span> <span class="n">partial</span> <span class="p">(</span><span class="n">Ds</span><span class="p">)</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// surface 1rst partial (Dt)</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// surface 1rst partial (Dss)</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// surface 1rst partial (Dst)</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// surface 1rst partial (Dtt)</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// surface unit normal</span>
        <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span>  <span class="c1">// unit tangent direction</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Determing if two curvatrues are different enough</span>
<span class="cm">  to qualify as a curvature discontinuity.</span>
<span class="cm">Parameters:</span>
<span class="cm">  Km - [in]</span>
<span class="cm">  Kp - [in]</span>
<span class="cm">    Km and Kp should be curvatures evaluated at the same</span>
<span class="cm">    parameters using limits from below (minus) and above (plus).</span>
<span class="cm">    The assumption is that you have already compared the</span>
<span class="cm">    points and tangents and consider to curve to be G1 at the</span>
<span class="cm">    point in question.</span>
<span class="cm">  cos_angle_tolerance - [in]</span>
<span class="cm">    If the inut value of cos_angle_tolerance &gt;= -1.0</span>
<span class="cm">    and cos_angle_tolerance &lt;= 1.0 and</span>
<span class="cm">    Km o Kp &lt; cos_angle_tolerance*|Km|*|Kp|, then</span>
<span class="cm">    true is returned.  Otherwise it is assumed Km and Kp</span>
<span class="cm">    are parallel. If the curve being tested is nonplanar,</span>
<span class="cm">    then use something like cos(2*tangent angle tolerance)</span>
<span class="cm">    for this parameter. If the curve being tested is planar,</span>
<span class="cm">    then 0.0 will work fine.</span>
<span class="cm">  curvature_tolerance - [in]</span>
<span class="cm">    If |Kp-Km| &lt;= curvature_tolerance,</span>
<span class="cm">    then false is returned, otherwise other tests are used</span>
<span class="cm">    to determing continuity.</span>
<span class="cm">  zero_curvature - [in] (ignored if &lt; 2^-110 = 7.7037197787136e-34)</span>
<span class="cm">    If |K| &lt;= zero_curvature, then K is treated as zero.</span>
<span class="cm">    When in doubt, use ON_ZERO_CURVATURE_TOLERANCE.</span>
<span class="cm">  radius_tolerance - [in]</span>
<span class="cm">    If radius_tolerance &gt;= 0.0 and the difference between the</span>
<span class="cm">    radii of curvature is &gt;= radius_tolerance, then true</span>
<span class="cm">    is returned.</span>
<span class="cm">  relative_tolerance - [in]</span>
<span class="cm">    If relative_tolerance &gt; 0 and</span>
<span class="cm">    |(|Km| - |Kp|)|/max(|Km|,|Kp|) &gt; relative_tolerance,</span>
<span class="cm">    then true is returned.  Note that if the curvatures are</span>
<span class="cm">    nonzero and rm and rp are the radii of curvature, then</span>
<span class="cm">    |(|Km| - |Kp|)|/max(|Km|,|Kp|) = |rm-rp|/max(rm,rp).</span>
<span class="cm">    This means the relative_tolerance insures both the scalar</span>
<span class="cm">    curvature and the radii of curvature agree to the specified</span>
<span class="cm">    number of decimal places.</span>
<span class="cm">    When in double use ON_RELATIVE_CURVATURE_TOLERANCE, which</span>
<span class="cm">    is currently 0.05.</span>
<span class="cm">Returns:</span>
<span class="cm">  False if the curvatures should be considered G2.</span>
<span class="cm">  True if the curvatures are different enough that the curve should be</span>
<span class="cm">  considered not G2.</span>
<span class="cm">  In addition to the tests described under the curvature_tolerance and</span>
<span class="cm">  radius_tolerance checks, other hurestic tests are used.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IsCurvatureDiscontinuity</span><span class="p">(</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Km</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Kp</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">cos_angle_tolerance</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">curvature_tolerance</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">zero_curvature</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">radius_tolerance</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">relative_tolerance</span>
  <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IsCurvatureDiscontinuity</span><span class="p">(</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Km</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Kp</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">cos_angle_tolerance</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">curvature_tolerance</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">zero_curvature</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">radius_tolerance</span>
  <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  This function is used to test curvature continuity</span>
<span class="cm">  in IsContinuous and GetNextDiscontinuity functions</span>
<span class="cm">  when the continuity parameter is ON::G2_continuous.</span>
<span class="cm">Parameters:</span>
<span class="cm">  Km - [in]</span>
<span class="cm">    Curve&#39;s vector curvature evaluated from below</span>
<span class="cm">  Kp - [in]</span>
<span class="cm">    Curve&#39;s vector curvature evaluated from below</span>
<span class="cm">Returns:</span>
<span class="cm">  True if the change from Km to Kp should be considered</span>
<span class="cm">  G2 continuous.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IsG2CurvatureContinuous</span><span class="p">(</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Km</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Kp</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">cos_angle_tolerance</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">curvature_tolerance</span>
  <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  This function is used to test curvature continuity</span>
<span class="cm">  in IsContinuous and GetNextDiscontinuity functions</span>
<span class="cm">  when the continuity parameter is ON::Gsmooth_continuous.</span>
<span class="cm">Parameters:</span>
<span class="cm">  Km - [in]</span>
<span class="cm">    Curve&#39;s vector curvature evaluated from below</span>
<span class="cm">  Kp - [in]</span>
<span class="cm">    Curve&#39;s vector curvature evaluated from below</span>
<span class="cm">Returns:</span>
<span class="cm">  True if the change from Km to Kp should be considered</span>
<span class="cm">  Gsmooth continuous.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IsGsmoothCurvatureContinuous</span><span class="p">(</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Km</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">ON_3dVector</span> <span class="n">Kp</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">cos_angle_tolerance</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">curvature_tolerance</span>
  <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Test curve continuity from derivative values.</span>
<span class="cm">Parameters:</span>
<span class="cm">  c - [in] type of continuity to test for. Read ON::continuity</span>
<span class="cm">           comments for details.</span>
<span class="cm">  Pa - [in] point on curve A.</span>
<span class="cm">  D1a - [in] first derviative of curve A.</span>
<span class="cm">  D2a - [in] second derviative of curve A.</span>
<span class="cm">  Pb - [in] point on curve B.</span>
<span class="cm">  D1b - [in] first derviative of curve B.</span>
<span class="cm">  D3b - [in] second derviative of curve B.</span>
<span class="cm">  point_tolerance - [in] if the distance between two points is</span>
<span class="cm">      greater than point_tolerance, then the curve is not C0.</span>
<span class="cm">  d1_tolerance - [in] if the difference between two first derivatives is</span>
<span class="cm">      greater than d1_tolerance, then the curve is not C1.</span>
<span class="cm">  d2_tolerance - [in] if the difference between two second derivatives is</span>
<span class="cm">      greater than d2_tolerance, then the curve is not C2.</span>
<span class="cm">  cos_angle_tolerance - [in] default = cos(1 degree) Used only when</span>
<span class="cm">      c is ON::G1_continuous or ON::G2_continuous.  If the cosine</span>
<span class="cm">      of the angle between two tangent vectors</span>
<span class="cm">      is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.</span>
<span class="cm">  curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when</span>
<span class="cm">      c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated</span>
<span class="cm">      from above and below and |K0 - K1| &gt; curvature_tolerance,</span>
<span class="cm">      then a curvature discontinuity is reported.</span>
<span class="cm">Returns:</span>
<span class="cm">  true if the curve has at least the c type continuity at</span>
<span class="cm">  the parameter t.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_BOOL32</span> <span class="nf">ON_IsContinuous</span><span class="p">(</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">continuity</span> <span class="n">c</span><span class="p">,</span>
  <span class="n">ON_3dPoint</span> <span class="n">Pa</span><span class="p">,</span>
  <span class="n">ON_3dVector</span> <span class="n">D1a</span><span class="p">,</span>
  <span class="n">ON_3dVector</span> <span class="n">D2a</span><span class="p">,</span>
  <span class="n">ON_3dPoint</span> <span class="n">Pb</span><span class="p">,</span>
  <span class="n">ON_3dVector</span> <span class="n">D1b</span><span class="p">,</span>
  <span class="n">ON_3dVector</span> <span class="n">D2b</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">point_tolerance</span><span class="o">=</span><span class="n">ON_ZERO_TOLERANCE</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">d1_tolerance</span><span class="o">=</span><span class="n">ON_ZERO_TOLERANCE</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">d2_tolerance</span><span class="o">=</span><span class="n">ON_ZERO_TOLERANCE</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">cos_angle_tolerance</span><span class="o">=</span><span class="n">ON_DEFAULT_ANGLE_TOLERANCE_COSINE</span><span class="p">,</span>
  <span class="kt">double</span> <span class="n">curvature_tolerance</span><span class="o">=</span><span class="n">ON_SQRT_EPSILON</span>
  <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_TuneupEvaluationParameter</span><span class="p">(</span>
   <span class="kt">int</span> <span class="n">side</span><span class="p">,</span>
   <span class="kt">double</span> <span class="n">s0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">s1</span><span class="p">,</span> <span class="c1">// segment domain</span>
   <span class="kt">double</span> <span class="o">*</span><span class="n">s</span>             <span class="c1">// segment parameter</span>
   <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Compare2dex</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_2dex</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_2dex</span><span class="o">*</span> <span class="n">b</span><span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Compare3dex</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dex</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_3dex</span><span class="o">*</span> <span class="n">b</span><span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Compare4dex</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_4dex</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_4dex</span><span class="o">*</span> <span class="n">b</span><span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="k">const</span> <span class="n">ON_2dex</span><span class="o">*</span> <span class="nf">ON_BinarySearch2dexArray</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">key_i</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_2dex</span><span class="o">*</span> <span class="n">base</span><span class="p">,</span>
          <span class="kt">size_t</span> <span class="n">nel</span>
          <span class="p">);</span>

<span class="c1">// These simple intersectors are fast and detect transverse intersections.</span>
<span class="c1">// If the intersection is not a simple transverse case, then they</span>
<span class="c1">// return false and you will have to use one of the slower but fancier</span>
<span class="c1">// models.</span>

<span class="c1">// returns closest points between the two infinite lines</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// parameter on first line</span>
          <span class="kt">double</span><span class="o">*</span>  <span class="c1">// parameter on second line</span>
          <span class="p">);</span>

<span class="c1">// Returns false unless intersection is a single point</span>
<span class="c1">// If returned parameter is &lt; 0 or &gt; 1, then the line</span>
<span class="c1">// segment between line.m_point[0] and line.m_point[1]</span>
<span class="c1">// does not intersect the plane</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">*</span> <span class="c1">// parameter on line</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="n">ON_Line</span><span class="o">&amp;</span> <span class="c1">// intersection line is returned here</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="c1">// intersection point is returned here</span>
        <span class="p">);</span>

<span class="c1">// returns 0 = no intersections,</span>
<span class="c1">// 1 = intersection = single point,</span>
<span class="c1">// 2 = intersection = circle</span>
<span class="c1">// If 0 is returned, returned circle has radius=0</span>
<span class="c1">// and center = point on sphere closest to plane.</span>
<span class="c1">// If 1 is returned, intersection is a single</span>
<span class="c1">// point and returned circle has radius=0</span>
<span class="c1">// and center = intersection point on sphere.</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
                 <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_Sphere</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_Circle</span><span class="o">&amp;</span>
                  <span class="p">);</span>

<span class="c1">// Intersects an infinte line and sphere and returns</span>
<span class="c1">// 0 = no intersections,</span>
<span class="c1">// 1 = one intersection,</span>
<span class="c1">// 2 = 2 intersections</span>
<span class="c1">// If 0 is returned, first point is point</span>
<span class="c1">// on line closest to sphere and 2nd point is the point</span>
<span class="c1">// on the sphere closest to the line.</span>
<span class="c1">// If 1 is returned, first point is obtained by evaluating</span>
<span class="c1">// the line and the second point is obtained by evaluating</span>
<span class="c1">// the sphere.</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_Sphere</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="n">ON_3dPoint</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="o">//</span> <span class="n">intersection</span> <span class="n">point</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">returned</span> <span class="n">here</span>
        <span class="p">);</span>


<span class="c1">// Intersects an infinte line and cylinder and returns</span>
<span class="c1">// 0 = no intersections,</span>
<span class="c1">// 1 = one intersection,</span>
<span class="c1">// 2 = 2 intersections</span>
<span class="c1">// 3 = line lies on cylinder</span>
<span class="c1">//</span>
<span class="c1">// If 0 is returned, first point is point</span>
<span class="c1">// on line closest to cylinder and 2nd point is the point</span>
<span class="c1">// on the cylinder closest to the line.</span>
<span class="c1">// If 1 is returned, first point is obtained by evaluating</span>
<span class="c1">// the line and the second point is obtained by evaluating</span>
<span class="c1">// the cylinder.</span>
<span class="c1">//</span>
<span class="c1">// The value of cylinder.IsFinite() determines if the</span>
<span class="c1">// intersection is performed on the finite or infinite cylinder.</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// [in]</span>
      <span class="k">const</span> <span class="n">ON_Cylinder</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// [in]</span>
      <span class="n">ON_3dPoint</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// [out] first intersection point</span>
      <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="c1">// [out] second intersection point</span>
      <span class="p">);</span>

<span class="c1">// Description:</span>
<span class="c1">//   Intersect an infinte line and circle.</span>
<span class="c1">// Parameters:</span>
<span class="c1">//   line - [in]</span>
<span class="c1">//   circle - [in]</span>
<span class="c1">//   line_t0 - [out] line parameter of first intersection point</span>
<span class="c1">//   circle_point0 - [out] first intersection point on circle</span>
<span class="c1">//   line_t1 - [out] line parameter of second intersection point</span>
<span class="c1">//   circle_point1 - [out] second intersection point on circle</span>
<span class="c1">// Returns:</span>
<span class="c1">//   0     No intersection</span>
<span class="c1">//   1     One intersection at line.PointAt(*line_t0)</span>
<span class="c1">//   2     Two intersections at line.PointAt(*line_t0)</span>
<span class="c1">//         and line.PointAt(*line_t1).</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
                  <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span> <span class="n">line</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">ON_Circle</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">line_t0</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">circle_point0</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">line_t1</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">circle_point1</span>
                  <span class="p">);</span>



<span class="c1">// Description:</span>
<span class="c1">//   Intersect a infinte line and arc.</span>
<span class="c1">// Parameters:</span>
<span class="c1">//   line - [in]</span>
<span class="c1">//   arc - [in]</span>
<span class="c1">//   line_t0 - [out] line parameter of first intersection point</span>
<span class="c1">//   arc_point0 - [out] first intersection point on arc</span>
<span class="c1">//   line_t1 - [out] line parameter of second intersection point</span>
<span class="c1">//   arc_point1 - [out] second intersection point on arc</span>
<span class="c1">// Returns:</span>
<span class="c1">//   0     No intersection</span>
<span class="c1">//   1     One intersection at line.PointAt(*line_t0)</span>
<span class="c1">//   2     Two intersections at line.PointAt(*line_t0)</span>
<span class="c1">//         and line.PointAt(*line_t1).</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
                  <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span> <span class="n">line</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">ON_Arc</span><span class="o">&amp;</span> <span class="n">arc</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">line_t0</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">arc_point0</span><span class="p">,</span>
                  <span class="kt">double</span><span class="o">*</span> <span class="n">line_t1</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">arc_point1</span>
                  <span class="p">);</span>

<span class="c1">// Description:</span>
<span class="c1">//   Intersect a plane and a circle.</span>
<span class="c1">// Parameters:</span>
<span class="c1">//   plane - [in]</span>
<span class="c1">//   circle - [in]</span>
<span class="c1">//   point0 - [out] first intersection point</span>
<span class="c1">//   point1 - [out] second intersection point</span>
<span class="c1">// Returns:</span>
<span class="c1">//   0     No intersection</span>
<span class="c1">//   1     One intersection at point0</span>
<span class="c1">//   2     Two intersections at point0</span>
<span class="c1">//         and point1.</span>
<span class="c1">//   3     Circle lies on plane</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
                  <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">ON_Circle</span><span class="o">&amp;</span> <span class="n">circle</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">point0</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">point1</span>
                  <span class="p">);</span>

<span class="c1">// Description:</span>
<span class="c1">//   Intersect a plane and an arc.</span>
<span class="c1">// Parameters:</span>
<span class="c1">//   plane - [in]</span>
<span class="c1">//   arc - [in]</span>
<span class="c1">//   point0 - [out] first intersection point</span>
<span class="c1">//   point1 - [out] second intersection point</span>
<span class="c1">// Returns:</span>
<span class="c1">//   0     No intersection</span>
<span class="c1">//   1     One intersection at point0</span>
<span class="c1">//   2     Two intersections at point0</span>
<span class="c1">//         and point1.</span>
<span class="c1">//   3     Arc lies on plane</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_Intersect</span><span class="p">(</span>
                  <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">ON_Arc</span><span class="o">&amp;</span> <span class="n">arc</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">point0</span><span class="p">,</span>
                  <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">point1</span>
                  <span class="p">);</span>


<span class="c1">// returns 0 = no, 1 = yes, 2 = points are coincident and on line</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_ArePointsOnLine</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// dimension of points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// is_rat = true if homogeneous rational</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// count = number of points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="o">//</span> <span class="n">stride</span> <span class="p">(</span> <span class="o">&gt;=</span> <span class="n">is_rat</span><span class="o">?</span><span class="p">(</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// point array</span>
        <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// if needed, use ON_GetBoundingBox(dim,is_rat,count,stride,point)</span>
        <span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="kt">double</span>         <span class="c1">// tolerance (if 0.0, a tolerance based on bounding box size is used)</span>
        <span class="p">);</span>

<span class="c1">// returns 0 = no, 1 = yes, 2 = points are coincident and on line</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_ArePointsOnPlane</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// dimension of points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// is_rat = true if homogeneous rational</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// count = number of points</span>
        <span class="kt">int</span><span class="p">,</span> <span class="o">//</span> <span class="n">stride</span> <span class="p">(</span> <span class="o">&gt;=</span> <span class="n">is_rat</span><span class="o">?</span><span class="p">(</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// point array</span>
        <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// if needed, use ON_GetBoundingBox(dim,is_rat,count,stride,point)</span>
        <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="kt">double</span>         <span class="c1">// tolerance (if 0.0, a tolerance based on bounding box size is used)</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Use the quotient rule to compute derivatives of a one parameter</span>
<span class="cm">  rational function F(t) = X(t)/W(t), where W is a scalar</span>
<span class="cm">  and F and X are vectors of dimension dim.</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in]</span>
<span class="cm">  der_count - [in] number of derivative (&gt;=0)</span>
<span class="cm">  v_stride - [in] (&gt;= dim+1)</span>
<span class="cm">  v - [in/out]</span>
<span class="cm">    v[] is an array of length (der_count+1)*v_stride.</span>
<span class="cm">    The input v[] array contains  derivatives of the numerator and</span>
<span class="cm">    denominator functions in the order (X, W), (Xt, Wt), (Xtt, Wtt), ...</span>
<span class="cm">    In general, the (dim+1) coordinates of the d-th derivative</span>
<span class="cm">    are in (v[n],...,v[n+dim]) where n = d*v_stride.</span>
<span class="cm">    In the output v[] array the derivatives of X are replaced with</span>
<span class="cm">    the derivatives of F and the derivatives of W are divided by</span>
<span class="cm">    w = v[dim].</span>
<span class="cm">Returns:</span>
<span class="cm">  True if input is valid; i.e., v[dim] != 0.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_EvaluateQuotientRule2</span>
<span class="cm">  ON_EvaluateQuotientRule3</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateQuotientRule</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">der_count</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">v_stride</span><span class="p">,</span>
          <span class="kt">double</span> <span class="o">*</span><span class="n">v</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Use the quotient rule to compute partial derivatives of a two parameter</span>
<span class="cm">  rational function F(s,t) = X(s,t)/W(s,t), where W is a scalar</span>
<span class="cm">  and F and X are vectors of dimension dim.</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in]</span>
<span class="cm">  der_count - [in] number of derivative (&gt;=0)</span>
<span class="cm">  v_stride - [in] (&gt;= dim+1)</span>
<span class="cm">  v - [in/out]</span>
<span class="cm">    v[] is an array of length (der_count+2)*(der_count+1)*v_stride.</span>
<span class="cm">    The input array contains derivatives of the numerator and denominator</span>
<span class="cm">    functions in the order X, W, Xs, Ws, Xt, Wt, Xss, Wss, Xst, Wst, Xtt, Wtt, ...</span>
<span class="cm">    In general, the (i,j)-th derivatives are in the (dim+1) entries of v[]</span>
<span class="cm">    v[k], ..., answer[k+dim], where k = ((i+j)*(i+j+1)/2 + j)*v_stride.</span>
<span class="cm">    In the output v[] array the derivatives of X are replaced with</span>
<span class="cm">    the derivatives of F and the derivatives of W are divided by</span>
<span class="cm">    w = v[dim].</span>
<span class="cm">Returns:</span>
<span class="cm">  True if input is valid; i.e., v[dim] != 0.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_EvaluateQuotientRule</span>
<span class="cm">  ON_EvaluateQuotientRule3</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateQuotientRule2</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">der_count</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">v_stride</span><span class="p">,</span>
          <span class="kt">double</span> <span class="o">*</span><span class="n">v</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Use the quotient rule to compute partial derivatives of a 3 parameter</span>
<span class="cm">  rational function F(r,s,t) = X(r,s,t)/W(r,s,t), where W is a scalar</span>
<span class="cm">  and F and X are vectors of dimension dim.</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in]</span>
<span class="cm">  der_count - [in] number of derivative (&gt;=0)</span>
<span class="cm">  v_stride - [in] (&gt;= dim+1)</span>
<span class="cm">  v - [in/out]</span>
<span class="cm">    v[] is an array of length</span>
<span class="cm">    v_stride*(der_count+1)*(der_count+2)*(der_count+3)/6.</span>
<span class="cm">    The input v[] array contains  derivatives of the numerator and</span>
<span class="cm">    denominator functions in the order (X, W), (Xr, Wr), (Xs, Ws),</span>
<span class="cm">    (Xt, Wt), (Xrr, Wrr), (Xrs, Wrs), (Xrt, Wrt), (Xss, Wss),</span>
<span class="cm">    (Xst, Wst), (Xtt, Wtt), ...</span>
<span class="cm">    In general, the (dim+1) coordinates of the derivative</span>
<span class="cm">    (Dr^i Ds^j Dt^k, i+j+k=d) are at v[n], ..., v[n+dim] where</span>
<span class="cm">    n = v_stride*( d*(d+1)*(d+2)/6  +  (d-i)*(d-i+1)/2  +  k ).</span>
<span class="cm">    In the output v[] array the derivatives of X are replaced with</span>
<span class="cm">    the derivatives of F and the derivatives of W are divided by</span>
<span class="cm">    w = v[dim].</span>
<span class="cm">Returns:</span>
<span class="cm">  True if input is valid; i.e., v[dim] != 0.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_EvaluateQuotientRule</span>
<span class="cm">  ON_EvaluateQuotientRule2</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateQuotientRule3</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">der_count</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">v_stride</span><span class="p">,</span>
          <span class="kt">double</span> <span class="o">*</span><span class="n">v</span>
          <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_GetPolylineLength</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>           <span class="c1">// dimension of points</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span>          <span class="c1">// bIsRational true if points are homogeneous rational</span>
        <span class="kt">int</span><span class="p">,</span>           <span class="c1">// number of points</span>
        <span class="kt">int</span><span class="p">,</span>           <span class="c1">// stride between points</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// points</span>
        <span class="kt">double</span><span class="o">*</span>        <span class="c1">// length returned here</span>
        <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Find the index of the point in the point_list that is closest to P.</span>
<span class="cm">Parameters:</span>
<span class="cm">  point_count - [in]</span>
<span class="cm">  point_list - [in]</span>
<span class="cm">  P - [in]</span>
<span class="cm">  closest_point_index - [out]</span>
<span class="cm">Returns:</span>
<span class="cm">  True if successful and *closest_point_index is set.</span>
<span class="cm">  False if input is not valid, in which case *closest_point_index</span>
<span class="cm">  is undefined.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_GetClosestPointInPointList</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">point_count</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">point_list</span><span class="p">,</span>
          <span class="n">ON_3dPoint</span> <span class="n">P</span><span class="p">,</span>
          <span class="kt">int</span><span class="o">*</span> <span class="n">closest_point_index</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Test math library functions.</span>
<span class="cm">Parameters:</span>
<span class="cm">  function_index - [in]  Determines which math library function is called.</span>

<span class="cm">           1:    z = x+y</span>
<span class="cm">           2:    z = x-y</span>
<span class="cm">           3:    z = x*y</span>
<span class="cm">           4:    z = x/y</span>
<span class="cm">           5:    z = fabs(x)</span>
<span class="cm">           6:    z = exp(x)</span>
<span class="cm">           7:    z = log(x)</span>
<span class="cm">           8:    z = logb(x)</span>
<span class="cm">           9:    z = log10(x)</span>
<span class="cm">          10:    z = pow(x,y)</span>
<span class="cm">          11:    z = sqrt(x)</span>
<span class="cm">          12:    z = sin(x)</span>
<span class="cm">          13:    z = cos(x)</span>
<span class="cm">          14:    z = tan(x)</span>
<span class="cm">          15:    z = sinh(x)</span>
<span class="cm">          16:    z = cosh(x)</span>
<span class="cm">          17:    z = tanh(x)</span>
<span class="cm">          18:    z = asin(x)</span>
<span class="cm">          19:    z = acos(x)</span>
<span class="cm">          20:    z = atan(x)</span>
<span class="cm">          21:    z = atan2(y,x)</span>
<span class="cm">          22:    z = fmod(x,y)</span>
<span class="cm">          23:    z = modf(x,&amp;y)</span>
<span class="cm">          24:    z = frexp(x,&amp;y)</span>

<span class="cm">  double x - [in]</span>
<span class="cm">  double y - [in]</span>
<span class="cm">Returns:</span>
<span class="cm">  Returns the &quot;z&quot; value listed in the function_index parameter</span>
<span class="cm">  description.</span>
<span class="cm">Remarks:</span>
<span class="cm">  This function is used to test the results of class floating</span>
<span class="cm">  point functions.  It is primarily used to see what happens</span>
<span class="cm">  when opennurbs is used as a DLL and illegal operations are</span>
<span class="cm">  performed.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_TestMathFunction</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">function_index</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">y</span>
        <span class="p">);</span>

<span class="c1">// If performance is important, then</span>
<span class="c1">// you are better off using ((b&lt;a)?a:b)</span>
<span class="n">ON_DECL</span> <span class="kt">double</span> <span class="nf">ON_Max</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// If performance is important, then</span>
<span class="c1">// you are better off using ((b&lt;a)?a:b)</span>
<span class="n">ON_DECL</span> <span class="kt">float</span> <span class="nf">ON_Max</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// If performance is important, then</span>
<span class="c1">// you are better off using ((b&lt;a)?a:b)</span>
<span class="n">ON_DECL</span> <span class="kt">int</span> <span class="nf">ON_Max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// If performance is important, then</span>
<span class="c1">// you are better off using ((a&lt;b)?a:b)</span>
<span class="n">ON_DECL</span> <span class="kt">double</span> <span class="nf">ON_Min</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// If performance is important, then</span>
<span class="c1">// you are better off using ((a&lt;b)?a:b)</span>
<span class="n">ON_DECL</span> <span class="kt">float</span> <span class="nf">ON_Min</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// If performance is important, then</span>
<span class="c1">// you are better off using ((a&lt;b)?a:b)</span>
<span class="n">ON_DECL</span> <span class="kt">int</span> <span class="nf">ON_Min</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="c1">// Do not call ON_Round() in any opennurbs code, tl code</span>
<span class="c1">// or any other code that does critical calculations or</span>
<span class="c1">// when there is any possibility that x is invalid or</span>
<span class="c1">// fabs(x)&gt;2147483647. Use floor(x+0.5) instead.</span>
<span class="n">ON_DECL</span> <span class="kt">int</span> <span class="nf">ON_Round</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Find the equation of the parabola, ellipse or hyperbola</span>
<span class="cm">  (non-degenerate conic) that passes through six distinct points.</span>
<span class="cm">Parameters:</span>
<span class="cm">  stride - [in] (&gt;=2)</span>
<span class="cm">    points array stride</span>
<span class="cm">  points2d - [in] (&gt;=2)</span>
<span class="cm">    i-th point is (points[i*stride],points[i*stride+1])</span>
<span class="cm">  conic - [out]</span>
<span class="cm">    Coefficients of the conic equation.</span>
<span class="cm">    The points on the conic satisfy the equation</span>
<span class="cm">      0 = conic[0]*x^2 + conic[1]*xy + conic[2]*y^2</span>
<span class="cm">        + conic[3]*x + conic[4]*y + conic[5]</span>
<span class="cm">  max_pivot - [out] (can be null)</span>
<span class="cm">  min_pivot - [out] (can be null)</span>
<span class="cm">  zero_pivot - [out] (can be null)</span>
<span class="cm">    If there are some near duplicates in the input point set,</span>
<span class="cm">    the calculation is not stable.  If you want to get an</span>
<span class="cm">    estimate of the validity of the solution, then inspect</span>
<span class="cm">    the returned values.  max_pivot should around 1,</span>
<span class="cm">    min_pivot should be &gt; 1e-4 or so, and zero_pivot should</span>
<span class="cm">    be &lt; 1e-10 or so.  If the returned pivots don&#39;t satisify</span>
<span class="cm">    these condtions, then exercise caution when using the</span>
<span class="cm">    returned solution.</span>
<span class="cm">Returns:</span>
<span class="cm">  True if a there is an ellipse, parabola or hyperbola through the</span>
<span class="cm">  six points.</span>
<span class="cm">  False if the input is invalid or the conic degenerate (the</span>
<span class="cm">  points lie on one or two lines).</span>
<span class="cm">  If false is returned, then conic[0]=...=conic[5] = 0 and</span>
<span class="cm">  *min_pivot = *max_pivot = *zero_pivot = 0.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">bool</span> <span class="nf">ON_GetConicEquationThrough6Points</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">stride</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">points2d</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">conic</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">max_pivot</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">min_pivot</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">zero_pivot</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Test a conic equation to see if it defines and ellipse. If so,</span>
<span class="cm">  return the center and axes of the ellipse.</span>
<span class="cm">Parameters:</span>
<span class="cm">  conic - [in]</span>
<span class="cm">    Coefficients of the conic equation.</span>
<span class="cm">    The points on the conic satisfy the equation</span>
<span class="cm">      0 = conic[0]*x^2 + conic[1]*xy + conic[2]*y^2</span>
<span class="cm">        + conic[3]*x + conic[4]*y + conic[5]</span>
<span class="cm">  center - [out]</span>
<span class="cm">  major_axis - [out]</span>
<span class="cm">  minor_axis - [out]</span>
<span class="cm">  major_radius - [out]</span>
<span class="cm">  minor_radius - [out]</span>
<span class="cm">Returns:</span>
<span class="cm">  True if the conic is an ellipse and the center and axes were found.</span>
<span class="cm">  False if the conic is not an ellipse, in which case the input values</span>
<span class="cm">  of center, major_axis, minor_axis, major_radius, and minor_radius</span>
<span class="cm">  are not changed.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">bool</span> <span class="nf">ON_IsConicEquationAnEllipse</span><span class="p">(</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="n">conic</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
        <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="n">center</span><span class="p">,</span>
        <span class="n">ON_2dVector</span><span class="o">&amp;</span> <span class="n">major_axis</span><span class="p">,</span>
        <span class="n">ON_2dVector</span><span class="o">&amp;</span> <span class="n">minor_axis</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">major_radius</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">minor_radius</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get the conic equation of an ellipse.</span>
<span class="cm">Parameters:</span>
<span class="cm">  a - [in] (a&gt;0)</span>
<span class="cm">  b - [in] (b&gt;0)</span>
<span class="cm">    a and b are the lengths of the axes. Either one</span>
<span class="cm">    may be largest and they can be equal.</span>
<span class="cm">  x0 - [in]</span>
<span class="cm">  y0 - [in]</span>
<span class="cm">    (x0,y0) is the enter of the ellipse.</span>
<span class="cm">  alpha - [in] (angle in radians)</span>
<span class="cm">    When alpha is 0, a corresponds to the x-axis and</span>
<span class="cm">    b corresponds to the y axis.  If alpha is non-zero</span>
<span class="cm">    it specifies the rotation of these axes.</span>
<span class="cm">  conic - [out]</span>
<span class="cm">    Coefficients of the conic equation.</span>
<span class="cm">    The points on the conic satisfy the equation</span>
<span class="cm">      0 = conic[0]*x^2 + conic[1]*xy + conic[2]*y^2</span>
<span class="cm">        + conic[3]*x + conic[4]*y + conic[5]</span>
<span class="cm">  center - [out]</span>
<span class="cm">  major_axis - [out]</span>
<span class="cm">  minor_axis - [out]</span>
<span class="cm">  major_radius - [out]</span>
<span class="cm">  minor_radius - [out]</span>
<span class="cm">Remarks:</span>
<span class="cm">  Here is the way to evaluate a point on the ellipse:</span>


<span class="cm">          double t = ellipse paramter in radians;</span>
<span class="cm">          double x = a*cos(t);</span>
<span class="cm">          double y = b*sin(t);</span>
<span class="cm">          ON_2dPoint ellipse_point;</span>
<span class="cm">          ellipse_point.x = x0 + x*cos(alpha) + y*sin(alpha);</span>
<span class="cm">          ellipse_point.y = y0 - x*sin(alpha) + y*cos(alpha);</span>

<span class="cm">Returns:</span>
<span class="cm">  True if the input is valid and conic[] was filled in.</span>
<span class="cm">  Falis if the input is not valid.  In this case the values in conic[]</span>
<span class="cm">  are not changed.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">bool</span> <span class="nf">ON_GetEllipseConicEquation</span><span class="p">(</span>
      <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">x0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y0</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">alpha</span><span class="p">,</span>
      <span class="kt">double</span> <span class="n">conic</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
      <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Descripton:</span>
<span class="cm">  Return the length of a 2d vector (x,y)</span>
<span class="cm">Returns:</span>
<span class="cm"> sqrt(x^2 + y^2) calculated in as precisely and safely as possible.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">double</span> <span class="nf">ON_Length2d</span><span class="p">(</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Descripton:</span>
<span class="cm">  Return the length of a 3d vector (x,y,z)</span>
<span class="cm">Returns:</span>
<span class="cm"> sqrt(x^2 + y^2 + z^2) calculated in as precisely and safely as possible.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">double</span> <span class="nf">ON_Length3d</span><span class="p">(</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span> <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Convert a double x to the largest float f such that</span>
<span class="cm">  the mathematical value of f is at most the value of x.</span>
<span class="cm">Parameters:</span>
<span class="cm">  x - [in]</span>
<span class="cm">Returns</span>
<span class="cm">  The largest float f such that the mathematical value</span>
<span class="cm">  of f is at most the value of x.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">float</span> <span class="nf">ON_FloatFloor</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Convert a double x to the smallest float f such that</span>
<span class="cm">  the mathematical value of f is at least the value of x.</span>
<span class="cm">Parameters:</span>
<span class="cm">  x - [in]</span>
<span class="cm">Returns</span>
<span class="cm">  The smallest float f such that the mathematical value</span>
<span class="cm">  of f is at least the value of x.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">float</span> <span class="nf">ON_FloatCeil</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_matrix.h.html" class="btn btn-neutral float-right" title="File opennurbs_matrix.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_math.h.html" class="btn btn-neutral float-left" title="File opennurbs_math.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>