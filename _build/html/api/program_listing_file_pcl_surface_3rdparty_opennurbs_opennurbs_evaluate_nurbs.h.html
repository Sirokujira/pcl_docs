

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_evaluate_nurbs.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_extensions.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_extensions.h.html" />
    <link rel="prev" title="File opennurbs_evaluate_nurbs.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_evaluate_nurbs.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_evaluate_nurbs.h.html">File opennurbs_evaluate_nurbs.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_evaluate_nurbs.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_evaluate_nurbs.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-evaluate-nurbs-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-evaluate-nurbs-h"></span><h1>Program Listing for File opennurbs_evaluate_nurbs.h<a class="headerlink" href="#program-listing-for-file-opennurbs-evaluate-nurbs-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_evaluate_nurbs.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-evaluate-nurbs-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_evaluate_nurbs.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="cp">#if !defined(ON_EVALUATE_NURBS_INC_)</span>
<span class="cp">#define ON_EVALUATE_NURBS_INC_</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IncreaseBezierDegree</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="c1">// dimension</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span>   <span class="c1">// true if Bezier is rational</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="o">//</span> <span class="n">order</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="c1">// cv_stride (&gt;=dim+1)</span>
        <span class="kt">double</span><span class="o">*</span> <span class="c1">// cv[(order+1)*cv_stride] array</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_RemoveBezierSingAt0</span><span class="p">(</span> <span class="c1">// input bezier is rational with 0/0 at start</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="c1">// dimension</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="o">//</span> <span class="n">order</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="c1">// cv_stride (&gt;=dim+1)</span>
        <span class="kt">double</span><span class="o">*</span> <span class="c1">// cv[order*cv_stride] array</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_RemoveBezierSingAt1</span><span class="p">(</span> <span class="c1">// input bezier is rational with 0/0 at end</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="c1">// dimension</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="o">//</span> <span class="n">order</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
        <span class="kt">int</span><span class="p">,</span>    <span class="c1">// cv_stride (&gt;=dim+1)</span>
        <span class="kt">double</span><span class="o">*</span> <span class="c1">// cv[order*cv_stride] array</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">double</span> <span class="nf">ON_EvaluateBernsteinBasis</span><span class="p">(</span> <span class="o">//</span> <span class="n">returns</span> <span class="p">(</span><span class="n">i</span> <span class="n">choose</span> <span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">^</span><span class="n">i</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// degree,</span>
        <span class="kt">int</span><span class="p">,</span> <span class="c1">// 0 &lt;= i &lt;= degree</span>
        <span class="kt">double</span> <span class="c1">//  t</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">void</span> <span class="nf">ON_EvaluatedeCasteljau</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>     <span class="c1">//  dim</span>
        <span class="kt">int</span><span class="p">,</span>     <span class="c1">//  order</span>
        <span class="kt">int</span><span class="p">,</span>     <span class="c1">//  side &lt;= 0  return left side of bezier in cv array</span>
                 <span class="c1">//       &gt;  0  return right side of bezier in cv array</span>
        <span class="kt">int</span><span class="p">,</span>     <span class="c1">//  cv_stride</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">//  cv</span>
        <span class="kt">double</span>   <span class="c1">//  t 0 &lt;= t &lt;= 1</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateBezier</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="c1">// dimension</span>
        <span class="n">ON_BOOL32</span><span class="p">,</span>           <span class="c1">// true if Bezier is rational</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="o">//</span> <span class="n">order</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="c1">// cv_stride &gt;= (is_rat)?dim+1:dim</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span>  <span class="c1">// cv[order*cv_stride] array</span>
        <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="c1">// t0,t1 = domain of bezier</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="c1">// number of derivatives to compute (&gt;=0)</span>
        <span class="kt">double</span><span class="p">,</span>         <span class="c1">// evaluation parameter</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="c1">// v_stride (&gt;=dimension)</span>
        <span class="kt">double</span><span class="o">*</span>         <span class="c1">// v[(der_count+1)*v_stride] array</span>
        <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateNurbsBasis</span><span class="p">(</span>
                  <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">order</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// knot[] array of 2*(order-1) knots</span>
                  <span class="kt">double</span><span class="p">,</span>        <span class="c1">// evaluation parameter</span>
                  <span class="kt">double</span><span class="o">*</span>        <span class="c1">// basis_values[] array of length order*order</span>
                  <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateNurbsBasisDerivatives</span><span class="p">(</span>
                  <span class="kt">int</span><span class="p">,</span>           <span class="o">//</span> <span class="n">order</span> <span class="p">(</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">)</span>
                  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// knot[] array of 2*(order-1) knots</span>
                  <span class="kt">int</span><span class="p">,</span>           <span class="c1">// number of derivatives</span>
                  <span class="kt">double</span><span class="o">*</span>        <span class="c1">// basis_values[] array of length order*order</span>
                  <span class="p">);</span>




<span class="cm">/*</span>
<span class="cm">int dim,             // dimension</span>
<span class="cm">                  ON_BOOL32 is_rat,         // true if NURBS is rational</span>
<span class="cm">                  int order,           // order</span>
<span class="cm">                  const double* knot,  // knot[] array of (2*order-2) doubles</span>
<span class="cm">                  int cv_stride,       // cv_stride &gt;= (is_rat)?dim+1:dim</span>
<span class="cm">                  const double* cv,    // cv[order*cv_stride] array</span>
<span class="cm">                  int der_count,       // number of derivatives to compute</span>
<span class="cm">                  double t,            // evaluation parameter</span>
<span class="cm">                  int v_stride,        // v_stride (&gt;=dimension)</span>
<span class="cm">                  double* v            // v[(der_count+1)*v_stride] array</span>
<span class="cm">                  )</span>
<span class="cm">        int,           // dimension</span>
<span class="cm">        ON_BOOL32,          // true if NURBS is rational</span>
<span class="cm">        int,           // order</span>
<span class="cm">        const double*, // knot[] array of (2*order-2) doubles</span>
<span class="cm">        int,           // cv_stride</span>
<span class="cm">        const double*, // cv[] array of order*cv_stride  doubles</span>
<span class="cm">        int,           // number of derivatives to compute (&gt;=0)</span>
<span class="cm">        double,        // evaluation parameter</span>
<span class="cm">        int,           // answer_stride (&gt;=dimension)</span>
<span class="cm">        double*        // answer[] array of length (ndir+1)*answer_stride</span>
<span class="cm">*/</span>


<span class="n">ON_DECL</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Evaluate a NURBS curve span.</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in]</span>
<span class="cm">    dimension (&gt; 0).</span>
<span class="cm">  is_rat - [in]</span>
<span class="cm">    true or false.</span>
<span class="cm">  order - [in]</span>
<span class="cm">    order=degree+1 (order&gt;=2)</span>
<span class="cm">  knot - [in] NURBS knot vector.</span>
<span class="cm">    NURBS knot vector with 2*(order-1) knots, knot[order-2] != knot[order-1]</span>
<span class="cm">  cv_stride - [in]</span>
<span class="cm">  cv - [in]</span>
<span class="cm">    For 0 &lt;= i &lt; order the i-th control vertex is</span>

<span class="cm">          cv[n],...,cv[n+(is_rat?dim:dim+1)],</span>

<span class="cm">    where n = i*cv_stride.  If is_rat is true the cv is</span>
<span class="cm">    in homogeneous form.</span>
<span class="cm">  der_count - [in]</span>
<span class="cm">    number of derivatives to evaluate (&gt;=0)</span>
<span class="cm">  t - [in]</span>
<span class="cm">    evaluation parameter</span>
<span class="cm">  v_stride - [in]</span>
<span class="cm">  v - [out]</span>
<span class="cm">    An array of length v_stride*(der_count+1). The evaluation</span>
<span class="cm">    results are returned in this array.</span>

<span class="cm">              P = v[0],...,v[m_dim-1]</span>
<span class="cm">              Dt = v[v_stride],...</span>
<span class="cm">              Dtt = v[2*v_stride],...</span>
<span class="cm">              ...</span>

<span class="cm">            In general, Dt^i returned in v[n],...,v[n+m_dim-1], where</span>

<span class="cm">              n = v_stride*i.</span>

<span class="cm">Returns:</span>
<span class="cm">  True if successful.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_NurbsCurve::Evaluate</span>
<span class="cm">  ON_EvaluateNurbsSurfaceSpan</span>
<span class="cm">  ON_EvaluateNurbsCageSpan</span>
<span class="cm">*/</span>
<span class="kt">bool</span> <span class="n">ON_EvaluateNurbsSpan</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">is_rat</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">knot</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cv_stride</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">cv</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">der_count</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">t</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">v_stride</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">v</span>
        <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Evaluate a NURBS surface bispan.</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in] &gt;0</span>
<span class="cm">  is_rat - [in] true of false</span>
<span class="cm">  order0 - [in] &gt;= 2</span>
<span class="cm">  order1 - [in] &gt;= 2</span>
<span class="cm">  knot0 - [in]</span>
<span class="cm">    NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]</span>
<span class="cm">  knot1 - [in]</span>
<span class="cm">    NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]</span>
<span class="cm">  cv_stride0 - [in]</span>
<span class="cm">  cv_stride1 - [in]</span>
<span class="cm">  cv - [in]</span>
<span class="cm">    For 0 &lt;= i &lt; order0 and  0 &lt;= j &lt; order1, the (i,j) control vertex is</span>

<span class="cm">          cv[n],...,cv[n+(is_rat?dim:dim+1)],</span>

<span class="cm">    where n = i*cv_stride0 + j*cv_stride1.  If is_rat is true the cv is</span>
<span class="cm">    in homogeneous form.</span>

<span class="cm">  der_count - [in] (&gt;=0)</span>
<span class="cm">  s - [in]</span>
<span class="cm">  t - [in] (s,t) is the evaluation parameter</span>
<span class="cm">  v_stride - [in] (&gt;=dim)</span>
<span class="cm">  v - [out] An array of length v_stride*(der_count+1)*(der_count+2)/2.</span>
<span class="cm">            The evaluation results are stored in this array.</span>

<span class="cm">              P = v[0],...,v[m_dim-1]</span>
<span class="cm">              Ds = v[v_stride],...</span>
<span class="cm">              Dt = v[2*v_stride],...</span>
<span class="cm">              Dss = v[3*v_stride],...</span>
<span class="cm">              Dst = v[4*v_stride],...</span>
<span class="cm">              Dtt = v[5*v_stride],...</span>

<span class="cm">            In general, Ds^i Dt^j is returned in v[n],...,v[n+m_dim-1], where</span>

<span class="cm">              n = v_stride*( (i+j)*(i+j+1)/2 + j).</span>

<span class="cm">Returns:</span>
<span class="cm">  True if succcessful.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_NurbsSurface::Evaluate</span>
<span class="cm">  ON_EvaluateNurbsSpan</span>
<span class="cm">  ON_EvaluateNurbsCageSpan</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateNurbsSurfaceSpan</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">is_rat</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">order0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">order1</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">knot0</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">knot1</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cv_stride0</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cv_stride1</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">cv</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">der_count</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">s</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">t</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">v_stride</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">v</span>
        <span class="p">);</span>



<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Evaluate a NURBS cage trispan.</span>
<span class="cm">Parameters:</span>
<span class="cm">  dim - [in] &gt;0</span>
<span class="cm">  is_rat - [in] true of false</span>
<span class="cm">  order0 - [in] &gt;= 2</span>
<span class="cm">  order1 - [in] &gt;= 2</span>
<span class="cm">  order2 - [in] &gt;= 2</span>
<span class="cm">  knot0 - [in]</span>
<span class="cm">    NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]</span>
<span class="cm">  knot1 - [in]</span>
<span class="cm">    NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]</span>
<span class="cm">  knot2 - [in]</span>
<span class="cm">    NURBS knot vector with 2*(order1-1) knots, knot2[order2-2] != knot2[order2-1]</span>
<span class="cm">  cv_stride0 - [in]</span>
<span class="cm">  cv_stride1 - [in]</span>
<span class="cm">  cv_stride2 - [in]</span>
<span class="cm">  cv - [in]</span>
<span class="cm">    For 0 &lt;= i &lt; order0, 0 &lt;= j &lt; order1, and 0 &lt;= k &lt; order2,</span>
<span class="cm">    the (i,j,k)-th control vertex is</span>

<span class="cm">          cv[n],...,cv[n+(is_rat?dim:dim+1)],</span>

<span class="cm">    where n = i*cv_stride0 + j*cv_stride1 *k*cv_stride2.</span>
<span class="cm">    If is_rat is true the cv is in homogeneous form.</span>

<span class="cm">  der_count - [in] (&gt;=0)</span>
<span class="cm">  r - [in]</span>
<span class="cm">  s - [in]</span>
<span class="cm">  t - [in] (r,s,t) is the evaluation parameter</span>
<span class="cm">  v_stride - [in] (&gt;=dim)</span>
<span class="cm">  v - [out] An array of length v_stride*(der_count+1)*(der_count+2)*(der_count+3)/6.</span>
<span class="cm">            The evaluation results are stored in this array.</span>

<span class="cm">              P = v[0],...,v[m_dim-1]</span>
<span class="cm">              Dr = v[v_stride],...</span>
<span class="cm">              Ds = v[2*v_stride],...</span>
<span class="cm">              Dt = v[3*v_stride],...</span>
<span class="cm">              Drr = v[4*v_stride],...</span>
<span class="cm">              Drs = v[5*v_stride],...</span>
<span class="cm">              Drt = v[6*v_stride],...</span>
<span class="cm">              Dss = v[7*v_stride],...</span>
<span class="cm">              Dst = v[8*v_stride],...</span>
<span class="cm">              Dtt = v[9*v_stride],...</span>

<span class="cm">            In general, Dr^i Ds^j Dt^k is returned in v[n],...,v[n+dim-1], where</span>

<span class="cm">               d = (i+j+k)</span>
<span class="cm">               n = v_stride*( d*(d+1)*(d+2)/6 + (j+k)*(j+k+1)/2 + k)</span>

<span class="cm">Returns:</span>
<span class="cm">  True if succcessful.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_NurbsCage::Evaluate</span>
<span class="cm">  ON_EvaluateNurbsSpan</span>
<span class="cm">  ON_EvaluateNurbsSurfaceSpan</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateNurbsCageSpan</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">dim</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">is_rat</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">order0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order2</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">knot0</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">knot1</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">knot2</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">cv_stride0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cv_stride1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cv_stride2</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">cv</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">der_count</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">t0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">t2</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">v_stride</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">v</span>
        <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateNurbsDeBoor</span><span class="p">(</span> <span class="c1">// for expert users only - no support available</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="o">//</span> <span class="n">cv_dim</span> <span class="p">(</span> <span class="n">dim</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">rational</span> <span class="n">cvs</span> <span class="p">)</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="c1">// order (&gt;=2)</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="c1">// cv_stride (&gt;=cv_dim)</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>        <span class="c1">// cv array - values changed to result of applying De Boor&#39;s algorithm</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span>  <span class="c1">// knot array</span>
        <span class="kt">int</span><span class="p">,</span>            <span class="c1">// side,</span>
                        <span class="c1">//    -1  return left side of B-spline span in cv array</span>
                        <span class="c1">//    +1  return right side of B-spline span in cv array</span>
                        <span class="c1">//    -2  return left side of B-spline span in cv array</span>
                        <span class="c1">//        Ignore values of knots[0,...,order-3] and assume</span>
                        <span class="c1">//        left end of span has a fully multiple knot with</span>
                        <span class="c1">//        value &quot;mult_k&quot;.</span>
                        <span class="c1">//    +2  return right side of B-spline span in cv array</span>
                        <span class="c1">//        Ignore values of knots[order,...,2*order-2] and</span>
                        <span class="c1">//        assume right end of span has a fully multiple</span>
                        <span class="c1">//        knot with value &quot;mult_k&quot;.</span>
        <span class="kt">double</span><span class="p">,</span>         <span class="c1">// mult_k - used when side is +2 or -2.  See above for usage.</span>
        <span class="kt">double</span>          <span class="c1">// t</span>
                        <span class="c1">//    If side &lt; 0, then the cv&#39;s for the portion of the NURB span to</span>
                        <span class="c1">//    the LEFT of t are computed.  If side &gt; 0, then the cv&#39;s for the</span>
                        <span class="c1">//    portion the span to the RIGHT of t are computed.  The following</span>
                        <span class="c1">//    table summarizes the restrictions on t:</span>
                        <span class="c1">//</span>
                        <span class="c1">//     value of side         condition t must satisfy</span>
                        <span class="c1">//        -2                    mult_k &lt; t and mult_k &lt; knots[order-1]</span>
                        <span class="c1">//        -1                    knots[order-2] &lt; t</span>
                        <span class="c1">//        +1                    t &lt; knots[order-1]</span>
                        <span class="c1">//        +2                    t &lt; mult_k and knots[order-2] &lt; mult_k</span>
        <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_EvaluateNurbsBlossom</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="c1">// cvdim,</span>
                             <span class="kt">int</span><span class="p">,</span> <span class="c1">// order,</span>
                             <span class="kt">int</span><span class="p">,</span> <span class="c1">// cv_stride,</span>
                             <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">//CV, size cv_stride*order</span>
                             <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="o">//</span><span class="n">knot</span><span class="p">,</span> <span class="n">nondecreasing</span><span class="p">,</span> <span class="n">size</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                             <span class="c1">// knot[order-2] != knot[order-1]</span>
                             <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">//t, input parameters size order-1</span>
                             <span class="kt">double</span><span class="o">*</span> <span class="c1">// P</span>

                             <span class="c1">// DeBoor algorithm with different input at each step.</span>
                             <span class="c1">// returns false for bad input.</span>
                            <span class="p">);</span>


<span class="n">ON_DECL</span>
<span class="kt">void</span> <span class="nf">ON_ConvertNurbSpanToBezier</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span>       <span class="o">//</span> <span class="n">cvdim</span> <span class="p">(</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">rational</span> <span class="n">curves</span><span class="p">)</span>
        <span class="kt">int</span><span class="p">,</span>       <span class="c1">// order,</span>
        <span class="kt">int</span><span class="p">,</span>       <span class="c1">// cvstride (&gt;=cvdim)</span>
        <span class="kt">double</span><span class="o">*</span><span class="p">,</span>   <span class="c1">// cv array - input has NURBS cvs, output has Bezier cvs</span>
        <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// (2*order-2) knots for the NURBS span</span>
        <span class="kt">double</span><span class="p">,</span>        <span class="c1">// t0, NURBS span parameter of start point</span>
        <span class="kt">double</span>         <span class="c1">// t1, NURBS span parameter of end point</span>
        <span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_extensions.h.html" class="btn btn-neutral float-right" title="File opennurbs_extensions.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_evaluate_nurbs.h.html" class="btn btn-neutral float-left" title="File opennurbs_evaluate_nurbs.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>