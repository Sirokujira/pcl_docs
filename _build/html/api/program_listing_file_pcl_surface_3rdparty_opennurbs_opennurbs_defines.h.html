

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_defines.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_detail.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_detail.h.html" />
    <link rel="prev" title="File opennurbs_defines.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_defines.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_defines.h.html">File opennurbs_defines.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_defines.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_defines.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-defines-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-defines-h"></span><h1>Program Listing for File opennurbs_defines.h<a class="headerlink" href="#program-listing-for-file-opennurbs-defines-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_defines.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-defines-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_defines.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">//   Includes all openNURBS toolkit defines and enums.</span>
<span class="c1">//</span>
<span class="c1">////////////////////////////////////////////////////////////////</span>

<span class="cp">#if !defined(OPENNURBS_DEFINES_INC_)</span>
<span class="cp">#define OPENNURBS_DEFINES_INC_</span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/pcl_exports.h&gt;</span><span class="cp"></span>

<span class="cp">#if defined (cplusplus) || defined(_cplusplus) || defined(__cplusplus) || defined(ON_CPLUSPLUS)</span>
<span class="c1">// C++ extern &quot;C&quot; declaration for C linkage</span>

<span class="cp">#if !defined(ON_CPLUSPLUS)</span>
<span class="cp">#define ON_CPLUSPLUS</span>
<span class="cp">#endif</span>
<span class="cp">#define ON_EXTERNC extern &quot;C&quot;</span>
<span class="cp">#define ON_BEGIN_EXTERNC extern &quot;C&quot; {</span>
<span class="cp">#define ON_END_EXTERNC   }</span>

<span class="cp">#else</span>

<span class="cm">/* C file - no extern declaration required or permitted */</span>

<span class="cp">#define ON_EXTERNC</span>
<span class="cp">#define ON_BEGIN_EXTERNC</span>
<span class="cp">#define ON_END_EXTERNC</span>

<span class="cp">#endif</span>


<span class="cp">#if defined(_DEBUG)</span>
<span class="cm">/* enable OpenNurbs debugging code */</span>
<span class="cp">#if !defined(ON_DEBUG)</span>
<span class="cp">#define ON_DEBUG</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">// Declarations in header (.H) files look like</span>
<span class="cm">//</span>
<span class="cm">//   ON_DECL type function():</span>
<span class="cm">//   extern ON_EXTERN_DECL type global_variable;</span>
<span class="cm">//   class ON_CLASS classname {};</span>
<span class="cm">//   ON_TEMPLATE template class ON_CLASS template&lt;T&gt;;</span>
<span class="cm">//</span>
<span class="cm">*/</span>

<span class="cp">#if defined(OPENNURBS_EXPORTS)</span>
<span class="c1">// OPENNURBS_EXPORTS is Microsoft&#39;s prefered defined for building an opennurbs DLL.</span>
<span class="cp">#if !defined(ON_DLL_EXPORTS)</span>
<span class="cp">#define ON_DLL_EXPORTS</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(ON_COMPILING_OPENNURBS)</span>
<span class="cp">#define ON_COMPILING_OPENNURBS</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(OPENNURBS_IMPORTS)</span>
<span class="c1">// OPENNURBS_EXPORTS is Microsoft&#39;s prefered defined for linking with an opennurbs DLL.</span>
<span class="cp">#if !defined(ON_DLL_IMPORTS)</span>
<span class="cp">#define ON_DLL_IMPORTS</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(ON_DLL_EXPORTS) &amp;&amp; defined(ON_DLL_IMPORTS)</span>
<span class="cp">#error At most one of ON_DLL_EXPORTS and ON_DLL_IMPORTS can be defined.</span>
<span class="cp">#endif</span>

<span class="cm">/* export/import */</span>
<span class="cp">#if defined(ON_DLL_EXPORTS)</span>

<span class="cp">#if !defined(ON_COMPILING_OPENNURBS)</span>
<span class="cp">#error When compiling an OpenNURBS DLL, ON_DLL_EXPORTS must be defined</span>
<span class="cp">#endif</span>

<span class="cm">/* compiling OpenNurbs as a Windows DLL - export classes, functions, templates, and globals */</span>
<span class="cp">#define ON_CLASS __declspec(dllexport)</span>
<span class="cp">#define ON_DECL __declspec(dllexport)</span>
<span class="cp">#define ON_EXTERN_DECL __declspec(dllexport)</span>
<span class="cp">#define ON_DLL_TEMPLATE</span>

<span class="cp">#elif defined(ON_DLL_IMPORTS)</span>

<span class="cp">#if defined(ON_COMPILING_OPENNURBS)</span>
<span class="cp">#error When compiling an OpenNURBS DLL, ON_DLL_IMPORTS must NOT be defined</span>
<span class="cp">#endif</span>

<span class="cm">/* using OpenNurbs as a Windows DLL - import classes, functions, templates, and globals */</span>
<span class="cp">#define ON_CLASS __declspec(dllimport)</span>
<span class="cp">#define ON_DECL __declspec(dllimport)</span>
<span class="cp">#define ON_EXTERN_DECL __declspec(dllimport)</span>
<span class="cp">#define ON_DLL_TEMPLATE extern</span>

<span class="cp">#else</span>

<span class="cm">/* compiling or using OpenNurbs as a static library */</span>
<span class="cp">#define ON_CLASS</span>
<span class="cp">#define ON_DECL</span>
<span class="cp">#define ON_EXTERN_DECL</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="cp">#undef ON_DLL_TEMPLATE</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>


<span class="c1">// ON_DEPRECATED is used to mark deprecated functions.</span>
<span class="cp">#if defined(ON_COMPILER_MSC)</span>
<span class="cp">#define ON_DEPRECATED  __declspec(deprecated)</span>
<span class="cp">#else</span>
<span class="cp">#define ON_DEPRECATED</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(PI)</span>
<span class="cp">#define ON_PI           PI</span>
<span class="cp">#else</span>
<span class="cp">#define ON_PI           3.141592653589793238462643</span>
<span class="cp">#endif</span>

<span class="cp">#define ON_DEGREES_TO_RADIANS ON_PI/180.0</span>
<span class="cp">#define ON_RADIANS_TO_DEGREES 180.0/ON_PI</span>

<span class="cp">#define ON_SQRT2          1.414213562373095048801689</span>
<span class="cp">#define ON_SQRT3          1.732050807568877293527446</span>
<span class="cp">#define ON_SQRT3_OVER_2   0.8660254037844386467637230</span>
<span class="cp">#define ON_1_OVER_SQRT2   0.7071067811865475244008445</span>
<span class="cp">#define ON_SIN_PI_OVER_12 0.2588190451025207623488990</span>
<span class="cp">#define ON_COS_PI_OVER_12 0.9659258262890682867497433</span>

<span class="cp">#define ON_LOG2         0.6931471805599453094172321</span>
<span class="cp">#define ON_LOG10        2.302585092994045684017991</span>

<span class="cp">#define ON_ArrayCount(a) (sizeof(a)/sizeof((a)[0]))</span>

<span class="cp">#if defined(DBL_MAX)</span>
<span class="cp">#define ON_DBL_MAX DBL_MAX</span>
<span class="cp">#else</span>
<span class="cp">#define ON_DBL_MAX 1.7976931348623158e+308</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(DBL_MIN)</span>
<span class="cp">#define ON_DBL_MIN DBL_MIN</span>
<span class="cp">#else</span>
<span class="cp">#define ON_DBL_MIN 2.22507385850720200e-308</span>
<span class="cp">#endif</span>

<span class="c1">// ON_EPSILON = 2^-52</span>
<span class="cp">#if defined(DBL_EPSILON)</span>
<span class="cp">#define ON_EPSILON DBL_EPSILON</span>
<span class="cp">#else</span>
<span class="cp">#define ON_EPSILON 2.2204460492503131e-16</span>
<span class="cp">#endif</span>
<span class="cp">#define ON_SQRT_EPSILON 1.490116119385000000e-8</span>

<span class="cp">#if defined(FLT_EPSILON)</span>
<span class="cp">#define ON_FLOAT_EPSILON FLT_EPSILON</span>
<span class="cp">#else</span>
<span class="cp">#define ON_FLOAT_EPSILON 1.192092896e-07</span>
<span class="cp">#endif</span>
<span class="cp">#define ON_SQRT_FLOAT_EPSILON 3.452669830725202719e-4</span>

<span class="cm">/*</span>
<span class="cm">// In cases where lazy evaluation of a double value is</span>
<span class="cm">// performed, b-rep tolerances being a notable example,</span>
<span class="cm">// this value is used to indicate the value has not been</span>
<span class="cm">// computed.  This value must be &lt; -1.0e308. and &gt; -ON_DBL_MAX</span>
<span class="cm">//</span>
<span class="cm">// The reasons ON_UNSET_VALUE is a valid finite number are:</span>
<span class="cm">//</span>
<span class="cm">//   1) It needs to round trip through fprintf/sscanf.</span>
<span class="cm">//   2) It needs to persist unchanged through assigment</span>
<span class="cm">/       and not generate exceptions when assigned.</span>
<span class="cm">//   3) ON_UNSET_VALUE == ON_UNSET_VALUE needs to be true.</span>
<span class="cm">//   4) ON_UNSET_VALUE != ON_UNSET_VALUE needs to be false.</span>
<span class="cm">//</span>
<span class="cm">// Ideally, it would also have these SNaN attributes</span>
<span class="cm">//   * When used in a calculation, a floating point exception</span>
<span class="cm">//     occures.</span>
<span class="cm">//   * No possibility of a valid calculation would generate</span>
<span class="cm">//     ON_UNSET_VALUE.</span>
<span class="cm">//   * float f = (float)ON_UNSET_VALUE would create an invalid</span>
<span class="cm">//     float and generate an exception.</span>
<span class="cm">*/</span>
<span class="cp">#define ON_UNSET_VALUE -1.23432101234321e+308</span>

<span class="cm">/*</span>
<span class="cm">// ON_UNSET_FLOAT is used to indicate a texture coordinate</span>
<span class="cm">// value cannot be calculated or is not well defined.</span>
<span class="cm">// In hindsight, this value should have been ON_FLT_QNAN</span>
<span class="cm">// because many calculation convert float texture coordinates</span>
<span class="cm">// to doubles and the &quot;unset&quot;ness attribute is lost.</span>
<span class="cm">*/</span>
<span class="cp">#define ON_UNSET_FLOAT -1.234321e+38f</span>


<span class="n">ON_BEGIN_EXTERNC</span>

<span class="c1">// IEEE 754 special values</span>
<span class="k">extern</span> <span class="n">ON_EXTERN_DECL</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">ON_DBL_QNAN</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ON_EXTERN_DECL</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">ON_DBL_PINF</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ON_EXTERN_DECL</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">ON_DBL_NINF</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">ON_EXTERN_DECL</span> <span class="k">const</span> <span class="kt">float</span>  <span class="n">ON_FLT_QNAN</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ON_EXTERN_DECL</span> <span class="k">const</span> <span class="kt">float</span>  <span class="n">ON_FLT_PINF</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ON_EXTERN_DECL</span> <span class="k">const</span> <span class="kt">float</span>  <span class="n">ON_FLT_NINF</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">Paramters:</span>
<span class="cm">  x - [out] returned value of x is an SNan</span>
<span class="cm">            (signalling not a number).</span>
<span class="cm">Remarks:</span>
<span class="cm">  Any time an SNaN passes through an Intel FPU, the result</span>
<span class="cm">  is a QNaN (quiet nan) and the invalid operation excpetion</span>
<span class="cm">  flag is set.  If this exception is not masked, then the</span>
<span class="cm">  exception handler is invoked.</span>

<span class="cm">    double x, y;</span>
<span class="cm">    ON_DBL_SNAN(&amp;x);</span>
<span class="cm">    y = x;     // y = QNAN and invalid op exception occurs</span>
<span class="cm">    z = sin(x) // z = QNAN and invalid op exception occurs</span>

<span class="cm">  So, if you want to reliably initialize doubles to SNaNs,</span>
<span class="cm">  you must use memcpy() or some other method that does not</span>
<span class="cm">  use the Intel FPU.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">void</span> <span class="nf">ON_DBL_SNAN</span><span class="p">(</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span> <span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">void</span> <span class="nf">ON_FLT_SNAN</span><span class="p">(</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span> <span class="p">);</span>

<span class="n">ON_END_EXTERNC</span>

<span class="cm">/*</span>
<span class="cm">// In cases where lazy evaluation of a color value is</span>
<span class="cm">// performed, this value is used to indicate the value</span>
<span class="cm">// has not been computed.</span>
<span class="cm">*/</span>
<span class="cp">#define ON_UNSET_COLOR 0xFFFFFFFF</span>

<span class="cm">/*</span>
<span class="cm">// In cases when an absolute &quot;zero&quot; tolerance</span>
<span class="cm">// is required to compare model space coordinates,</span>
<span class="cm">// ON_ZERO_TOLERANCE is used.  The value of</span>
<span class="cm">// ON_ZERO_TOLERANCE should be no smaller than</span>
<span class="cm">// ON_EPSILON and should be several orders of</span>
<span class="cm">// magnitude smaller than ON_SQRT_EPSILON</span>
<span class="cm">//</span>
<span class="cm">*/</span>
<span class="c1">//#define ON_ZERO_TOLERANCE 1.0e-12</span>
<span class="c1">// ON_ZERO_TOLERANCE = 2^-32</span>
<span class="cp">#define ON_ZERO_TOLERANCE 2.3283064365386962890625e-10</span>

<span class="cm">/*</span>
<span class="cm">// In cases when an relative &quot;zero&quot; tolerance is</span>
<span class="cm">// required for comparing model space coordinates,</span>
<span class="cm">// (fabs(a)+fabs(b))*ON_RELATIVE_TOLERANCE is used.</span>
<span class="cm">// ON_RELATIVE_TOLERANCE should be larger than</span>
<span class="cm">// ON_EPSILON and smaller than no larger than</span>
<span class="cm">// ON_ZERO_TOLERANCE*2^-10.</span>
<span class="cm">//</span>
<span class="cm">*/</span>
<span class="c1">// ON_RELATIVE_TOLERANCE = 2^-42</span>
<span class="cp">#define ON_RELATIVE_TOLERANCE 2.27373675443232059478759765625e-13</span>

<span class="cm">/*</span>
<span class="cm">// Bugs in geometry calculations involving world coordinates</span>
<span class="cm">// values &gt; ON_MAXIMUM_WORLD_COORDINATE_VALUE</span>
<span class="cm">// will be a low priority.</span>
<span class="cm">*/</span>
<span class="c1">// ON_MAXIMUM_VALUE = 2^27</span>
<span class="cp">#define ON_MAXIMUM_WORLD_COORDINATE_VALUE 1.34217728e8</span>

<span class="cm">/*</span>
<span class="cm">// The default test for deciding if a curvature value should be</span>
<span class="cm">// treated as zero is</span>
<span class="cm">// length(curvature) &lt;= ON_ZERO_CURVATURE_TOLERANCE.</span>
<span class="cm">// ON_ZERO_CURVATURE_TOLERANCE must be set so that</span>
<span class="cm">// ON_ZERO_CURVATURE_TOLERANCE &gt;= sqrt(3)*ON_ZERO_TOLERANCE</span>
<span class="cm">// so that K.IsTiny() = true implies |K| &lt;= ON_ZERO_CURVATURE_TOLERANCE</span>
<span class="cm">*/</span>
<span class="cp">#define ON_ZERO_CURVATURE_TOLERANCE 1.0e-8</span>

<span class="cm">/* default value for angle tolerances = 1 degree */</span>
<span class="cp">#define ON_DEFAULT_ANGLE_TOLERANCE (ON_PI/180.0)</span>
<span class="cp">#define ON_DEFAULT_ANGLE_TOLERANCE_COSINE 0.99984769515639123915701155881391</span>
<span class="cp">#define ON_MINIMUM_ANGLE_TOLERANCE (ON_DEFAULT_ANGLE_TOLERANCE/10.0)</span>

<span class="c1">// pair of integer indices.  This</span>
<span class="c1">// is intentionally a struct/typedef</span>
<span class="c1">// rather than a class so that it</span>
<span class="c1">// can be used in other structs.</span>
<span class="k">struct</span> <span class="n">tagON_2dex</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagON_2dex</span> <span class="n">ON_2dex</span><span class="p">;</span>

<span class="c1">// triplet of integer indices.  This</span>
<span class="c1">// is intentionally a struct/typedef</span>
<span class="c1">// rather than a class so that it</span>
<span class="c1">// can be used in other structs.</span>
<span class="k">struct</span> <span class="n">tagON_3dex</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagON_3dex</span> <span class="n">ON_3dex</span><span class="p">;</span>


<span class="c1">// quadruplet of integer indices.  This</span>
<span class="c1">// is intentionally a struct/typedef</span>
<span class="c1">// rather than a class so that it</span>
<span class="c1">// can be used in other structs.</span>
<span class="k">struct</span> <span class="n">tagON_4dex</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">l</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagON_4dex</span> <span class="n">ON_4dex</span><span class="p">;</span>

<span class="k">union</span> <span class="n">ON_U</span>
<span class="p">{</span>
  <span class="kt">char</span>      <span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// 8 bytes</span>
  <span class="n">ON__INT64</span> <span class="n">h</span><span class="p">;</span>    <span class="c1">// 64 bit integer</span>
  <span class="n">ON__INT32</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// 32 bit integer</span>
  <span class="kt">int</span>       <span class="n">j</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// two 32 bit integers</span>
  <span class="kt">void</span><span class="o">*</span>     <span class="n">p</span><span class="p">;</span>
  <span class="kt">double</span>    <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(ON_CPLUSPLUS)</span>

<span class="c1">// OpenNurbs enums</span>
<span class="k">class</span> <span class="nc">PCL_EXPORTS</span> <span class="n">ON_CLASS</span> <span class="n">ON</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Call before using openNURBS to ensure all class definitions</span>
<span class="cm">    are linked.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">Begin</span><span class="p">();</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Call when finished with openNURBS.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Currently does nothing.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">End</span><span class="p">();</span>

  <span class="c1">//////////</span>
  <span class="c1">// Version of opennurbs (YYYYMMDDn)</span>
  <span class="k">static</span>
  <span class="kt">int</span> <span class="nf">Version</span><span class="p">();</span>

  <span class="c1">//////////</span>
  <span class="c1">// McNeel subversion revsion used to build opennurbs</span>
  <span class="k">static</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">SourceRevision</span><span class="p">();</span>

  <span class="k">static</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">DocumentationRevision</span><span class="p">();</span>

  <span class="k">static</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">SourceBranch</span><span class="p">();</span>

  <span class="k">static</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">DocumentationBranch</span><span class="p">();</span>


  <span class="c1">//// File open/close for DLL use ///////////////////////////////////////////////</span>

  <span class="k">static</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="nf">OpenFile</span><span class="p">(</span> <span class="o">//</span> <span class="n">like</span> <span class="n">fopen</span><span class="p">()</span> <span class="o">-</span> <span class="n">needed</span> <span class="n">when</span> <span class="n">OpenNURBS</span> <span class="n">is</span> <span class="n">used</span> <span class="n">as</span> <span class="n">a</span> <span class="n">DLL</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filemode</span>
          <span class="p">);</span>

  <span class="k">static</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="nf">OpenFile</span><span class="p">(</span> <span class="o">//</span> <span class="n">like</span> <span class="n">fopen</span><span class="p">()</span> <span class="o">-</span> <span class="n">needed</span> <span class="n">when</span> <span class="n">OpenNURBS</span> <span class="n">is</span> <span class="n">used</span> <span class="n">as</span> <span class="n">a</span> <span class="n">DLL</span>
          <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">filemode</span>
          <span class="p">);</span>

  <span class="k">static</span>
  <span class="kt">int</span> <span class="nf">CloseFile</span><span class="p">(</span> <span class="o">//</span> <span class="n">like</span> <span class="n">fclose</span><span class="p">()</span> <span class="o">-</span> <span class="n">needed</span> <span class="n">when</span> <span class="n">OpenNURBS</span> <span class="n">is</span> <span class="n">used</span> <span class="n">as</span> <span class="n">a</span> <span class="n">DLL</span>
          <span class="kt">FILE</span><span class="o">*</span> <span class="c1">// pointer returned by OpenFile()</span>
          <span class="p">);</span>

  <span class="k">static</span>
  <span class="kt">int</span> <span class="nf">CloseAllFiles</span><span class="p">();</span> <span class="c1">// like _fcloseall() - needed when OpenNURBS is used as a DLL</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Uses the flavor of fstat that is appropriate for the platform.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    filename - [in]</span>
<span class="cm">    fp - [in]</span>
<span class="cm">    filesize - [out] (can be NULL if you do not want filesize)</span>
<span class="cm">    create_time - [out] (can be NULL if you do not want last create time)</span>
<span class="cm">    lastmodify_time - [out] (can be NULL if you do not want last modification time)</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if file exists, can be opened for read, and fstat worked.</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="kt">bool</span> <span class="nf">GetFileStats</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span>
                     <span class="kt">size_t</span><span class="o">*</span> <span class="n">filesize</span><span class="p">,</span>
                     <span class="kt">time_t</span><span class="o">*</span> <span class="n">create_time</span><span class="p">,</span>
                     <span class="kt">time_t</span><span class="o">*</span> <span class="n">lastmodify_time</span>
                    <span class="p">);</span>

  <span class="k">static</span>
  <span class="kt">bool</span> <span class="nf">GetFileStats</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span>
                     <span class="kt">size_t</span><span class="o">*</span> <span class="n">filesize</span><span class="p">,</span>
                     <span class="kt">time_t</span><span class="o">*</span> <span class="n">create_time</span><span class="p">,</span>
                     <span class="kt">time_t</span><span class="o">*</span> <span class="n">lastmodify_time</span>
                    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns true if pathname is a directory.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsDirectory</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">pathname</span> <span class="p">);</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsDirectory</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">utf8pathname</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns</span>
<span class="cm">    If the file is an opennurbs file, the version of the file</span>
<span class="cm">    is returned (2,3,4,50,...).</span>
<span class="cm">    If the file is not an opennurbs file, 0 is returned.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">IsOpenNURBSFile</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">pathname</span> <span class="p">);</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">IsOpenNURBSFile</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">utf8pathname</span> <span class="p">);</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">IsOpenNURBSFile</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="p">);</span>

  <span class="c1">//// Dimension Types ///////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">eAnnotationType</span>
  <span class="p">{</span>
    <span class="n">dtNothing</span><span class="p">,</span>
    <span class="n">dtDimLinear</span><span class="p">,</span>
    <span class="n">dtDimAligned</span><span class="p">,</span>
    <span class="n">dtDimAngular</span><span class="p">,</span>
    <span class="n">dtDimDiameter</span><span class="p">,</span>
    <span class="n">dtDimRadius</span><span class="p">,</span>
    <span class="n">dtLeader</span><span class="p">,</span>
    <span class="n">dtTextBlock</span><span class="p">,</span>
    <span class="n">dtDimOrdinate</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">eAnnotationType</span> <span class="nf">AnnotationType</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to eAnnotationType enum</span>


  <span class="c1">//// Text Display Modes ///////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">eTextDisplayMode</span>
  <span class="p">{</span>
    <span class="n">dtNormal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">dtHorizontal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">dtAboveLine</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">dtInLine</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">eTextDisplayMode</span> <span class="nf">TextDisplayMode</span><span class="p">(</span> <span class="kt">int</span><span class="p">);</span>

  <span class="c1">// Defines the current working space.</span>
  <span class="k">enum</span> <span class="n">active_space</span>
  <span class="p">{</span>
    <span class="n">no_space</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">model_space</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// 3d modeling or &quot;world&quot; space</span>
    <span class="n">page_space</span>  <span class="o">=</span> <span class="mi">2</span>  <span class="c1">// page/layout/paper/printing space</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">active_space</span> <span class="nf">ActiveSpace</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to active_space enum</span>



  <span class="c1">//// unit_system ///////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">unit_system</span>
  <span class="p">{</span>
    <span class="c1">// The constant enum values are saved in 3dm files</span>
    <span class="c1">// and must never be changed.  The values &gt; 11 were</span>
    <span class="c1">// added 5 April 2006.</span>
    <span class="n">no_unit_system</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>

    <span class="c1">// atomic distances</span>
    <span class="n">angstroms</span>      <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>  <span class="c1">// 1.0e-10 meters</span>

    <span class="c1">// SI units</span>
    <span class="n">nanometers</span>     <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>  <span class="c1">// 1.0e-9 meters</span>
    <span class="n">microns</span>        <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>  <span class="c1">// 1.0e-6 meters</span>
    <span class="n">millimeters</span>    <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>  <span class="c1">// 1.0e-3 meters</span>
    <span class="n">centimeters</span>    <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>  <span class="c1">// 1.0e-2 meters</span>
    <span class="n">decimeters</span>     <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>  <span class="c1">// 1.0e-1 meters</span>
    <span class="n">meters</span>         <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>
    <span class="n">dekameters</span>     <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>  <span class="c1">// 1.0e+1 meters</span>
    <span class="n">hectometers</span>    <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>  <span class="c1">// 1.0e+2 meters</span>
    <span class="n">kilometers</span>     <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>  <span class="c1">// 1.0e+3 meters</span>
    <span class="n">megameters</span>     <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>  <span class="c1">// 1.0e+6 meters</span>
    <span class="n">gigameters</span>     <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>  <span class="c1">// 1.0e+9 meters</span>

    <span class="c1">// english distances</span>
    <span class="n">microinches</span>    <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>  <span class="c1">//    2.54e-8 meters (1.0e-6 inches)</span>
    <span class="n">mils</span>           <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>  <span class="c1">//    2.54e-5 meters (0.001 inches)</span>
    <span class="n">inches</span>         <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span>  <span class="c1">//    0.0254  meters</span>
    <span class="n">feet</span>           <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span>  <span class="c1">//    0.3408  meters (12 inches)</span>
    <span class="n">yards</span>          <span class="o">=</span> <span class="mi">19</span><span class="p">,</span>  <span class="c1">//    0.9144  meters (36 inches)</span>
    <span class="n">miles</span>          <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>  <span class="c1">// 1609.344   meters (5280 feet)</span>

    <span class="c1">// printer distances</span>
    <span class="n">printer_point</span>  <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>  <span class="c1">// 1/72 inches (computer points)</span>
    <span class="n">printer_pica</span>   <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>  <span class="c1">// 1/6 inches  (computer picas)</span>

    <span class="c1">// terrestrial distances</span>
    <span class="n">nautical_mile</span>  <span class="o">=</span> <span class="mi">22</span><span class="p">,</span> <span class="c1">// 1852 meters</span>
                         <span class="c1">//    Approximately 1 minute of arc on a terrestrial great circle.</span>
                         <span class="c1">//    See http://en.wikipedia.org/wiki/Nautical_mile.</span>

    <span class="c1">// astronomical distances</span>
    <span class="n">astronomical</span>   <span class="o">=</span> <span class="mi">23</span><span class="p">,</span> <span class="c1">// 1.4959787e+11 // http://en.wikipedia.org/wiki/Astronomical_unit</span>
                         <span class="c1">// 1.495979e+11  // http://units.nist.gov/Pubs/SP811/appenB9.htm</span>
                         <span class="c1">//    An astronomical unit (au) is the mean distance from the</span>
                         <span class="c1">//    center of the earth to the center of the sun.</span>
    <span class="n">lightyears</span>     <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="c1">// 9.4607304725808e+15 // http://en.wikipedia.org/wiki/Light_year</span>
                         <span class="c1">// 9.46073e+15 meters  // http://units.nist.gov/Pubs/SP811/appenB9.htm</span>
                         <span class="c1">//    A light year is the distance light travels in one Julian year.</span>
                         <span class="c1">//    The speed of light is exactly 299792458 meters/second.</span>
                         <span class="c1">//    A Julian year is exactly 365.25 * 86400 seconds and is</span>
                         <span class="c1">//    approximately the time it takes for one earth orbit.</span>
    <span class="n">parsecs</span>        <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="c1">// 3.08567758e+16  // http://en.wikipedia.org/wiki/Parsec</span>
                         <span class="c1">// 3.085678e+16    // http://units.nist.gov/Pubs/SP811/appenB9.htm</span>

    <span class="c1">// Custom unit systems</span>
    <span class="n">custom_unit_system</span> <span class="o">=</span> <span class="mi">11</span> <span class="c1">// x meters with x defined in ON_3dmUnitsAndTolerances.m_custom_unit_scale</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">unit_system</span> <span class="nf">UnitSystem</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to unit_system enum</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Scale factor for changing unit &quot;standard&quot; systems.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    us_from - [in]</span>
<span class="cm">    us_to - [in]</span>
<span class="cm">  For example:</span>

<span class="cm">          100.0 = ON::UnitScale( ON::meters, ON::centimeters )</span>
<span class="cm">          2.54  = ON::UnitScale( ON::inches, ON::centimeters )</span>
<span class="cm">          12.0  = ON::UnitScale( ON::feet,   ON::inches )</span>

<span class="cm">  Remarks:</span>
<span class="cm">    If you are using custom unit systems, use the version</span>
<span class="cm">    that takes ON_UnitSystem or ON_3dmUnitsAndTolerances</span>
<span class="cm">    parameters.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="nf">UnitScale</span><span class="p">(</span>
      <span class="n">ON</span><span class="o">::</span><span class="n">unit_system</span> <span class="n">us_from</span><span class="p">,</span>
      <span class="n">ON</span><span class="o">::</span><span class="n">unit_system</span> <span class="n">us_to</span>
      <span class="p">);</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="nf">UnitScale</span><span class="p">(</span>
      <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_UnitSystem</span><span class="o">&amp;</span> <span class="n">us_from</span><span class="p">,</span>
      <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_UnitSystem</span><span class="o">&amp;</span> <span class="n">us_to</span>
      <span class="p">);</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="nf">UnitScale</span><span class="p">(</span>
      <span class="n">ON</span><span class="o">::</span><span class="n">unit_system</span> <span class="n">us_from</span><span class="p">,</span>
      <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_UnitSystem</span><span class="o">&amp;</span> <span class="n">us_to</span>
      <span class="p">);</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="nf">UnitScale</span><span class="p">(</span>
      <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_UnitSystem</span><span class="o">&amp;</span> <span class="n">us_from</span><span class="p">,</span>
      <span class="n">ON</span><span class="o">::</span><span class="n">unit_system</span> <span class="n">us_to</span>
      <span class="p">);</span>
  <span class="k">static</span> <span class="kt">double</span> <span class="nf">UnitScale</span><span class="p">(</span>
      <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_3dmUnitsAndTolerances</span><span class="o">&amp;</span> <span class="n">us_from</span><span class="p">,</span>
      <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_3dmUnitsAndTolerances</span><span class="o">&amp;</span> <span class="n">us_to</span>
      <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns the string &quot; : &quot;.  This is the string Rhino uses</span>
<span class="cm">    to separate reference model names from the root name for</span>
<span class="cm">    things like layer, block definition, material, linetype,</span>
<span class="cm">    dimstyle and font names.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON::NameReferenceDelimiterLength()</span>
<span class="cm">    ON::IsNameReferenceDelimiter()</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">NameReferenceDelimiter</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns the number of characters in the string returned</span>
<span class="cm">    by ON::NameReferenceDelimiter().</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON::NameReferenceDelimiterLength()</span>
<span class="cm">    ON::IsNameReferenceDelimiter()</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">NameReferenceDelimiterLength</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Test a string to see if its beginning matches the</span>
<span class="cm">    string returned by ON::NameReferenceDelimiter().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    s - [in];</span>
<span class="cm">      string to test.</span>
<span class="cm">  Returns:</span>
<span class="cm">    null:</span>
<span class="cm">      The beginning of the string does not match ON::NameReferenceDelimiter().</span>
<span class="cm">    non-null:</span>
<span class="cm">      The beginning of the string matches ON::NameReferenceDelimiter(). The</span>
<span class="cm">      returned pointer is the first character in s after the last character</span>
<span class="cm">      of the delimiter.  Put another way, if the beginning of s matches</span>
<span class="cm">      the string  ON::NameReferenceDelimiter(), then the returned pointer is</span>
<span class="cm">      s + ON::NameReferenceDelimiterLength().</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON::NameReferenceDelimiter()</span>
<span class="cm">    ON::NameReferenceDelimiterLength()</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">IsNameReferenceDelimiter</span><span class="p">(</span><span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>

  <span class="c1">//// distance_display_mode ///////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">distance_display_mode</span>
  <span class="p">{</span>
    <span class="n">decimal</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">fractional</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">feet_inches</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">distance_display_mode</span> <span class="nf">DistanceDisplayMode</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to distance_display_mode enum</span>


  <span class="c1">//// point_style ///////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">point_style</span>
  <span class="p">{</span>
    <span class="n">unknown_point_style</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">not_rational</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">homogeneous_rational</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">euclidean_rational</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">intrinsic_point_style</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// point format used in definition</span>
    <span class="n">point_style_count</span>     <span class="o">=</span> <span class="mi">5</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">point_style</span> <span class="nf">PointStyle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to point_style enum</span>

  <span class="c1">//// knot_style ///////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">knot_style</span> <span class="c1">// if a knot vector meets the conditions of two styles,</span>
  <span class="p">{</span>               <span class="c1">// then the style with the lowest value is used</span>
    <span class="n">unknown_knot_style</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// unknown knot style</span>
    <span class="n">uniform_knots</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// uniform knots (ends not clamped)</span>
    <span class="n">quasi_uniform_knots</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// uniform knots (clamped ends, degree &gt;= 2)</span>
    <span class="n">piecewise_bezier_knots</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// all internal knots have full multiplicity</span>
    <span class="n">clamped_end_knots</span>      <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// clamped end knots (with at least 1 interior non-uniform knot)</span>
    <span class="n">non_uniform_knots</span>      <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="c1">// known to be none of the above</span>
    <span class="n">knot_style_count</span>       <span class="o">=</span> <span class="mi">6</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">knot_style</span> <span class="nf">KnotStyle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to knot_style enum</span>

  <span class="c1">//// continuity ////////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">continuity</span>
  <span class="p">{</span>
    <span class="n">unknown_continuity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1">// These test for parametric continuity.  In particular,</span>
    <span class="c1">// all types of ON_Curves are considered infinitely</span>
    <span class="c1">// continuous at the start/end of the evaluation domain.</span>
    <span class="n">C0_continuous</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span> <span class="c1">// continuous function</span>
    <span class="n">C1_continuous</span> <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span> <span class="c1">// continuous first derivative</span>
    <span class="n">C2_continuous</span> <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span> <span class="c1">// continuous first and second derivative</span>
    <span class="n">G1_continuous</span> <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span> <span class="c1">// continuous unit tangent</span>
    <span class="n">G2_continuous</span> <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span> <span class="c1">// continuous unit tangent and curvature</span>

    <span class="c1">// 20 March 2003 Dale Lear added these.</span>
    <span class="c1">//</span>
    <span class="c1">// Continuity tests using the following enum values</span>
    <span class="c1">// are identical to tests using the preceding enum values</span>
    <span class="c1">// on the INTERIOR of a curve&#39;s domain.  At the END of</span>
    <span class="c1">// a curve a &quot;locus&quot; test is performed in place of a</span>
    <span class="c1">// parametric test. In particular, at the END of a domain,</span>
    <span class="c1">// all open curves are locus discontinuous.  At the END of</span>
    <span class="c1">// a domain, all closed curves are at least C0_locus_continuous.</span>
    <span class="c1">// By convention all ON_Curves are considered</span>
    <span class="c1">// locus continuous at the START of the evaluation domain.</span>
    <span class="c1">// This convention is not strictly correct, but is was</span>
    <span class="c1">// adopted to make iterative kink finding tools easier to</span>
    <span class="c1">// use and so that locus discontinuities are reported once</span>
    <span class="c1">// at the end parameter of a curve rather than twice.</span>
    <span class="n">C0_locus_continuous</span> <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span> <span class="c1">// locus continuous function</span>
    <span class="n">C1_locus_continuous</span> <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span> <span class="c1">// locus continuous first derivative</span>
    <span class="n">C2_locus_continuous</span> <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span> <span class="c1">// locus continuous first and second derivative</span>
    <span class="n">G1_locus_continuous</span> <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span> <span class="c1">// locus continuous unit tangent</span>
    <span class="n">G2_locus_continuous</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="c1">// locus continuous unit tangent and curvature</span>

    <span class="n">Cinfinity_continuous</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="c1">// analytic discontinuity</span>
    <span class="n">Gsmooth_continuous</span> <span class="o">=</span> <span class="mi">12</span>    <span class="c1">// aesthetic discontinuity</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Convert int to ON::continuity enum value</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">continuity</span> <span class="nf">Continuity</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Convert int to ON::continuity enum value and</span>
<span class="cm">    convert the locus flavored values to the parametric</span>
<span class="cm">    flavored values.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">continuity</span> <span class="nf">ParametricContinuity</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Convert int to ON::continuity enum value and</span>
<span class="cm">    convert the higher order flavored values to</span>
<span class="cm">    the corresponding C1 or G1 values needed to</span>
<span class="cm">    test piecewise linear curves.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">continuity</span> <span class="nf">PolylineContinuity</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="c1">//// curve_style ///////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">curve_style</span>
  <span class="p">{</span>
    <span class="n">unknown_curve_style</span>   <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
    <span class="n">line</span>                  <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
    <span class="n">circle</span>                <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>
    <span class="n">ellipse</span>               <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span> <span class="c1">// with distinct foci (not a circle)</span>
    <span class="n">parabola</span>              <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>
    <span class="n">hyperbola</span>             <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>
    <span class="n">planar_polyline</span>       <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span> <span class="c1">// not a line segment</span>
    <span class="n">polyline</span>              <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span> <span class="c1">// non-planar polyline</span>
    <span class="n">planar_freeform_curve</span> <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span> <span class="c1">// planar but none of the above</span>
    <span class="n">freeform_curve</span>        <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span> <span class="c1">// known to be none of the above</span>
    <span class="n">curve_style_count</span>     <span class="o">=</span> <span class="mi">10</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">curve_style</span> <span class="nf">CurveStyle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to curve_style enum</span>

  <span class="c1">//// surface_style ///////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">surface_style</span>
  <span class="p">{</span>
    <span class="n">unknown_surface_style</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
    <span class="n">plane</span>                 <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
    <span class="n">circular_cylinder</span>     <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span> <span class="c1">// portion of right circular cylinder</span>
    <span class="n">elliptical_cylinder</span>   <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span> <span class="c1">// portion of right elliptical cylinder</span>
    <span class="n">circular_cone</span>         <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span> <span class="c1">// portion of right circular cone</span>
    <span class="n">elliptical_cone</span>       <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span> <span class="c1">// portion of right elliptical cone</span>
    <span class="n">sphere</span>                <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span> <span class="c1">// portion of sphere</span>
    <span class="n">torus</span>                 <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span> <span class="c1">// portion of torus</span>
    <span class="n">surface_of_revolution</span> <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span> <span class="c1">// portion of surface of revolution that is none of the above</span>
    <span class="n">ruled_surface</span>         <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span> <span class="c1">// portion of a ruled surface this is none of the above</span>
    <span class="n">freeform_surface</span>      <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="c1">// known to be none of the above</span>
    <span class="n">surface_style_count</span>   <span class="o">=</span> <span class="mi">11</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">surface_style</span> <span class="nf">SurfaceStyle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to surface_style enum</span>

  <span class="c1">//// sort_algorithm ///////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">sort_algorithm</span>
  <span class="p">{</span>
    <span class="n">heap_sort</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">quick_sort</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">sort_algorithm</span> <span class="nf">SortAlgorithm</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to sort_method enum</span>

  <span class="c1">//// endian-ness ///////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">endian</span> <span class="p">{</span>
    <span class="n">little_endian</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// least significant byte first or reverse byte order - Intel x86, ...</span>
    <span class="n">big_endian</span>    <span class="o">=</span> <span class="mi">1</span>  <span class="c1">// most significant byte first - Motorola, Sparc, MIPS, ...</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">endian</span> <span class="nf">Endian</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to endian enum</span>
  <span class="k">static</span> <span class="n">endian</span> <span class="nf">Endian</span><span class="p">();</span>    <span class="c1">// returns endian-ness of current CPU</span>

  <span class="c1">//// archive modes //////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">archive_mode</span>
  <span class="p">{</span>
    <span class="n">unknown_archive_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">read</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// all read modes have bit 0x0001 set</span>
    <span class="n">write</span>     <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// all write modes have bit 0x0002 set</span>
    <span class="n">readwrite</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">read3dm</span>   <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">write3dm</span>  <span class="o">=</span> <span class="mi">6</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">archive_mode</span> <span class="nf">ArchiveMode</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to endian enum</span>


  <span class="c1">//// view projections ///////////////////////////////////////////////////////////</span>

  <span class="c1">// The x/y/z_2pt_perspective_view projections are ordinary perspective</span>
  <span class="c1">// projection. Using these values insures the ON_Viewport member</span>
  <span class="c1">// fuctions properly constrain the camera up and camera direction vectors</span>
  <span class="c1">// to preserve the specified perspective vantage.</span>
  <span class="k">enum</span> <span class="n">view_projection</span>
  <span class="p">{</span>
    <span class="n">unknown_view</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">parallel_view</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">perspective_view</span>   <span class="o">=</span> <span class="mi">2</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Converts integer into ON::view_projection enum value.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    i - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    ON::view_projection enum with same value as i.</span>
<span class="cm">    If i is not an ON::view_projection enum value,</span>
<span class="cm">    then ON::unknow_view is returned.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">view_projection</span> <span class="nf">ViewProjection</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    projection - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if projection is ON::perspective_view.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsPerspectiveProjection</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">view_projection</span> <span class="n">projection</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    projection - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if projection is ON::parallel_view.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsParallelProjection</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">view_projection</span> <span class="n">projection</span> <span class="p">);</span>

  <span class="c1">//// view coordinates ///////////////////////////////////////////////////////////</span>

  <span class="k">enum</span> <span class="n">coordinate_system</span>
  <span class="p">{</span>
    <span class="n">world_cs</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">camera_cs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">clip_cs</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">screen_cs</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">coordinate_system</span> <span class="nf">CoordinateSystem</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to coordinate_system enum</span>

  <span class="c1">//// exception types ///////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">exception_type</span>
  <span class="p">{</span>
    <span class="n">unknown_exception</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">out_of_memory</span><span class="p">,</span>
    <span class="n">corrupt_object</span><span class="p">,</span>               <span class="c1">// invalid object encountered - continuing would crash or</span>
                                  <span class="c1">// result in corrupt object being saved in archive.</span>
    <span class="n">unable_to_write_archive</span><span class="p">,</span>      <span class="c1">// write operation failed - out of file space/read only mode/...?</span>
    <span class="n">unable_to_read_archive</span><span class="p">,</span>       <span class="c1">// read operation failed - truncated archive/locked file/... ?</span>
    <span class="n">unable_to_seek_archive</span><span class="p">,</span>       <span class="c1">// seek operation failed - locked file/size out of bounds/... ?</span>
    <span class="n">unexpected_end_of_archive</span><span class="p">,</span>    <span class="c1">// truncated archive</span>
    <span class="n">unexpected_value_in_archive</span>   <span class="c1">// corrupt archive?</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">exception_type</span> <span class="nf">ExceptionType</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to exception_type enum</span>

  <span class="c1">//// layer mode ///////////////////////////////////////////////////////////</span>
  <span class="c1">// OBSOLETE</span>
  <span class="k">enum</span> <span class="n">layer_mode</span>
  <span class="p">{</span>
    <span class="n">normal_layer</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// visible, objects on layer can be selected and changed</span>
    <span class="n">hidden_layer</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// not visible, objects on layer cannot be selected or changed</span>
    <span class="n">locked_layer</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// visible, objects on layer cannot be selected or changed</span>
    <span class="n">layer_mode_count</span>   <span class="o">=</span> <span class="mi">3</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">layer_mode</span> <span class="nf">LayerMode</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to layer_mode enum</span>

  <span class="c1">//// object mode ///////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">object_mode</span>
  <span class="p">{</span>
    <span class="n">normal_object</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// object mode comes from layer</span>
    <span class="n">hidden_object</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// not visible, object cannot be selected or changed</span>
    <span class="n">locked_object</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// visible, object cannot be selected or changed</span>
    <span class="n">idef_object</span>      <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// object is part of an ON_InstanceDefinition.  The</span>
                          <span class="c1">// ON_InstanceDefinition m_object_uuid[] array will</span>
                          <span class="c1">// contain this object attribute&#39;s uuid.</span>
    <span class="n">object_mode_count</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">object_mode</span> <span class="nf">ObjectMode</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to object_mode enum</span>

  <span class="c1">//// object display color /////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">object_color_source</span>
  <span class="p">{</span>
    <span class="n">color_from_layer</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// use color assigned to layer</span>
    <span class="n">color_from_object</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// use color assigned to object</span>
    <span class="n">color_from_material</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// use diffuse render material color</span>
    <span class="n">color_from_parent</span>   <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// for objects with parents (like objects in instance references, use parent linetype)</span>
                             <span class="c1">// if no parent, treat as color_from_layer</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">object_color_source</span> <span class="nf">ObjectColorSource</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to object_color_source enum</span>

  <span class="c1">//// object plot color /////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">plot_color_source</span>
  <span class="p">{</span>
    <span class="n">plot_color_from_layer</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// use plot color assigned to layer</span>
    <span class="n">plot_color_from_object</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// use plot color assigned to object</span>
    <span class="n">plot_color_from_display</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// use display color</span>
    <span class="n">plot_color_from_parent</span>  <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// for objects with parents (like objects in instance references, use parent plot color)</span>
                                 <span class="c1">// if no parent, treat as plot_color_from_layer</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">plot_color_source</span> <span class="nf">PlotColorSource</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to plot_color_source enum</span>

  <span class="c1">//// object plot weight /////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">plot_weight_source</span>
  <span class="p">{</span>
    <span class="n">plot_weight_from_layer</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// use plot color assigned to layer</span>
    <span class="n">plot_weight_from_object</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// use plot color assigned to object</span>
    <span class="n">plot_weight_from_parent</span>  <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// for objects with parents (like objects in instance references, use parent plot color)</span>
                                  <span class="c1">// if no parent, treat as plot_color_from_layer</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">plot_weight_source</span> <span class="nf">PlotWeightSource</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to plot_color_source enum</span>

  <span class="c1">//// object linetype /////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">object_linetype_source</span>
  <span class="p">{</span>
    <span class="n">linetype_from_layer</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// use line style assigned to layer</span>
    <span class="n">linetype_from_object</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// use line style assigned to object</span>
    <span class="n">linetype_from_parent</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// for objects with parents (like objects in instance references, use parent linetype)</span>
                              <span class="c1">// if not parent, treat as linetype_from_layer.</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">object_linetype_source</span> <span class="nf">ObjectLinetypeSource</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to object_linetype_source enum</span>

  <span class="c1">//// object material /////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">object_material_source</span>
  <span class="p">{</span>
    <span class="n">material_from_layer</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// use material assigned to layer</span>
    <span class="n">material_from_object</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// use material assigned to object</span>
    <span class="n">material_from_parent</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// for objects with parents, like</span>
                              <span class="c1">// definition geometry in instance</span>
                              <span class="c1">// references and faces in polysurfaces,</span>
                              <span class="c1">// this value indicates the material</span>
                              <span class="c1">// definition should come from the parent.</span>
                              <span class="c1">// If the object does not have an</span>
                              <span class="c1">// obvious &quot;parent&quot;, then treat</span>
                              <span class="c1">// it the same as material_from_layer.</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">object_material_source</span> <span class="nf">ObjectMaterialSource</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to object_color_source enum</span>

  <span class="c1">//// light style /////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">light_style</span>
  <span class="p">{</span>
    <span class="n">unknown_light_style</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="c1">//view_directional_light   = 1, // light location and direction in clip coordinates</span>
    <span class="c1">//view_point_light         = 2,</span>
    <span class="c1">//view_spot_light          = 3,</span>
    <span class="n">camera_directional_light</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// light location and direction in camera coordinates</span>
    <span class="n">camera_point_light</span>       <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="c1">//   +x points to right, +y points up, +z points towards camera</span>
    <span class="n">camera_spot_light</span>        <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">world_directional_light</span>  <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="c1">// light location and direction in world coordinates</span>
    <span class="n">world_point_light</span>        <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="n">world_spot_light</span>         <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
    <span class="n">ambient_light</span>            <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="c1">// pure ambient light</span>
    <span class="n">world_linear_light</span>       <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
    <span class="n">world_rectangular_light</span>  <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">light_style_count</span>        <span class="o">=</span> <span class="mi">13</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">light_style</span> <span class="nf">LightStyle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to light_style enum</span>

  <span class="c1">//// curvature style /////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">curvature_style</span>
  <span class="p">{</span>
    <span class="n">unknown_curvature_style</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">gaussian_curvature</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">mean_curvature</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// unsigned mean curvature</span>
    <span class="n">min_curvature</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// minimum unsigned radius of curvature</span>
    <span class="n">max_curvature</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// maximum unsigned radius of curvature</span>
    <span class="n">curvature_style_count</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">curvature_style</span> <span class="nf">CurvatureStyle</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to curvature_style enum</span>

  <span class="c1">//// view display mode /////////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">display_mode</span>
  <span class="p">{</span>
    <span class="n">default_display</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// default display</span>
    <span class="n">wireframe_display</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// wireframe display</span>
    <span class="n">shaded_display</span>        <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// shaded display</span>
    <span class="n">renderpreview_display</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// render preview display</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">display_mode</span> <span class="nf">DisplayMode</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to display_mode enum</span>


  <span class="k">enum</span> <span class="n">view_type</span>
  <span class="p">{</span>
    <span class="n">model_view_type</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>       <span class="c1">// standard model space 3d view</span>
    <span class="n">page_view_type</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1">// a.k.a &quot;paper space&quot;, &quot;plot view&quot;, etc.</span>
                                <span class="c1">// A page view must be orthographic,</span>
                                <span class="c1">// the camera frame x,y,z direction must be</span>
                                <span class="c1">// world x,y,z (which means the camera direction</span>
                                <span class="c1">// is always (0,0,-1)).</span>
    <span class="n">nested_view_type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>       <span class="c1">// This view is a &quot;model&quot; view that is nested</span>
                                <span class="c1">// in another view.  The nesting and parent</span>
                                <span class="c1">// information is saved in ON_3dmView.</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">view_type</span> <span class="nf">ViewType</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to display_mode enum</span>


  <span class="c1">//// texture mapping mode ///////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// OBSOLETE</span>
  <span class="k">enum</span> <span class="n">texture_mode</span>
  <span class="p">{</span>
    <span class="n">no_texture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>        <span class="c1">// texture disabled</span>
    <span class="n">modulate_texture</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">// modulate with material diffuse color</span>
    <span class="n">decal_texture</span> <span class="o">=</span> <span class="mi">2</span>      <span class="c1">// decal</span>
  <span class="p">};</span>
  <span class="c1">// OBSOLETE</span>
  <span class="k">static</span> <span class="n">texture_mode</span> <span class="nf">TextureMode</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to texture_mode enum</span>
  <span class="c1">// OBSOLETE</span>
  <span class="c1">//</span>
  <span class="c1">/////////////////////////////////////////////////////////////////////////////</span>

  <span class="c1">//// object_type ///////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">object_type</span>
  <span class="p">{</span>
    <span class="c1">// Use with ON_Object::ObjectType() in situations where</span>
    <span class="c1">// using a switch() is better than a long string of if else if ...</span>
    <span class="c1">// if ( ON_Curve::Cast() ) ... else if ( ON_Surface::Cast() ) ...</span>
    <span class="c1">// ...</span>
    <span class="n">unknown_object_type</span>  <span class="o">=</span>          <span class="mi">0</span><span class="p">,</span>

    <span class="n">point_object</span>         <span class="o">=</span>          <span class="mi">1</span><span class="p">,</span> <span class="c1">// some type of ON_Point</span>
    <span class="n">pointset_object</span>      <span class="o">=</span>          <span class="mi">2</span><span class="p">,</span> <span class="c1">// some type of ON_PointCloud, ON_PointGrid, ...</span>
    <span class="n">curve_object</span>         <span class="o">=</span>          <span class="mi">4</span><span class="p">,</span> <span class="c1">// some type of ON_Curve like ON_LineCurve, ON_NurbsCurve, etc.</span>
    <span class="n">surface_object</span>       <span class="o">=</span>          <span class="mi">8</span><span class="p">,</span> <span class="c1">// some type of ON_Surface like ON_PlaneSurface, ON_NurbsSurface, etc.</span>
    <span class="n">brep_object</span>          <span class="o">=</span>       <span class="mh">0x10</span><span class="p">,</span> <span class="c1">// some type of ON_Brep</span>
    <span class="n">mesh_object</span>          <span class="o">=</span>       <span class="mh">0x20</span><span class="p">,</span> <span class="c1">// some type of ON_Mesh</span>
    <span class="n">layer_object</span>         <span class="o">=</span>       <span class="mh">0x40</span><span class="p">,</span> <span class="c1">// some type of ON_Layer</span>
    <span class="n">material_object</span>      <span class="o">=</span>       <span class="mh">0x80</span><span class="p">,</span> <span class="c1">// some type of ON_Material</span>
    <span class="n">light_object</span>         <span class="o">=</span>      <span class="mh">0x100</span><span class="p">,</span> <span class="c1">// some type of ON_Light</span>
    <span class="n">annotation_object</span>    <span class="o">=</span>      <span class="mh">0x200</span><span class="p">,</span> <span class="c1">// some type of ON_Annotation</span>
    <span class="n">userdata_object</span>      <span class="o">=</span>      <span class="mh">0x400</span><span class="p">,</span> <span class="c1">// some type of ON_UserData</span>
    <span class="n">instance_definition</span>  <span class="o">=</span>      <span class="mh">0x800</span><span class="p">,</span> <span class="c1">// some type of ON_InstanceDefinition</span>
    <span class="n">instance_reference</span>   <span class="o">=</span>     <span class="mh">0x1000</span><span class="p">,</span> <span class="c1">// some type of ON_InstanceRef</span>
    <span class="n">text_dot</span>             <span class="o">=</span>     <span class="mh">0x2000</span><span class="p">,</span> <span class="c1">// some type of ON_TextDot</span>
    <span class="n">grip_object</span>          <span class="o">=</span>     <span class="mh">0x4000</span><span class="p">,</span> <span class="c1">// selection filter value - not a real object type</span>
    <span class="n">detail_object</span>        <span class="o">=</span>     <span class="mh">0x8000</span><span class="p">,</span> <span class="c1">// some type of ON_DetailView</span>
    <span class="n">hatch_object</span>         <span class="o">=</span>    <span class="mh">0x10000</span><span class="p">,</span> <span class="c1">// some type of ON_Hatch</span>
    <span class="n">morph_control_object</span> <span class="o">=</span>    <span class="mh">0x20000</span><span class="p">,</span> <span class="c1">// some type of ON_MorphControl</span>
    <span class="n">loop_object</span>          <span class="o">=</span>    <span class="mh">0x80000</span><span class="p">,</span> <span class="c1">// some type of ON_BrepLoop</span>
    <span class="n">polysrf_filter</span>       <span class="o">=</span>   <span class="mh">0x200000</span><span class="p">,</span> <span class="c1">// selection filter value - not a real object type</span>
    <span class="n">edge_filter</span>          <span class="o">=</span>   <span class="mh">0x400000</span><span class="p">,</span> <span class="c1">// selection filter value - not a real object type</span>
    <span class="n">polyedge_filter</span>      <span class="o">=</span>   <span class="mh">0x800000</span><span class="p">,</span> <span class="c1">// selection filter value - not a real object type</span>
    <span class="n">meshvertex_object</span>    <span class="o">=</span> <span class="mh">0x01000000</span><span class="p">,</span> <span class="c1">// some type of ON_MeshVertexRef</span>
    <span class="n">meshedge_object</span>      <span class="o">=</span> <span class="mh">0x02000000</span><span class="p">,</span> <span class="c1">// some type of ON_MeshEdgeRef</span>
    <span class="n">meshface_object</span>      <span class="o">=</span> <span class="mh">0x04000000</span><span class="p">,</span> <span class="c1">// some type of ON_MeshFaceRef</span>
    <span class="n">cage_object</span>          <span class="o">=</span> <span class="mh">0x08000000</span><span class="p">,</span> <span class="c1">// some type of ON_NurbsCage</span>
    <span class="n">phantom_object</span>       <span class="o">=</span> <span class="mh">0x10000000</span><span class="p">,</span>
    <span class="n">clipplane_object</span>     <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">,</span>
    <span class="n">beam_object</span>          <span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span> <span class="c1">// obsolete - use extrusion_object</span>
    <span class="n">extrusion_object</span>     <span class="o">=</span> <span class="mh">0x40000000</span><span class="p">,</span> <span class="c1">// some type of ON_Extrusion</span>

    <span class="n">any_object</span>           <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>

    <span class="c1">// Please discuss any changes with Dale Lear</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">object_type</span> <span class="nf">ObjectType</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to object_type enum</span>

  <span class="c1">//// bitmap_type ///////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">bitmap_type</span>
  <span class="p">{</span>
    <span class="n">unknown_bitmap_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">windows_bitmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>     <span class="c1">// BITMAPINFO style</span>
    <span class="n">opengl_bitmap</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>      <span class="c1">// unpacked OpenGL RGB or RGBA</span>
    <span class="n">png_bitmap</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">bitmap_type</span> <span class="nf">BitmapType</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to bitmap_type enum</span>

  <span class="k">enum</span> <span class="n">object_decoration</span>
  <span class="p">{</span>
    <span class="n">no_object_decoration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">start_arrowhead</span>      <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span> <span class="c1">// arrow head at start</span>
    <span class="n">end_arrowhead</span>        <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span> <span class="c1">// arrow head at end</span>
    <span class="n">both_arrowhead</span>       <span class="o">=</span> <span class="mh">0x18</span>  <span class="c1">// arrow heads at start and end</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">object_decoration</span> <span class="nf">ObjectDecoration</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to line_pattern enum</span>

  <span class="k">enum</span> <span class="n">mesh_type</span>
  <span class="p">{</span>
    <span class="n">default_mesh</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">render_mesh</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">analysis_mesh</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">preview_mesh</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">any_mesh</span>      <span class="o">=</span> <span class="mi">4</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">mesh_type</span> <span class="nf">MeshType</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to mesh_type enum</span>


  <span class="c1">// Types of object snapping.</span>
  <span class="c1">// In situations where more than one type of snap applies,</span>
  <span class="c1">// snaps with higher value take precedence.</span>
  <span class="c1">// enum values must be a power of 2.</span>
  <span class="c1">// ON_ObjRef saves these values in files.  Do not change</span>
  <span class="c1">// the values.  The reason for the gaps between the enum</span>
  <span class="c1">// values is to leave room for future snaps with prededence</span>
  <span class="c1">// falling between existing snaps</span>
  <span class="k">enum</span> <span class="n">osnap_mode</span>
  <span class="p">{</span>
    <span class="n">os_none</span>          <span class="o">=</span>          <span class="mi">0</span><span class="p">,</span>
    <span class="n">os_near</span>          <span class="o">=</span>          <span class="mi">2</span><span class="p">,</span>
    <span class="n">os_focus</span>         <span class="o">=</span>          <span class="mi">8</span><span class="p">,</span>
    <span class="n">os_center</span>        <span class="o">=</span>       <span class="mh">0x20</span><span class="p">,</span>
    <span class="n">os_vertex</span>        <span class="o">=</span>       <span class="mh">0x40</span><span class="p">,</span>
    <span class="n">os_knot</span>          <span class="o">=</span>       <span class="mh">0x80</span><span class="p">,</span>
    <span class="n">os_quadrant</span>      <span class="o">=</span>      <span class="mh">0x200</span><span class="p">,</span>
    <span class="n">os_midpoint</span>      <span class="o">=</span>      <span class="mh">0x800</span><span class="p">,</span>
    <span class="n">os_intersection</span>  <span class="o">=</span>     <span class="mh">0x2000</span><span class="p">,</span>
    <span class="n">os_end</span>           <span class="o">=</span>    <span class="mh">0x20000</span><span class="p">,</span>
    <span class="n">os_perpendicular</span> <span class="o">=</span>    <span class="mh">0x80000</span><span class="p">,</span>
    <span class="n">os_tangent</span>       <span class="o">=</span>   <span class="mh">0x200000</span><span class="p">,</span>
    <span class="n">os_point</span>         <span class="o">=</span> <span class="mh">0x08000000</span><span class="p">,</span>
    <span class="n">os_all_snaps</span>     <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
  <span class="p">};</span>
  <span class="k">static</span> <span class="n">osnap_mode</span> <span class="nf">OSnapMode</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// convert integer to osnap_mode enum</span>


  <span class="c1">//// Types of Curves ///////////////////////////////////////////////////////////</span>
  <span class="k">enum</span> <span class="n">eCurveType</span>
  <span class="p">{</span>
    <span class="n">ctCurve</span><span class="p">,</span> <span class="c1">// nothing</span>
    <span class="n">ctArc</span><span class="p">,</span>
    <span class="n">ctCircle</span><span class="p">,</span>
    <span class="n">ctLine</span><span class="p">,</span>
    <span class="n">ctNurbs</span><span class="p">,</span>
    <span class="n">ctOnsurface</span><span class="p">,</span>
    <span class="n">ctProxy</span><span class="p">,</span>
    <span class="n">ctPolycurve</span><span class="p">,</span>
    <span class="n">ctPolyline</span><span class="p">,</span>
  <span class="p">};</span>


  <span class="c1">//// surface_loft_end_condition //////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// End condition paramter values for  ON_Curve::CreateCubicLoft() and</span>
  <span class="c1">// ON_Surface::CreateCubicLoft().</span>
  <span class="k">enum</span> <span class="n">cubic_loft_end_condition</span>
  <span class="p">{</span>
    <span class="n">cubic_loft_ec_quadratic</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">cubic_loft_ec_linear</span>         <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">cubic_loft_ec_cubic</span>          <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic_loft_ec_natural</span>        <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">cubic_loft_ec_unit_tangent</span>   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">cubic_loft_ec_1st_derivative</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">cubic_loft_ec_2nd_derivative</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">cubic_loft_ec_free_cv</span>        <span class="o">=</span> <span class="mi">7</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Convert an integer to cubic_loft_end_condition enum.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    i - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    corresponding cubic_loft_end_condition enum value.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If i does not correspond to a cubic_loft_end_condition</span>
<span class="cm">    enum value, then cubic_loft_ec_quadratic is returned.</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="n">cubic_loft_end_condition</span> <span class="nf">CubicLoftEndCondition</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// prohibit instantiaion</span>
  <span class="c1">//ON();             // no implementation</span>
  <span class="c1">//ON( const ON&amp; );  // no implementation</span>
  <span class="c1">//~ON();            // no implementation</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Component indices are used to provide a persistent way</span>
<span class="cm">  to identify portions of complex objects.</span>

<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_COMPONENT_INDEX</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="c1">// Do not change these values; they are stored in 3dm archives</span>
  <span class="c1">// and provide a persistent way to indentify components of</span>
  <span class="c1">// complex objects.</span>
  <span class="k">enum</span> <span class="n">TYPE</span>
  <span class="p">{</span>
    <span class="n">invalid_type</span>       <span class="o">=</span>   <span class="mi">0</span><span class="p">,</span>

    <span class="n">brep_vertex</span>        <span class="o">=</span>   <span class="mi">1</span><span class="p">,</span>
    <span class="n">brep_edge</span>          <span class="o">=</span>   <span class="mi">2</span><span class="p">,</span>
    <span class="n">brep_face</span>          <span class="o">=</span>   <span class="mi">3</span><span class="p">,</span>
    <span class="n">brep_trim</span>          <span class="o">=</span>   <span class="mi">4</span><span class="p">,</span>
    <span class="n">brep_loop</span>          <span class="o">=</span>   <span class="mi">5</span><span class="p">,</span>

    <span class="n">mesh_vertex</span>        <span class="o">=</span>  <span class="mi">11</span><span class="p">,</span>
    <span class="n">meshtop_vertex</span>     <span class="o">=</span>  <span class="mi">12</span><span class="p">,</span>
    <span class="n">meshtop_edge</span>       <span class="o">=</span>  <span class="mi">13</span><span class="p">,</span>
    <span class="n">mesh_face</span>          <span class="o">=</span>  <span class="mi">14</span><span class="p">,</span>

    <span class="n">idef_part</span>          <span class="o">=</span>  <span class="mi">21</span><span class="p">,</span>

    <span class="n">polycurve_segment</span>  <span class="o">=</span>  <span class="mi">31</span><span class="p">,</span>

    <span class="n">pointcloud_point</span>   <span class="o">=</span>  <span class="mi">41</span><span class="p">,</span>

    <span class="n">group_member</span>       <span class="o">=</span>  <span class="mi">51</span><span class="p">,</span>


    <span class="n">extrusion_bottom_profile</span> <span class="o">=</span> <span class="mi">61</span><span class="p">,</span> <span class="c1">// 3d bottom profile curves</span>
                                   <span class="c1">//   index identifies profile component</span>
    <span class="n">extrusion_top_profile</span>    <span class="o">=</span> <span class="mi">62</span><span class="p">,</span> <span class="c1">// 3d top profile curves</span>
                                   <span class="c1">//   index identifies profile component</span>
    <span class="n">extrusion_wall_edge</span>      <span class="o">=</span> <span class="mi">63</span><span class="p">,</span> <span class="c1">// 3d wall edge curve</span>
                                   <span class="c1">//   index/2: identifies profile component</span>
                                   <span class="c1">//   index%2: 0 = start, 1 = end</span>
    <span class="n">extrusion_wall_surface</span>   <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="c1">// side wall surfaces</span>
                                   <span class="c1">//   index: identifies profile component</span>
    <span class="n">extrusion_cap_surface</span>    <span class="o">=</span> <span class="mi">65</span><span class="p">,</span> <span class="c1">// bottom and top cap surfaces</span>
                                   <span class="c1">//   index: 0 = bottom, 1 = top</span>
    <span class="n">extrusion_path</span>           <span class="o">=</span> <span class="mi">66</span><span class="p">,</span> <span class="c1">// extrusion path (axis line)</span>
                                   <span class="c1">//   index -1 = entire path, 0 = start point, 1 = endpoint</span>

    <span class="n">dim_linear_point</span>   <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">dim_radial_point</span>   <span class="o">=</span> <span class="mi">101</span><span class="p">,</span>
    <span class="n">dim_angular_point</span>  <span class="o">=</span> <span class="mi">102</span><span class="p">,</span>
    <span class="n">dim_ordinate_point</span> <span class="o">=</span> <span class="mi">103</span><span class="p">,</span>
    <span class="n">dim_text_point</span>     <span class="o">=</span> <span class="mi">104</span><span class="p">,</span>

    <span class="n">no_type</span>           <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Safe conversion of integer value to TYPE enum.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    i - [in] integer with value equal to one of the TYPE enums.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The TYPE enum with the same numeric value</span>
<span class="cm">    or ON_COMPONENT_INDEX::invalid_type if no corresponding enum</span>
<span class="cm">    exists.</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="n">TYPE</span> <span class="nf">Type</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Dictionary compare on m_type, m_index as ints.</span>
<span class="cm">  Returns:</span>
<span class="cm">    &lt; 0: a &lt; b</span>
<span class="cm">    = 0: a = b</span>
<span class="cm">    &gt; 0: a &gt; b</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="kt">int</span> <span class="nf">Compare</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">*</span> <span class="n">b</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets m_type = invalid_type and m_index = -1.</span>
<span class="cm">  */</span>
  <span class="n">ON_COMPONENT_INDEX</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets m_type = type and m_index = index.</span>
<span class="cm">  */</span>
  <span class="n">ON_COMPONENT_INDEX</span><span class="p">(</span><span class="n">TYPE</span> <span class="n">type</span><span class="p">,</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Set</span><span class="p">(</span><span class="n">TYPE</span> <span class="n">type</span><span class="p">,</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets m_type = invalid_type and m_index = -1.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">UnSet</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type is set to a TYPE enum value between</span>
<span class="cm">    brep_vertex and polycurve_segment.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsSet</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type is set to one of the mesh or meshtop</span>
<span class="cm">    TYPE enum values and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsMeshComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type is set to one of the</span>
<span class="cm">    brep TYPE enum values and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsBrepComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = idef_part and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsIDefComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = polycurve_segment and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsPolyCurveComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = group_member and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsGroupMemberComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = extrusion_bottom_profile or extrusion_top_profile</span>
<span class="cm">    and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsExtrusionProfileComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = extrusion_path and -1 &lt;= m_index &lt;= 1.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsExtrusionPathComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = extrusion_wall_edge and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsExtrusionWallEdgeComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = extrusion_wall_surface and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsExtrusionWallSurfaceComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = extrusion_wall_surface or extrusion_wall_edge</span>
<span class="cm">    and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsExtrusionWallComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = extrusion_bottom_profile, extrusion_top_profile,</span>
<span class="cm">    extrusion_wall_edge, extrusion_wall_surface, extrusion_cap_surface</span>
<span class="cm">    or extrusion_path and m_index is reasonable.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsExtrusionComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = pointcloud_point and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsPointCloudComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if m_type = dim_... and m_index &gt;= 0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsAnnotationComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">TYPE</span> <span class="n">m_type</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  The interpretation of m_index depends on the m_type value.</span>

<span class="cm">    m_type             m_index interpretation (0 based indices)</span>

<span class="cm">    no_type            used when context makes it clear what array is being index</span>
<span class="cm">    brep_vertex        ON_Brep.m_V[] array index</span>
<span class="cm">    brep_edge          ON_Brep.m_E[] array index</span>
<span class="cm">    brep_face          ON_Brep.m_F[] array index</span>
<span class="cm">    brep_trim          ON_Brep.m_T[] array index</span>
<span class="cm">    brep_loop          ON_Brep.m_L[] array index</span>
<span class="cm">    mesh_vertex        ON_Mesh.m_V[] array index</span>
<span class="cm">    meshtop_vertex     ON_MeshTopology.m_topv[] array index</span>
<span class="cm">    meshtop_edge       ON_MeshTopology.m_tope[] array index</span>
<span class="cm">    mesh_face          ON_Mesh.m_F[] array index</span>
<span class="cm">    idef_part          ON_InstanceDefinition.m_object_uuid[] array index</span>
<span class="cm">    polycurve_segment  ON_PolyCurve::m_segment[] array index</span>

<span class="cm">    extrusion_bottom_profile  Use ON_Extrusion::Profile3d() to get 3d profile curve</span>
<span class="cm">    extrusion_top_profile     Use ON_Extrusion::Profile3d() to get 3d profile curve</span>
<span class="cm">    extrusion_wall_edge       Use ON_Extrusion::WallEdge() to get 3d line curve</span>
<span class="cm">    extrusion_wall_surface    Use ON_Extrusion::WallSurface() to get 3d wall surface</span>
<span class="cm">    extrusion_cap_surface      0 = bottom cap, 1 = top cap</span>
<span class="cm">    extrusion_path            -1 = entire path, 0 = start of path, 1 = end of path</span>

<span class="cm">    dim_linear_point   ON_LinearDimension2::POINT_INDEX</span>
<span class="cm">    dim_radial_point   ON_RadialDimension2::POINT_INDEX</span>
<span class="cm">    dim_angular_point  ON_AngularDimension2::POINT_INDEX</span>
<span class="cm">    dim_ordinate_point ON_OrdinateDimension2::POINT_INDEX</span>
<span class="cm">    dim_text_point     ON_TextEntity2 origin point</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="n">m_index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="n">ON_BEGIN_EXTERNC</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Sets Windows code page used to convert UNICODE (wchar_t) strings</span>
<span class="cm">  to multibyte (char) strings and vice verse.</span>
<span class="cm">Parameters:</span>
<span class="cm">  code_page - [in] code page to use when converting UNICODE strings</span>
<span class="cm">       to multibyte strings and vice verse.</span>
<span class="cm">Returns:</span>
<span class="cm">  previous value of Windows code page.</span>
<span class="cm">Remarks:</span>
<span class="cm">  For Windows NT/2000/XP, CP_THREAD_ACP will work for all</span>
<span class="cm">  locales if your app&#39;s thread is correctly configured.</span>
<span class="cm">  For Windows 95/98/ME you have to choose the locale.</span>

<span class="cm">  Conversions between UNICODE and multibyte strings happens when</span>
<span class="cm">  ON_wString converts a char* string to a wchar_t* string and</span>
<span class="cm">  when and ON_String converts a wchar_t* string to a char* string.</span>

<span class="cm">  All pertinant code is in opennurbs_defines.cpp.</span>

<span class="cm">See Also:</span>
<span class="cm">  ON_GetStringConversionWindowsCodePage</span>
<span class="cm">  on_WideCharToMultiByte</span>
<span class="cm">  on_MultiByteToWideChar</span>
<span class="cm">  ON_wString::operator=(const char*)</span>
<span class="cm">  ON_String::operator=(const wchar_t*)</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ON_SetStringConversionWindowsCodePage</span><span class="p">(</span>
                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">code_page</span>
                <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Gets Windows code page used to convert UNICODE (wchar_t) strings</span>
<span class="cm">  to multibyte (char) strings and vice verse.</span>
<span class="cm">Returns:</span>
<span class="cm">  Value of Windows code page used to convert strings.</span>
<span class="cm">Remarks:</span>
<span class="cm">  For Windows NT/2000/XP, CP_THREAD_ACP will work for all</span>
<span class="cm">  locales if your app&#39;s thread is correctly configured.</span>
<span class="cm">  For Windows 95/98/ME you have to choose the locale.</span>

<span class="cm">  Conversions between UNICODE and multibyte strings happens when</span>
<span class="cm">  ON_wString converts a char* string to a wchar_t* string and</span>
<span class="cm">  when and ON_String converts a wchar_t* string to a char* string.</span>

<span class="cm">  All pertinant code is in opennurbs_defines.cpp.</span>

<span class="cm">See Also:</span>
<span class="cm">  ON_GetStringConversionWindowsCodePage</span>
<span class="cm">  on_WideCharToMultiByte</span>
<span class="cm">  on_MultiByteToWideChar</span>
<span class="cm">  ON_wString::operator=(const char*)</span>
<span class="cm">  ON_String::operator=(const wchar_t*)</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ON_GetStringConversionWindowsCodePage</span><span class="p">();</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Sets Windows locale id used in case insensitive string</span>
<span class="cm">  compares.</span>
<span class="cm">Parameters:</span>
<span class="cm">  locale_id - [in] Windows locale id to use in case insensitive</span>
<span class="cm">                 string compares.</span>
<span class="cm">  bWin9X - [in] True if OS is Windows 95/98/ME (which has</span>
<span class="cm">                poor UNICODE support).</span>
<span class="cm">Returns:</span>
<span class="cm">  Previous value of Windows locale id.</span>
<span class="cm">Remarks:</span>
<span class="cm">  All pertinant code is in opennurbs_defines.cpp.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_GetStringConversionWindowsLocaleID</span>
<span class="cm">  on_wcsicmp</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ON_SetStringConversionWindowsLocaleID</span><span class="p">(</span>
                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">locale_id</span><span class="p">,</span>
                <span class="n">ON_BOOL32</span> <span class="n">bWin9X</span>
                <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Gets Windows locale id used in case insensitive string</span>
<span class="cm">  compares.</span>
<span class="cm">Returns:</span>
<span class="cm">  Value of Windows locale id used in case insensitive string</span>
<span class="cm">  compares.</span>
<span class="cm">Remarks:</span>
<span class="cm">  All pertinant code is in opennurbs_defines.cpp.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_SetStringConversionWindowsLocaleID</span>
<span class="cm">  on_wcsicmp</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ON_GetStringConversionWindowsLocaleID</span><span class="p">();</span>

<span class="c1">// on_wcsicmp() is a wrapper for case insensitive wide string compare</span>
<span class="c1">// and calls one of _wcsicmp() or wcscasecmp() depending on OS.</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">on_wcsicmp</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="p">);</span>

<span class="c1">// on_wcsupr() calls _wcsupr() or wcsupr() depending on OS</span>
<span class="n">ON_DECL</span>
<span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">on_wcsupr</span><span class="p">(</span><span class="kt">wchar_t</span><span class="o">*</span><span class="p">);</span>

<span class="c1">// on_wcslwr() calls _wcslwr() or wcslwr() depending on OS</span>
<span class="n">ON_DECL</span>
<span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">on_wcslwr</span><span class="p">(</span><span class="kt">wchar_t</span><span class="o">*</span><span class="p">);</span>

<span class="c1">// on_wcsrev() calls _wcsrev() or wcsrev() depending on OS</span>
<span class="n">ON_DECL</span>
<span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">on_wcsrev</span><span class="p">(</span><span class="kt">wchar_t</span><span class="o">*</span><span class="p">);</span>

<span class="c1">// on_stricmp() is a wrapper for case insensitive string compare</span>
<span class="c1">// and calls one of _stricmp(), stricmp(), or strcasecmp()</span>
<span class="c1">// depending on OS.</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">on_stricmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="c1">// on_stricmp() is a wrapper for case insensitive string compare</span>
<span class="c1">// and calls one of _strnicmp() or strncasecmp()</span>
<span class="c1">// depending on OS.</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">on_strnicmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">s2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">// on_strupr() calls _strupr() or strupr() depending on OS</span>
<span class="n">ON_DECL</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">on_strupr</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="c1">// on_strlwr() calls _strlwr() or strlwr() depending on OS</span>
<span class="n">ON_DECL</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">on_strlwr</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="c1">// on_strrev() calls _strrev() or strrev() depending on OS</span>
<span class="n">ON_DECL</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">on_strrev</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Calls ON_ConvertWideCharToUTF8()</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">on_WideCharToMultiByte</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span><span class="p">,</span> <span class="c1">// lpWideCharStr,</span>
    <span class="kt">int</span><span class="p">,</span>            <span class="c1">// cchWideChar,</span>
    <span class="kt">char</span><span class="o">*</span><span class="p">,</span>          <span class="c1">// lpMultiByteStr,</span>
    <span class="kt">int</span>             <span class="c1">// cchMultiByte,</span>
    <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Calls ON_ConvertUTF8ToWideChar()</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">on_MultiByteToWideChar</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="c1">// lpMultiByteStr,</span>
    <span class="kt">int</span><span class="p">,</span>         <span class="c1">// cchMultiByte,</span>
    <span class="kt">wchar_t</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// lpWideCharStr,</span>
    <span class="kt">int</span>          <span class="c1">// cchWideChar</span>
    <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Find the locations in a path the specify the drive, directory,</span>
<span class="cm">  file name and file extension.</span>
<span class="cm">Parameters:</span>
<span class="cm">  path - [in]</span>
<span class="cm">    UTF-8 encoded string that is a legitimate path to a file.</span>
<span class="cm">  drive - [out] (pass null if you don&#39;t need the drive)</span>
<span class="cm">    If drive is not null and the path parameter begins with</span>
<span class="cm">    an A-Z or a-z followed by a colon ( : ) then the returned</span>
<span class="cm">    value of *drive will equal the input value of path.</span>
<span class="cm">  dir - [out] (pass null if you don&#39;t need the directory)</span>
<span class="cm">    If dir is not null and the path parameter contains a</span>
<span class="cm">    directory specification, then the returned value of *dir</span>
<span class="cm">    will point to the character in path where the directory</span>
<span class="cm">    specification begins.</span>
<span class="cm">  fname - [out] (pass null if you don&#39;t need the file name)</span>
<span class="cm">    If fname is not null and the path parameter contains a</span>
<span class="cm">    file name specification, then the returned value of *fname</span>
<span class="cm">    will point to the character in path where the file name</span>
<span class="cm">    specification begins.</span>
<span class="cm">  ext - [out] (pass null if you don&#39;t need the extension)</span>
<span class="cm">    If ext is not null and the path parameter contains a</span>
<span class="cm">    file extension specification, then the returned value of</span>
<span class="cm">    *ext will point to the &#39;.&#39; character in path where the file</span>
<span class="cm">    extension specification begins.</span>
<span class="cm">Remarks:</span>
<span class="cm">  This function will treat a front slash ( / ) and a back slash</span>
<span class="cm">  ( \ ) as directory separators.  Because this function parses</span>
<span class="cm">  file names store in .3dm files and the .3dm file may have been</span>
<span class="cm">  written on a Windows computer and then read on a another</span>
<span class="cm">  computer, it looks for a drive dpecification even when the</span>
<span class="cm">  operating system is not Windows.</span>
<span class="cm">  This function will not return an directory that does not</span>
<span class="cm">  end with a trailing slash.</span>
<span class="cm">  This function will not return an empty filename and a non-empty</span>
<span class="cm">  extension.</span>
<span class="cm">  This function parses the path string according to these rules.</span>
<span class="cm">  It does not check the actual file system to see if the answer</span>
<span class="cm">  is correct.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_String::SplitPath</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">void</span> <span class="nf">on_splitpath</span><span class="p">(</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">drive</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">dir</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">fname</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">ext</span>
  <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Find the locations in a path the specify the drive, directory,</span>
<span class="cm">  file name and file extension.</span>
<span class="cm">Parameters:</span>
<span class="cm">  path - [in]</span>
<span class="cm">    UTF-8, UTF-16 or UTF-32 encoded wchar_t string that is a</span>
<span class="cm">    legitimate path to a file.</span>
<span class="cm">  drive - [out] (pass null if you don&#39;t need the drive)</span>
<span class="cm">    If drive is not null and the path parameter begins with</span>
<span class="cm">    an A-Z or a-z followed by a colon ( : ) then the returned</span>
<span class="cm">    value of *drive will equal the input value of path.</span>
<span class="cm">  dir - [out] (pass null if you don&#39;t need the directory)</span>
<span class="cm">    If dir is not null and the path parameter contains a</span>
<span class="cm">    directory specification, then the returned value of *dir</span>
<span class="cm">    will point to the character in path where the directory</span>
<span class="cm">    specification begins.</span>
<span class="cm">  fname - [out] (pass null if you don&#39;t need the file name)</span>
<span class="cm">    If fname is not null and the path parameter contains a</span>
<span class="cm">    file name specification, then the returned value of *fname</span>
<span class="cm">    will point to the character in path where the file name</span>
<span class="cm">    specification begins.</span>
<span class="cm">  ext - [out] (pass null if you don&#39;t need the extension)</span>
<span class="cm">    If ext is not null and the path parameter contains a</span>
<span class="cm">    file extension specification, then the returned value of</span>
<span class="cm">    *ext will point to the &#39;.&#39; character in path where the file</span>
<span class="cm">    extension specification begins.</span>
<span class="cm">Remarks:</span>
<span class="cm">  This function will treat a front slash ( / ) and a back slash</span>
<span class="cm">  ( \ ) as directory separators.  Because this function parses</span>
<span class="cm">  file names store in .3dm files and the .3dm file may have been</span>
<span class="cm">  written on a Windows computer and then read on a another</span>
<span class="cm">  computer, it looks for a drive dpecification even when the</span>
<span class="cm">  operating system is not Windows.</span>
<span class="cm">  This function will not return an directory that does not</span>
<span class="cm">  end with a trailing slash.</span>
<span class="cm">  This function will not return an empty filename and a non-empty</span>
<span class="cm">  extension.</span>
<span class="cm">  This function parses the path string according to these rules.</span>
<span class="cm">  It does not check the actual file system to see if the answer</span>
<span class="cm">  is correct.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_wString::SplitPath</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span> <span class="kt">void</span> <span class="nf">on_wsplitpath</span><span class="p">(</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">**</span> <span class="n">drive</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">**</span> <span class="n">dir</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">**</span> <span class="n">fname</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">**</span> <span class="n">ext</span>
  <span class="p">);</span>

<span class="n">ON_END_EXTERNC</span>


<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_detail.h.html" class="btn btn-neutral float-right" title="File opennurbs_detail.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_defines.h.html" class="btn btn-neutral float-left" title="File opennurbs_defines.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>