

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_brep.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_circle.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_circle.h.html" />
    <link rel="prev" title="File opennurbs_brep.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_brep.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_brep.h.html">File opennurbs_brep.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_brep.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_brep.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-brep-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-brep-h"></span><h1>Program Listing for File opennurbs_brep.h<a class="headerlink" href="#program-listing-for-file-opennurbs-brep-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_brep.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-brep-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_brep.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">//   Definition of b-rep and its parts</span>
<span class="c1">//</span>
<span class="c1">////////////////////////////////////////////////////////////////</span>

<span class="cp">#if !defined(OPENNURBS_BREP_INC_)</span>
<span class="cp">#define OPENNURBS_BREP_INC_</span>

<span class="k">class</span> <span class="nc">ON_BrepTrim</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_BrepEdge</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_BrepLoop</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_BrepFace</span><span class="p">;</span>


<span class="c1">// TEMPORARY DEFINES SO I DON&#39;T BREAK THE BUILD</span>
<span class="cp">#define m_vertex_user_i m_vertex_user.i</span>
<span class="cp">#define m_trim_user_i m_trim_user.i</span>
<span class="cp">#define m_edge_user_i m_edge_user.i</span>
<span class="cp">#define m_loop_user_i m_loop_user.i</span>
<span class="cp">#define m_face_user_i m_face_user.i</span>

<span class="c1">// Description:</span>
<span class="c1">//   Brep vertex information is stored in ON_BrepVertex classes.</span>
<span class="c1">//   ON_Brep.m_V[] is an array of all the vertices in the brep.</span>
<span class="c1">//</span>
<span class="c1">//   If a vertex is a point on a face, then brep.m_E[m_ei]</span>
<span class="c1">//   will be an edge with no 3d curve.  This edge will have</span>
<span class="c1">//   a single trim with type ON_BrepTrim::ptonsrf.  There</span>
<span class="c1">//   will be a loop containing this single trim.</span>
<span class="c1">//   Use ON_Brep::NewPointOnFace() to create vertices that are</span>
<span class="c1">//   points on faces.</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepVertex</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Point</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_BrepVertex</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_vertex_user.</span>
  <span class="c1">// The value is of m_vertex_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_vertex_user</span><span class="p">;</span>

  <span class="c1">// index of the vertex in the ON_Brep.m_V[] array</span>
  <span class="kt">int</span> <span class="n">m_vertex_index</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Construction</span>
  <span class="c1">//</span>
  <span class="c1">// In general, you should not directly create ON_BrepVertex classes.</span>
  <span class="c1">// Use ON_Brep::NewVertex instead.</span>
  <span class="n">ON_BrepVertex</span><span class="p">();</span>
  <span class="n">ON_BrepVertex</span><span class="p">(</span>
    <span class="kt">int</span> <span class="c1">// vertex index</span>
    <span class="p">);</span>
  <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepVertex</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// virtual ON_Object::SizeOf override</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::DataCRC override</span>
  <span class="n">ON__UINT32</span> <span class="nf">DataCRC</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">current_remainder</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::Dump() override</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// for debugging</span>

  <span class="c1">// virtual ON_Object::Write() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::Read() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::ComponentIndex() override</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Interface</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Set vertex location.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   point - [in] 3d vertex location</span>
  <span class="kt">bool</span> <span class="nf">SetPoint</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="c1">// point</span>
          <span class="p">);</span>

  <span class="c1">// Returns:</span>
  <span class="c1">//   Vertex location.</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Point</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Returns:</span>
  <span class="c1">//   value of ON_BrepVertex::m_tolerance</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   Use ON_Brep::SetVertexTolerance( ON_BrepVertex&amp; ) to set tolerances.</span>
  <span class="kt">double</span> <span class="nf">Tolerance</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Returns:</span>
  <span class="c1">//   number of edges that begin or end at this vertex.</span>
  <span class="kt">int</span> <span class="nf">EdgeCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation</span>

  <span class="c1">// indices of edges starting/ending at this vertex</span>
  <span class="c1">//</span>
  <span class="c1">// For closed edges, edge.m_vi[0] = edge.m_vi[1] and</span>
  <span class="c1">// edge.m_edge_index appears twice in the m_ei[] array.</span>
  <span class="c1">// The first occurance of edge.m_edge_index in m_ei[]</span>
  <span class="c1">// is for the closed edge starting the vertex.</span>
  <span class="c1">// The second occurance of edge,m_edge_index in m_ei[]</span>
  <span class="c1">// is for the closed edge ending at the vertex.</span>
  <span class="c1">// C.f. ON_Brep::Next/PrevEdge().</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_ei</span><span class="p">;</span>

  <span class="c1">// accuracy of vertex point (&gt;=0.0 or ON_UNSET_VALUE)</span>
  <span class="c1">//</span>
  <span class="c1">// A value of ON_UNSET_VALUE indicates that the</span>
  <span class="c1">// tolerance should be computed.</span>
  <span class="c1">//</span>
  <span class="c1">// A value of 0.0 indicates that the distance</span>
  <span class="c1">// from the vertex to any applicable edge or trim</span>
  <span class="c1">// end is &lt;=  ON_ZERO_TOLERANCE</span>
  <span class="c1">//</span>
  <span class="c1">// If an edge begins or ends at this vertex,</span>
  <span class="c1">// then the distance from the vertex&#39;s</span>
  <span class="c1">// 3d point to the appropriate end of the</span>
  <span class="c1">// edge&#39;s 3d curve must be &lt;= this tolerance.</span>
  <span class="c1">//</span>
  <span class="c1">// If a trim begins or ends at this vertex,</span>
  <span class="c1">// then the distance from the vertex&#39;s 3d point</span>
  <span class="c1">// to the 3d point on the surface obtained by</span>
  <span class="c1">// evaluating the surface at the appropriate</span>
  <span class="c1">// end of the trimming curve must be &lt;= this</span>
  <span class="c1">// tolerance.</span>
  <span class="kt">double</span> <span class="n">m_tolerance</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">ON_BrepVertex</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>

<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Brep edge information is stored in ON_BrepEdge classes.</span>
<span class="cm">  ON_Brep.m_E[] is an array of all the edges in the brep.</span>

<span class="cm">  An ON_BrepEdge is derived from ON_CurveProxy so the the</span>
<span class="cm">  edge can supply easy to use evaluation tools via</span>
<span class="cm">  the ON_Curve virtual member functions.</span>

<span class="cm">  Note well that the domains and orientations of the curve</span>
<span class="cm">  m_C3[edge.m_c3i] and the edge as a curve may not</span>
<span class="cm">  agree.</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepEdge</span> <span class="p">:</span> <span class="k">public</span>  <span class="n">ON_CurveProxy</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_BrepEdge</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>

  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_edge_user.</span>
  <span class="c1">// The value is of m_edge_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_edge_user</span><span class="p">;</span>

  <span class="c1">// index of edge in ON_Brep.m_E[] array</span>
  <span class="kt">int</span> <span class="n">m_edge_index</span><span class="p">;</span>


  <span class="c1">// virtual ON_Curve::IsClosed override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsClosed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Construction</span>
  <span class="c1">//</span>
  <span class="c1">// In general, you should not directly create ON_BrepEdge classes.</span>
  <span class="c1">// Use ON_Brep::NewVertex instead.</span>
  <span class="n">ON_BrepEdge</span><span class="p">();</span>
  <span class="n">ON_BrepEdge</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// edge index</span>
  <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// virtual ON_Object function</span>
  <span class="c1">// The ON_BrepEdge override returns ON::curve_object.</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep this edge belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">Brep</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    eti - [in] index into the edge&#39;s m_ti[] array.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The trim brep.m_T[edge.m_ti[eti]];</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">*</span> <span class="nf">Trim</span><span class="p">(</span> <span class="kt">int</span> <span class="n">eti</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of trims attached to this edge.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">TrimCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    evi - [in] 0 or 1</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep vertex at specified end of the edge.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepVertex</span><span class="o">*</span> <span class="nf">Vertex</span><span class="p">(</span><span class="kt">int</span> <span class="n">evi</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::SizeOf override</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::DataCRC override</span>
  <span class="n">ON__UINT32</span> <span class="nf">DataCRC</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">current_remainder</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::Dump() override</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// for debugging</span>

  <span class="c1">// virtual ON_Object::Write() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::Read() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::ComponentIndex() override</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Curve::Reverse override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Reverse</span><span class="p">();</span>

  <span class="c1">// virtual ON_Curve::SetStartPoint override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">SetStartPoint</span><span class="p">(</span>
          <span class="n">ON_3dPoint</span> <span class="n">start_point</span>
          <span class="p">);</span>

  <span class="c1">// virtual ON_Curve::SetEndPoint override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">SetEndPoint</span><span class="p">(</span>
          <span class="n">ON_3dPoint</span> <span class="n">end_point</span>
          <span class="p">);</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    brep.m_C3[] index of the 3d curve geometry used by this edge</span>
<span class="cm">    or -1.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">EdgeCurveIndexOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    3d curve geometry used by this edge or NULL.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">*</span> <span class="nf">EdgeCurveOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool that replaces the 3d curve geometry</span>
<span class="cm">    of an edge</span>
<span class="cm">  Parameters;</span>
<span class="cm">    c3i - [in] brep 3d curve index of new curve</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Example:</span>

<span class="cm">            ON_Curve* pCurve = ...;</span>
<span class="cm">            int c3i = brep.AddEdgeCurve(pCurve);</span>
<span class="cm">            edge.ChangeEdgeCurve(c3i);</span>

<span class="cm">  Remarks:</span>
<span class="cm">    Sets m_c3i, calls SetProxyCurve, cleans runtime caches.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ChangeEdgeCurve</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">c3i</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    When an edge is modified, the m_pline[].e values need</span>
<span class="cm">    to be set to ON_UNSET_VALUE by calling UnsetPlineEdgeParameters().</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">UnsetPlineEdgeParameters</span><span class="p">();</span>

  <span class="c1">// index of 3d curve in m_C3[] array</span>
  <span class="c1">// (edge.m_curve also points to m_C3[m_c3i])</span>
  <span class="kt">int</span> <span class="n">m_c3i</span><span class="p">;</span>

  <span class="c1">// indices of starting/ending vertex</span>
  <span class="c1">//</span>
  <span class="c1">// For closed edges, m_vi[0] = m_vi[1] and m_edge_index</span>
  <span class="c1">// appears twice in the m_V[m_vi[0]].m_ei[] array.</span>
  <span class="c1">// The first occurance of m_edge_index in m_V[m_vi[0]].m_ei[]</span>
  <span class="c1">// is for the closed edge starting the vertex.  The second</span>
  <span class="c1">// occurance of m_edge_index in m_V[m_vi[0]].m_ei[]</span>
  <span class="c1">// is for the closed edge edge ending at the vertex.</span>
  <span class="c1">// C.f. ON_Brep::Next/PrevEdge().</span>
  <span class="kt">int</span> <span class="n">m_vi</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="c1">// indices of Trims that use this edge</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_ti</span><span class="p">;</span>

  <span class="c1">// accuracy of edge curve (&gt;=0.0 or ON_UNSET_VALUE)</span>
  <span class="c1">//</span>
  <span class="c1">// A value of ON_UNSET_VALUE indicates that the</span>
  <span class="c1">// tolerance should be computed.</span>
  <span class="c1">//</span>
  <span class="c1">// The maximum distance from the edge&#39;s 3d curve</span>
  <span class="c1">// to any surface of a face that has this edge as</span>
  <span class="c1">// a portion of its boundary must be &lt;= this</span>
  <span class="c1">// tolerance.</span>
  <span class="kt">double</span> <span class="n">m_tolerance</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Brep</span><span class="p">;</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">m_brep</span><span class="p">;</span> <span class="c1">// so isolated edge class edge can get at it&#39;s 3d curve</span>
  <span class="n">ON_BrepEdge</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_BrepTrimPoint</span>
<span class="p">{</span>
  <span class="n">ON_2dPoint</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 2d surface parameter space point</span>
  <span class="kt">double</span> <span class="n">t</span><span class="p">;</span>     <span class="c1">// corresponding trim curve parameter</span>
  <span class="kt">double</span> <span class="n">e</span><span class="p">;</span>     <span class="c1">// corresponding edge curve parameter (ON_UNSET_VALUE if unknown)</span>
<span class="p">};</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_BrepTrimPoint</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Brep trim information is stored in ON_BrepTrim classes.</span>
<span class="cm">  ON_Brep.m_T[] is an array of all the trim in the brep.</span>

<span class="cm">  An ON_BrepTrim is derived from ON_CurveProxy so the the</span>
<span class="cm">  trim can supply easy to use evaluation tools via</span>
<span class="cm">  the ON_Curve virtual member functions.</span>

<span class="cm">  Note well that the domains and orientations of the curve</span>
<span class="cm">  m_C2[trim.m_c2i] and the trin as a curve may not</span>
<span class="cm">  agree.</span>
<span class="cm">*/</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepTrim</span> <span class="p">:</span> <span class="k">public</span>  <span class="n">ON_CurveProxy</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_BrepTrim</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">DestroyRuntimeCache</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDelete</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Object::SizeOf override</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_trim_user.</span>
  <span class="c1">// The value is of m_trim_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_trim_user</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">m_trim_index</span><span class="p">;</span>  <span class="c1">// index of trim in ON_Brep.m_T[] array</span>

  <span class="c1">// types of trim - access through m_type member.  Also see m_iso and ON_Surface::ISO</span>
  <span class="k">enum</span> <span class="n">TYPE</span>
  <span class="p">{</span>
    <span class="n">unknown</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1">// trim is connected to an edge, is part of an outer,</span>
                        <span class="c1">// inner or slit loop, and is the only trim connected</span>
                        <span class="c1">// to the edge.</span>
    <span class="n">mated</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>       <span class="c1">// trim is connected to an edge, is part of an outer,</span>
                        <span class="c1">// inner or slit loop, no other trim from the same</span>
                        <span class="c1">// loop is connected to the edge, and at least one</span>
                        <span class="c1">// trim from a different loop is connected to the edge.</span>
    <span class="n">seam</span>     <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>       <span class="c1">// trim is connected to an edge, is part of an outer,</span>
                        <span class="c1">// inner or slit loop, and one other trim from the</span>
                        <span class="c1">// same loop is connected to the edge.</span>
                        <span class="c1">// (There can be other mated trims that are also</span>
                        <span class="c1">// connected to the edge.  For example, the non-mainfold</span>
                        <span class="c1">// edge that results when a surface edge lies in the</span>
                        <span class="c1">// middle of another surface.)  Non-mainfold &quot;cuts&quot;</span>
                        <span class="c1">// have seam trims too.</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>       <span class="c1">// trim is part of an outer loop, the trim&#39;s 2d curve</span>
                        <span class="c1">// runs along the singular side of a surface, and the</span>
                        <span class="c1">// trim is NOT connected to an edge. (There is no 3d</span>
                        <span class="c1">// edge because the surface side is singular.)</span>
    <span class="n">crvonsrf</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>       <span class="c1">// trim is connected to an edge, is the only trim in</span>
                        <span class="c1">// a crfonsrf loop, and is the only trim connected to</span>
                        <span class="c1">// the edge.</span>
    <span class="n">ptonsrf</span>  <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>       <span class="c1">// trim is a point on a surface, trim.m_pbox is records</span>
                        <span class="c1">// surface parameters, and is the only trim</span>
                        <span class="c1">// in a ptonsrf loop.  This trim is not connected</span>
                        <span class="c1">// to an edge and has no 2d curve.</span>
    <span class="n">slit</span>     <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>       <span class="c1">// 17 Nov 2006 - reserved for future use</span>
                        <span class="c1">//   currently an invalid value</span>
    <span class="n">trim_type_count</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="n">force_32_bit_trim_type</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
  <span class="p">};</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Construction</span>
  <span class="c1">//</span>
  <span class="c1">// In general, you should not directly create ON_BrepTrim classes.</span>
  <span class="c1">// Use ON_Brep::NewTrim instead.</span>
  <span class="n">ON_BrepTrim</span><span class="p">();</span>
  <span class="n">ON_BrepTrim</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// trim index</span>
  <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep that this trim belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">Brep</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep loop that this trim belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">*</span> <span class="nf">Loop</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep face this trim belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">Face</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep edge this trim uses or belongs to.  This will</span>
<span class="cm">    be NULL for singular trims.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepEdge</span><span class="o">*</span> <span class="nf">Edge</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    tvi - [in] 0 or 1</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep vertex at specified end of the trim.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepVertex</span><span class="o">*</span> <span class="nf">Vertex</span><span class="p">(</span><span class="kt">int</span> <span class="n">tvi</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// ON_Object overrides</span>
  <span class="c1">//</span>
  <span class="c1">// (Trims are purely topologicial - geometry queries should be</span>
  <span class="c1">//  directed at the trim&#39;s 2d curve or the trim&#39;s edge&#39;s 3d curve.)</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// for debugging</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::ComponentIndex() override</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Curve::Reverse override</span>
  <span class="c1">// Reverses curve - caller must make sure trim&#39;s m_bRev3d</span>
  <span class="c1">// flags are properly updated.  Use</span>
  <span class="c1">// ON_Brep::FlipTrim to reverse and trim and update all</span>
  <span class="c1">// m_bRev3d informtion.</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Reverse</span><span class="p">();</span>

  <span class="c1">// virtual ON_Curve::SetStartPoint override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">SetStartPoint</span><span class="p">(</span>
          <span class="n">ON_3dPoint</span> <span class="n">start_point</span>
          <span class="p">);</span>

  <span class="c1">// virtual ON_Curve::SetEndPoint override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">SetEndPoint</span><span class="p">(</span>
          <span class="n">ON_3dPoint</span> <span class="n">end_point</span>
          <span class="p">);</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Interface</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool that replaces the 2d curve geometry</span>
<span class="cm">    of a trim</span>
<span class="cm">  Parameters;</span>
<span class="cm">    c2i - [in] brep 2d curve index of new curve</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Example:</span>

<span class="cm">            ON_Curve* pCurve = ...;</span>
<span class="cm">            int c2i = brep.AddTrimCurve(pCurve);</span>
<span class="cm">            trim.ChangeTrimCurve(c2i);</span>

<span class="cm">  Remarks:</span>
<span class="cm">    Sets m_c2i, calls SetProxyCurve, cleans runtime caches,</span>
<span class="cm">    and updates m_pbox.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ChangeTrimCurve</span><span class="p">(</span> <span class="kt">int</span> <span class="n">c2i</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Destroy parameter space information.</span>
<span class="cm">    Currently, this involves destroying m_pline</span>
<span class="cm">    and m_pbox. Parameter space information should</span>
<span class="cm">    be destroyed when the location of a trim</span>
<span class="cm">    curve is changed.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DestroyPspaceInformation</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function.</span>
<span class="cm">    Removes a trim from an edge.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bRemoveFromStartVertex - [in] if true, the trim</span>
<span class="cm">      is removed from its start vertex by setting</span>
<span class="cm">      m_vi[0] to -1.</span>
<span class="cm">    bRemoveFromEndVertex - [in] if true, the trim</span>
<span class="cm">      is removed from its start vertex by setting</span>
<span class="cm">      m_vi[1] to -1.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If the trim is attached to an edge (m_ei&gt;=0), then</span>
<span class="cm">    the trim is removed from the edge and the edge&#39;s</span>
<span class="cm">    m_ti[] list.  The trim&#39;s m_bRev3d and tolerance values</span>
<span class="cm">    are not changed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">RemoveFromEdge</span><span class="p">(</span>
        <span class="kt">bool</span> <span class="n">bRemoveFromStartVertex</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">bRemoveFromEndVertex</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function.</span>
<span class="cm">    Attaches a trim to an edge.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge_index - [in] index of an edge.</span>
<span class="cm">    bRev3d - [in] value for trim&#39;s m_bRev3d field.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If the trim is attached to an edge (m_ei&gt;=0), then</span>
<span class="cm">    the trim is removed from the edge and the edge&#39;s</span>
<span class="cm">    m_ti[] list.  The trim&#39;s tolerance values are not</span>
<span class="cm">    changed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">AttachToEdge</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">bRev3d</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    2d curve geometry used by this trim or NULL</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">*</span> <span class="nf">TrimCurveOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    3d curve geometry used by this trim or NULL.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">*</span> <span class="nf">EdgeCurveOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    3d surface geometry used by this trim or NULL</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_Surface</span><span class="o">*</span> <span class="nf">SurfaceOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    brep.m_C2[] 2d curve index of the 2d curve geometry used by</span>
<span class="cm">    this trim or -1.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">TrimCurveIndexOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    brep.m_C3[] 3d curve index of the 3d curve geometry used by</span>
<span class="cm">    this trim or -1.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">EdgeCurveIndexOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    brep.m_S[] surface index of the 3d surface geometry used by</span>
<span class="cm">    this trim or -1.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SurfaceIndexOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    brep.m_F[] face index of the face used by this trim or -1.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">FaceIndexOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the trim satisfies these four criteria.</span>
<span class="cm">      1) is part of a loop</span>
<span class="cm">      2) is connected to a 3d edge</span>
<span class="cm">      3) one other trim from the same loop is connected to the edge</span>
<span class="cm">      4) The 2d trim curve for the other trim is the reverse</span>
<span class="cm">         of the 2d trim curve for this trim.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    In order for IsSlit() to work correctly, the m_type and m_iso</span>
<span class="cm">    fields must be set correctly.  In V4 SR1, this function will</span>
<span class="cm">    be removed and ON_BrepTrim::slit will be added as a type.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsSlit</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the trim satisfies these four criteria.</span>
<span class="cm">      1) is part of a loop</span>
<span class="cm">      2) is connected to a 3d edge</span>
<span class="cm">      3) one other trim from the same loop is connected to the edge</span>
<span class="cm">      4) the 2d trim curve for this trim lies along the side of</span>
<span class="cm">         the face&#39;s parameter space and the 2d curve for the other</span>
<span class="cm">         trim lies on the opposite side of the face&#39;s parameter</span>
<span class="cm">         space.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    In order for IsSeam() to work correctly, the m_type and m_iso</span>
<span class="cm">    fields must be set correctly.  In V4 SR1, this function will</span>
<span class="cm">    be removed and ON_BrepTrim::slit will be added as a type.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsSeam</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool that tranforms all the parameter space (2d)</span>
<span class="cm">    trimming curves in this loop.  Only 2d curve geometry is</span>
<span class="cm">    changed.  The caller is responsible for reversing loops,</span>
<span class="cm">    toggle m_bRev, flags, etc.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    xform - [in] Transformation applied to 2d curve geometry.</span>
<span class="cm">  Returns</span>
<span class="cm">    True if successful.  If false is returned, the brep</span>
<span class="cm">    may be invalid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TransformTrim</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="c1">// index of the 2d parameter space trimming curve</span>
  <span class="kt">int</span> <span class="n">m_c2i</span><span class="p">;</span>

  <span class="c1">// index of 3d edge (-1 if ON_BrepTrim is singular)</span>
  <span class="kt">int</span> <span class="n">m_ei</span><span class="p">;</span>

  <span class="c1">// Indices of start/end vertices.  Trims along singular</span>
  <span class="c1">// sides and trims that correspond to closed 3d edges</span>
  <span class="c1">// have m_vi[0] = m_vi[1].  Note that singular trims</span>
  <span class="c1">// and trims on the closed edge of a closed surface can</span>
  <span class="c1">// have an open 2d trimming curve and still have</span>
  <span class="c1">// m_vi[0] = m_vi[1].</span>
  <span class="kt">int</span> <span class="n">m_vi</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="c1">// true if the 2d trim and 3d edge have opposite orientations.</span>
  <span class="kt">bool</span>   <span class="n">m_bRev3d</span><span class="p">;</span>

  <span class="n">TYPE</span>   <span class="n">m_type</span><span class="p">;</span>
  <span class="n">ON_Surface</span><span class="o">::</span><span class="n">ISO</span>  <span class="n">m_iso</span><span class="p">;</span>

  <span class="c1">// index of loop that uses this trim</span>
  <span class="kt">int</span>    <span class="n">m_li</span><span class="p">;</span>

  <span class="c1">// The values in m_tolerance[] record the accuracy of</span>
  <span class="c1">// the parameter space trimming curves.</span>
  <span class="c1">//</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   m_tolerance[0] = accuracy of parameter space curve</span>
  <span class="c1">//   in first ( &quot;u&quot; ) parameter</span>
  <span class="c1">//</span>
  <span class="c1">//   m_tolerance[1] = accuracy of parameter space curve</span>
  <span class="c1">//   in second ( &quot;v&quot; ) parameter</span>
  <span class="c1">//</span>
  <span class="c1">//   A value of ON_UNSET_VALUE indicates that the</span>
  <span class="c1">//   tolerance should be computed. If the value &gt;= 0.0,</span>
  <span class="c1">//   then the tolerance is set.  If the value is</span>
  <span class="c1">//   ON_UNSET_VALUE, then the tolrance needs to be</span>
  <span class="c1">//   computed.</span>
  <span class="c1">//</span>
  <span class="c1">//   If the trim is not singular, then the trim must</span>
  <span class="c1">//   have an edge.  If P is a 3d point on the edge&#39;s</span>
  <span class="c1">//   curve and surface(u,v) = Q is the point on the</span>
  <span class="c1">//   surface that is closest to P, then there must</span>
  <span class="c1">//   be a parameter t in the interval [m_t[0], m_t[1]]</span>
  <span class="c1">//   such that</span>
  <span class="c1">//</span>
  <span class="c1">//   |u - curve2d(t)[0]| &lt;= m_tolerance[0]</span>
  <span class="c1">//</span>
  <span class="c1">//   and</span>
  <span class="c1">//</span>
  <span class="c1">//   |v - curve2d(t)[1]| &lt;= m_tolerance[1]</span>
  <span class="c1">//</span>
  <span class="c1">//   If P is the 3d point for the vertex brep.m_V[m_vi[k]]</span>
  <span class="c1">//   and (uk,vk) is the corresponding end of the trim&#39;s</span>
  <span class="c1">//   parameter space curve, then there must be a surface</span>
  <span class="c1">//   parameter (u,v) such that:</span>
  <span class="c1">//</span>
  <span class="c1">//   *  the distance from the 3d point surface(u,v) to P</span>
  <span class="c1">//      is &lt;= brep.m_V[m_vi[k]].m_tolerance,</span>
  <span class="c1">//   *  |u-uk| &lt;= m_tolerance[0].</span>
  <span class="c1">//   *  |v-vk| &lt;= m_tolerance[1].</span>
  <span class="kt">double</span> <span class="n">m_tolerance</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="c1">// Runtime polyline approximation of trimming curve.</span>
  <span class="c1">// This information is not saved in 3DM archives.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_BrepTrimPoint</span><span class="o">&gt;</span> <span class="n">m_pline</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    When an edge is modified, the m_pline[].e values need</span>
<span class="cm">    to be set to ON_UNSET_VALUE by calling UnsetPlineEdgeParameters().</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">UnsetPlineEdgeParameters</span><span class="p">();</span>

  <span class="c1">// Runtime parameter space trimming curve bounding box.</span>
  <span class="c1">// This information is not saved in 3DM archives.</span>
  <span class="n">ON_BoundingBox</span> <span class="n">m_pbox</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="c1">// values stored in legacy file formats - ignore</span>

  <span class="kt">void</span> <span class="n">m__legacy_flags_Set</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>   <span class="c1">// used internally - ignore</span>
  <span class="kt">bool</span> <span class="nf">m__legacy_flags_Get</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// used internally - ignore</span>
  <span class="kt">double</span> <span class="n">m__legacy_2d_tol</span><span class="p">;</span> <span class="c1">// used internally - ignore</span>
  <span class="kt">double</span> <span class="n">m__legacy_3d_tol</span><span class="p">;</span> <span class="c1">// used internally - ignore</span>
  <span class="kt">int</span>    <span class="n">m__legacy_flags</span><span class="p">;</span>  <span class="c1">// used internally - ignore</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Brep</span><span class="p">;</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">m_brep</span><span class="p">;</span> <span class="c1">// so isolated edge class edge can get at it&#39;s 3d curve</span>
  <span class="n">ON_BrepTrim</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepLoop</span> <span class="p">:</span> <span class="k">public</span>  <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_BrepLoop</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">DestroyRuntimeCache</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDelete</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry overrides</span>
  <span class="c1">// A loop is derived from ON_Geometry so that is can</span>
  <span class="c1">// be passed around to things that expect ON_Geometry</span>
  <span class="c1">// pointers.  It is not a very useful stand-alone object.</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    virtual ON_Geometry::Dimension() override.</span>
<span class="cm">  Returns:</span>
<span class="cm">    2</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::GetBBox() override.</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmin</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmax</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::Transform() override.</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span>
         <span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   Brep that the loop belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">Brep</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep face this loop belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">Face</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    lti - [in] index into the loop&#39;s m_ti[] array.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The trim brep.m_T[loop.m_ti[lti]];</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">*</span> <span class="nf">Trim</span><span class="p">(</span> <span class="kt">int</span> <span class="n">lti</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of trims in this loop.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">TrimCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_loop_user.</span>
  <span class="c1">// The value is of m_loop_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_loop_user</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">m_loop_index</span><span class="p">;</span>  <span class="c1">// index of loop in ON_Brep.m_L[] array</span>

  <span class="k">enum</span> <span class="n">TYPE</span> <span class="p">{</span>
    <span class="n">unknown</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">outer</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">// 2d loop curves form a simple closed curve with a counterclockwise orientation</span>
    <span class="n">inner</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1">// 2d loop curves form a simple closed curve with a clockwise orientation</span>
    <span class="n">slit</span>     <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1">// always closed - used internally during splitting operations</span>
    <span class="n">crvonsrf</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>  <span class="c1">// &quot;loop&quot; is a curveonsrf made from a single</span>
                   <span class="c1">// (open or closed) trim that is has type ON_BrepTrim::crvonsrf.</span>
    <span class="n">ptonsrf</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>   <span class="c1">// &quot;loop&quot; is a ptonsrf made from a single</span>
                   <span class="c1">// trim that is has type ON_BrepTrim::ptonsrf.</span>
    <span class="n">type_count</span> <span class="o">=</span> <span class="mi">6</span>
  <span class="p">};</span>

  <span class="n">ON_BrepLoop</span><span class="p">();</span>
  <span class="n">ON_BrepLoop</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// loop index</span>
  <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// ON_Object overrides</span>
  <span class="c1">//</span>
  <span class="c1">// (Loops and trims are purely topologicial - geometry queries should be</span>
  <span class="c1">// directed at the trim&#39;s 2d curve or the trim&#39;s edge&#39;s 3d curve.)</span>

  <span class="c1">// virtual ON_Object::SizeOf override</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// for debugging</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::ComponentIndex() override</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Interface</span>

  <span class="c1">//////////</span>
  <span class="c1">// Returns the index i such that loop.m_ti[i] = trim.m_trim_index.</span>
  <span class="c1">// Returns -1 if the trim is not in this loop</span>
  <span class="kt">int</span> <span class="nf">IndexOfTrim</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    brep.m_S[] surface index of the 3d surface geometry used by</span>
<span class="cm">    this loop or -1.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SurfaceIndexOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to the surface geometry used by the loop.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_Surface</span><span class="o">*</span> <span class="nf">SurfaceOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool that tranforms all the parameter space (2d)</span>
<span class="cm">    trimming curves in this loop.  Only 2d curve geometry is</span>
<span class="cm">    changed.  The caller is responsible for reversing loops,</span>
<span class="cm">    toggle m_bRev, flags, etc.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    xform - [in] Transformation applied to 2d curve geometry.</span>
<span class="cm">  Returns</span>
<span class="cm">    True if successful.  If false is returned, the brep</span>
<span class="cm">    may be invalid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TransformTrim</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_ti</span><span class="p">;</span>   <span class="c1">// trim indices</span>
  <span class="n">TYPE</span>         <span class="n">m_type</span><span class="p">;</span>
  <span class="kt">int</span>          <span class="n">m_fi</span><span class="p">;</span>   <span class="c1">// index of face that uses this loop</span>

  <span class="c1">//////////</span>
  <span class="c1">// parameter space trimming loop bounding box</span>
  <span class="c1">// runtime information - not saved</span>
  <span class="n">ON_BoundingBox</span> <span class="n">m_pbox</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Brep</span><span class="p">;</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">m_brep</span><span class="p">;</span>
  <span class="n">ON_BrepLoop</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// no implementation</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepFace</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_SurfaceProxy</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_BrepFace</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">DestroyRuntimeCache</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDelete</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_face_user.</span>
  <span class="c1">// The value is of m_face_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_face_user</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">m_face_index</span><span class="p">;</span>  <span class="c1">// index of face in ON_Brep.m_F[] array</span>

  <span class="n">ON_BrepFace</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepFace</span><span class="p">();</span>
  <span class="n">ON_BrepFace</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   Brep that the face belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">Brep</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fli - [in] index into the face&#39;s m_li[] array.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The loop brep.m_L[face.m_li[fli]];</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">*</span> <span class="nf">Loop</span><span class="p">(</span> <span class="kt">int</span> <span class="n">fli</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of loops in this face.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">LoopCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Outer boundary loop for this face.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">*</span> <span class="nf">OuterLoop</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dir</span>
<span class="cm">       1: side with underlying surface normal</span>
<span class="cm">         pointing into the topology region</span>
<span class="cm">      -1: side with underlying surface normal</span>
<span class="cm">          pointing out of the topology region</span>
<span class="cm">  Returns:</span>
<span class="cm">    Brep region topology face side.  If the region</span>
<span class="cm">    topology has not be created by calling</span>
<span class="cm">    ON_Brep::RegionToplogy(), then NULL is returned.</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_BrepFaceSide</span><span class="o">*</span> <span class="nf">FaceSide</span><span class="p">(</span><span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// ON_Object overrides</span>
  <span class="c1">//</span>
  <span class="c1">// (Faces are purely topologicial - geometry queries should be</span>
  <span class="c1">//  directed at the face&#39;s 3d surface.)</span>

  <span class="c1">// virtual ON_Object::SizeOf override</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::DataCRC override</span>
  <span class="n">ON__UINT32</span> <span class="nf">DataCRC</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">current_remainder</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// for debugging</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::ComponentIndex() override</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::ClearBoundingBox() override</span>
  <span class="kt">void</span> <span class="nf">ClearBoundingBox</span><span class="p">();</span>

  <span class="c1">// virtual ON_Geometry::GetBBox() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span> <span class="c1">// returns true if successful</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// minimum</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// maximum</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>  <span class="c1">// true means grow box</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    This is an override of the virtual ON_Surface::Reverse</span>
<span class="cm">    function.  It toggles the face&#39;s m_bRev flag so the abstract</span>
<span class="cm">    orientation of the face does not change.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dir - [in] 0 = reverse &quot;s&quot; parameter, 1 = reverse &quot;t&quot; parameter</span>
<span class="cm">         The domain changes from [a,b] to [-a,-b]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The range of the face&#39;s trimming curves and the orientation direction</span>
<span class="cm">    of then loops are changed so that the resulting face is still valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Reverse</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">dir</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    This is an override of the virtual ON_Surface::Transpose</span>
<span class="cm">    function.  It toggles the face&#39;s m_bRev flag so the abstract</span>
<span class="cm">    orientation of the face does not change.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The range of the face&#39;s trimming curves and the orientation direction</span>
<span class="cm">    of then loops are changed so that the resulting face is still valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transpose</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    This is an override of the virtual ON_Surface::SetDomain</span>
<span class="cm">    function.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dir - [in] 0 = set &quot;u&quot; domain, 1 = set &quot;v&quot; domain.</span>
<span class="cm">    t0 - [in]</span>
<span class="cm">    t1 - [in] t0 &lt; t1  The new domain is the interval (t0,t1)</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">SetDomain</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">t0</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">t1</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  //////////</span>
<span class="cm">  // Change the domain of a face</span>
<span class="cm">  // This changes the parameterization of the face&#39;s surface and transforms</span>
<span class="cm">  // the &quot;u&quot; and &quot;v&quot; coordinates of all the face&#39;s parameter space trimming</span>
<span class="cm">  // curves.  The locus of the face is not changed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetDomain</span><span class="p">(</span>
         <span class="n">ON_Interval</span> <span class="n">udom</span><span class="p">,</span>
         <span class="n">ON_Interval</span> <span class="n">vdom</span>
         <span class="p">);</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Rendering Interface</span>
  <span class="c1">//int MaterialIndex() const; // if -1, use parent&#39;s material definition</span>
  <span class="c1">//void SetMaterialIndex(int);</span>

  <span class="c1">// If true is returne, then ~ON_BrepFace will delete mesh.</span>
  <span class="kt">bool</span> <span class="nf">SetMesh</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">mesh_type</span><span class="p">,</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">mesh</span> <span class="p">);</span>

  <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="nf">Mesh</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">mesh_type</span> <span class="n">mesh_type</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Destroy meshes used to render and analyze surface and polysrf</span>
<span class="cm">    objects.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh_type - [in] type of mesh to destroy</span>
<span class="cm">    bDeleteMesh - [in] if true, cached mesh is deleted.</span>
<span class="cm">      If false, pointer to cached mesh is just set to NULL.</span>
<span class="cm">  See Also:</span>
<span class="cm">    CRhinoObject::GetMeshes</span>
<span class="cm">    CRhinoObject::MeshCount</span>
<span class="cm">    CRhinoObject::IsMeshable</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DestroyMesh</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">mesh_type</span> <span class="n">mesh_type</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bDeleteMesh</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// &quot;Expert&quot; Interface</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool that tranforms all the parameter space (2d)</span>
<span class="cm">    trimming curves on this face.  Only 2d curve geometry is</span>
<span class="cm">    changed.  The caller is responsible for reversing loops,</span>
<span class="cm">    toggle m_bRev, flags, etc.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    xform - [in] Transformation applied to 2d curve geometry.</span>
<span class="cm">  Returns</span>
<span class="cm">    True if successful.  If false is returned, the brep</span>
<span class="cm">    may be invalid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TransformTrim</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool that replaces the 3d surface geometry</span>
<span class="cm">    use by the face.</span>
<span class="cm">  Parameters;</span>
<span class="cm">    si - [in] brep surface index of new surface</span>
<span class="cm">    bTransformTrimCurves - [in]</span>
<span class="cm">      If unsure, then pass true.</span>
<span class="cm">      If the surface&#39;s domain has changed and you are certain</span>
<span class="cm">      its parameterization still jibes with the trim curve</span>
<span class="cm">      locations, then pass false.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Example:</span>

<span class="cm">            ON_Surface* pSurface = ...;</span>
<span class="cm">            int si = brep.AddSurface(pSurface);</span>
<span class="cm">            face.ChangeSurface(si);</span>

<span class="cm">  Remarks:</span>
<span class="cm">    If the face had a surface and new surface has a different</span>
<span class="cm">    shape, then you probably want to call something like</span>
<span class="cm">    ON_Brep::RebuildEdges() to move the 3d edge curves so they</span>
<span class="cm">    will lie on the new surface. This doesn&#39;t delete the old</span>
<span class="cm">    surface; call ON_Brep::CullUnusedSurfaces() or ON_Brep::Compact</span>
<span class="cm">    to remove unused surfaces.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::RebuildEdges</span>
<span class="cm">    ON_Brep::CullUnusedSurfaces</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ChangeSurface</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">si</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ChangeSurface</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">si</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bTransformTrimCurves</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    brep.m_S[] surface index of the 3d surface geometry used by</span>
<span class="cm">    this face or -1.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SurfaceIndexOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to the surface geometry used by the face.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_Surface</span><span class="o">*</span> <span class="nf">SurfaceOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_li</span><span class="p">;</span> <span class="c1">// loop indices (outer loop is m_li[0])</span>
  <span class="kt">int</span> <span class="n">m_si</span><span class="p">;</span>            <span class="c1">// index of surface in b-rep m_S[] array</span>
  <span class="kt">bool</span> <span class="n">m_bRev</span><span class="p">;</span>         <span class="c1">// true if face orientation is opposite</span>
                       <span class="c1">//      of natural surface orientation</span>

  <span class="c1">// m_face_material_channel provides a way to have individual</span>
  <span class="c1">// brep faces use a rendering material that is different</span>
  <span class="c1">// from the rendering material used by the parent brep.</span>
  <span class="c1">// If m_face_material_channel is zero</span>
  <span class="c1">// channel and m_face_material_channel.m_j is the back face</span>
  <span class="c1">// materal. The default is (0,0) which indicates the face</span>
  <span class="c1">// should use the parent brep&#39;s material.</span>
  <span class="c1">// If &quot;mat&quot; is the brep&#39;s rendering material and</span>
  <span class="c1">// 0 &lt; m_material_channel.m_i &lt; mat.m_material_channel.Count(),</span>
  <span class="c1">// then this face should use the material with id</span>
  <span class="c1">// mat.m_material_channel[face.m_material_channel.m_i-1].m_id.</span>
  <span class="c1">// If m_material_channel.m_i or the id is invalid in any way,</span>
  <span class="c1">// then the default should be used.</span>
  <span class="kt">int</span> <span class="n">m_face_material_channel</span><span class="p">;</span>

  <span class="c1">// Persistent id for this face.  Default is ON_nil_uuid.</span>
  <span class="n">ON_UUID</span> <span class="n">m_face_uuid</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">ON_BoundingBox</span> <span class="n">m_bbox</span><span class="p">;</span>      <span class="c1">// 3d bounding box</span>
  <span class="n">ON_Interval</span>    <span class="n">m_domain</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// rectangular bounds of 2d curves</span>
  <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">m_render_mesh</span><span class="p">;</span>
  <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">m_analysis_mesh</span><span class="p">;</span>
  <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">m_preview_mesh</span><span class="p">;</span>
  <span class="c1">//int m_material_index; // if 0 (default), ON_Brep&#39;s object attributes</span>
  <span class="c1">//                      // determine material.</span>
<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Brep</span><span class="p">;</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">m_brep</span><span class="p">;</span>
  <span class="n">ON_BrepFace</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepFaceSide</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Object</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_BrepFaceSide</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BOOL32</span> <span class="n">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_faceside_user.</span>
  <span class="c1">// The value is of m_faceside_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_faceside_user</span><span class="p">;</span>

  <span class="c1">// index of face side in ON_BrepRegionTopology.m_FS[] array</span>
  <span class="kt">int</span> <span class="n">m_faceside_index</span><span class="p">;</span>

  <span class="n">ON_BrepFaceSide</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepFaceSide</span><span class="p">();</span>
  <span class="n">ON_BrepFaceSide</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepFaceSide</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   Brep this face side belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">Brep</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Region topology this face side belongs to.</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_BrepRegionTopology</span><span class="o">*</span> <span class="nf">RegionTopology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   Region the face side belongs to.</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_BrepRegion</span><span class="o">*</span> <span class="nf">Region</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   Face this side belongs to.</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_BrepFace</span><span class="o">*</span> <span class="nf">Face</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   +1: underlying geometric surface normal points</span>
<span class="cm">       into region.</span>
<span class="cm">   -1: underlying geometric surface normal points</span>
<span class="cm">       out of region.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SurfaceNormalDirection</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">m_ri</span><span class="p">;</span> <span class="c1">// region index</span>
            <span class="c1">// m_ri = -1 indicates this faceside overlaps</span>
            <span class="c1">// another faceside. Generally this is a flaw</span>
            <span class="c1">// in an ON_Brep.</span>
  <span class="kt">int</span> <span class="n">m_fi</span><span class="p">;</span> <span class="c1">// face index</span>
  <span class="kt">int</span> <span class="n">m_srf_dir</span><span class="p">;</span> <span class="c1">//  1 ON_BrepFace&#39;s surface normal points into region</span>
                 <span class="c1">// -1 ON_BrepFace&#39;s surface normal points out of region</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Brep</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_BrepRegionTopology</span><span class="p">;</span>
  <span class="n">ON_BrepRegionTopology</span><span class="o">*</span> <span class="n">m_rtop</span><span class="p">;</span>
  <span class="n">ON_BrepFaceSide</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepFaceSide</span><span class="o">&amp;</span> <span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepRegion</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Object</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_BrepRegion</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BOOL32</span> <span class="n">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_region_user.</span>
  <span class="c1">// The value is of m_region_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_region_user</span><span class="p">;</span>

  <span class="c1">// index of region in ON_BrepRegionTopology.m_R[] array</span>
  <span class="kt">int</span> <span class="n">m_region_index</span><span class="p">;</span>

  <span class="n">ON_BrepRegion</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepRegion</span><span class="p">();</span>
  <span class="n">ON_BrepRegion</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepRegion</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   Brep this region belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">Brep</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Region topology this region belongs to.</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_BrepRegionTopology</span><span class="o">*</span> <span class="nf">RegionTopology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameter:</span>
<span class="cm">    rfsi - [in] index into the region&#39;s m_fsi[] array.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The face side in rtop.m_FS[m_fsi[rsi]], where</span>
<span class="cm">    rtop is the ON_BrepRegionTopology class this</span>
<span class="cm">    region belongs to.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFaceSide</span><span class="o">*</span> <span class="nf">FaceSide</span><span class="p">(</span><span class="kt">int</span> <span class="n">rfsi</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the region is finite.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsFinite</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">   Region bounding box.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">BoundingBox</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_fsi</span><span class="p">;</span> <span class="c1">// indices of face sides</span>
  <span class="kt">int</span> <span class="n">m_type</span><span class="p">;</span> <span class="c1">// 0 = infinte, 1 = bounded</span>
  <span class="n">ON_BoundingBox</span> <span class="n">m_bbox</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the boundary of a region as a brep object.</span>
<span class="cm">    If the region is finite, the boundary will be a closed</span>
<span class="cm">    manifold brep.  The boundary may have more than one</span>
<span class="cm">    connected component.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    brep - [in] if not NULL, the brep form is put into</span>
<span class="cm">                this brep.</span>
<span class="cm">  Returns: the region boundary as a brep or NULL if the</span>
<span class="cm">           calculation fails.</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">RegionBoundaryBrep</span><span class="p">(</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">brep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Brep</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_BrepRegionTopology</span><span class="p">;</span>
  <span class="n">ON_BrepRegionTopology</span><span class="o">*</span> <span class="n">m_rtop</span><span class="p">;</span>
  <span class="n">ON_BrepRegion</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepRegion</span><span class="o">&amp;</span> <span class="p">);</span>
<span class="p">};</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_BrepVertex</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepVertex</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_BrepEdge</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepEdge</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_BrepTrim</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepTrim</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_BrepLoop</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepLoop</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_BrepFace</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepFace</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepFaceSide</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepRegion</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepVertexArray</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepVertex</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepVertexArray</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepVertexArray</span><span class="p">();</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepEdgeArray</span>   <span class="p">:</span> <span class="k">public</span>  <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepEdge</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepEdgeArray</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepEdgeArray</span><span class="p">();</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepTrimArray</span>   <span class="p">:</span> <span class="k">public</span>  <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepTrim</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepTrimArray</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepTrimArray</span><span class="p">();</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepLoopArray</span>   <span class="p">:</span> <span class="k">public</span>  <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepLoop</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepLoopArray</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepLoopArray</span><span class="p">();</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepFaceArray</span>   <span class="p">:</span> <span class="k">public</span>  <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepFace</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepFaceArray</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepFaceArray</span><span class="p">();</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepFaceSideArray</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepFaceSide</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepFaceSideArray</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepFaceSideArray</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BrepRegionArray</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_BrepRegion</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepRegionArray</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_BrepRegionArray</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_BrepRegionTopology</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BrepRegionTopology</span><span class="p">();</span>
  <span class="n">ON_BrepRegionTopology</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepRegionTopology</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>
  <span class="o">~</span><span class="n">ON_BrepRegionTopology</span><span class="p">();</span>
  <span class="n">ON_BrepRegionTopology</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BrepRegionTopology</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="n">ON_BrepFaceSideArray</span> <span class="n">m_FS</span><span class="p">;</span>
  <span class="n">ON_BrepRegionArray</span> <span class="n">m_R</span><span class="p">;</span>

  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">Brep</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_BrepRegionTopologyUserData</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Brep</span><span class="p">;</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">m_brep</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_Brep</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_Brep</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="c1">// virtual ON_Object::DestroyRuntimeCache override</span>
  <span class="kt">void</span> <span class="n">DestroyRuntimeCache</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDelete</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Object::SizeOf override</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::DataCRC override</span>
  <span class="n">ON__UINT32</span> <span class="nf">DataCRC</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">current_remainder</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry override</span>
  <span class="kt">bool</span> <span class="nf">EvaluatePoint</span><span class="p">(</span> <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_ObjRef</span><span class="o">&amp;</span> <span class="n">objref</span><span class="p">,</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Use ON_Brep::New() instead of new ON_Brep() when writing</span>
<span class="cm">    Rhino plug-ins (or when openNURBS is used as a Microsoft</span>
<span class="cm">    DLL and you need to create a new ON_Brep in a different</span>
<span class="cm">    .EXE or .DLL).</span>
<span class="cm">  Example:</span>

<span class="cm">              // bad - ON_Brep* pBrep = new ON_Brep();</span>
<span class="cm">              ON_Brep* pBrep = ON_Brep::New(); // good</span>
<span class="cm">              ...</span>
<span class="cm">              delete pBrep;</span>
<span class="cm">              pBrep = NULL;</span>

<span class="cm">  Returns:</span>
<span class="cm">    Pointer to an ON_Brep.  Destroy by calling delete.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    When openNURBS is used as a Microsoft DLL, the CL.EXE</span>
<span class="cm">    compiler uses local vtables for classes that are new-ed</span>
<span class="cm">    in other executables but uses the ordinary vtable for</span>
<span class="cm">    for classes that are allocated in functions like</span>
<span class="cm">    ON_BrepCylinder(), ON_NurbsSurfaceQuadrilateral(),</span>
<span class="cm">    ON_Cylinder::RevSurfaceForm(NULL), etc.</span>
<span class="cm">    Using static New() functions like ON_Brep::New() insures</span>
<span class="cm">    that identical classes has the same vtable and makes</span>
<span class="cm">    all code run identically.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">New</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Use ON_Brep::New(const ON_Brep&amp; src) instead</span>
<span class="cm">    of new ON_Brep(const ON_Brep&amp; src).</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to an ON_Brep.  Destroy by calling delete.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    See static ON_Brep* ON_Brep::New() for details.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">New</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Brep</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// Construction</span>
  <span class="n">ON_Brep</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_Brep</span><span class="p">();</span>
  <span class="n">ON_Brep</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Brep</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Brep</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// Override of virtual ON_Object::MemoryRelocate</span>
  <span class="kt">void</span> <span class="nf">MemoryRelocate</span><span class="p">();</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    See if this and other are same brep geometry.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    other - [in] other brep</span>
<span class="cm">    tolerance - [in] tolerance to use when comparing</span>
<span class="cm">                     control points.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if breps are the same</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsDuplicate</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="n">ON_ZERO_TOLERANCE</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// construction/destruction helpers</span>

  <span class="c1">// returns Brep to state it has after default construction</span>
  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>

  <span class="c1">// call if memory pool used by b-rep members becomes invalid</span>
  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calculates polygon mesh approximation of the brep</span>
<span class="cm">    and appends one mesh for each face to the mesh_list[]</span>
<span class="cm">    array.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mp - [in] meshing parameters</span>
<span class="cm">    mesh_list - [out] meshes are appended to this array.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of meshes appended to mesh_list[] array.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">CreateMesh</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_MeshParameters</span><span class="o">&amp;</span> <span class="n">mp</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Mesh</span><span class="o">*&gt;&amp;</span> <span class="n">mesh_list</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Destroy meshes used to render and analyze brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh_type - [in] type of mesh to destroy</span>
<span class="cm">    bDeleteMesh - [in] if true, cached meshes are deleted.</span>
<span class="cm">      If false, pointers to cached meshes are just set to NULL.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::GetMesh</span>
<span class="cm">    ON_BrepFace::DestroyMesh</span>
<span class="cm">    ON_BrepFace::Mesh</span>
<span class="cm">    ON_BrepFace::SetMesh</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DestroyMesh</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">mesh_type</span> <span class="n">mesh_type</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bDeleteMesh</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get cached meshes used to render and analyze brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh_type - [in] type of mesh to get</span>
<span class="cm">    meshes - [out] meshes are appended to this array.  The ON_Brep</span>
<span class="cm">      owns these meshes so they cannot be modified.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of meshes added to array. (Same as m_F.Count())</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::DestroyMesh</span>
<span class="cm">    ON_BrepFace::DestroyMesh</span>
<span class="cm">    ON_BrepFace::Mesh</span>
<span class="cm">    ON_BrepFace::SetMesh</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetMesh</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">mesh_type</span> <span class="n">mesh_type</span><span class="p">,</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span> <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="o">&gt;&amp;</span> <span class="n">meshes</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a brep from a surface.  The resulting surface has an outer</span>
<span class="cm">    boundary made from four trims.  The trims are ordered so that</span>
<span class="cm">    they run along the south, east, north, and then west side of the</span>
<span class="cm">    surface&#39;s parameter space.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    pSurface - [in] pointer to a surface.  The brep will manage this</span>
<span class="cm">       pointer and delete it in ~ON_Brep.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     successful</span>
<span class="cm">      When true is returned, the pSurface pointer is added to the</span>
<span class="cm">      brep&#39;s m_S[] array and it will be deleted by the brep&#39;s</span>
<span class="cm">      destructor.</span>
<span class="cm">    false</span>
<span class="cm">      brep cannot be created from this surface.</span>
<span class="cm">      When false is returned, then the caller is responsible</span>
<span class="cm">      for deleting pSurface unless it was previously added</span>
<span class="cm">      to the brep&#39;s m_S[] array.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The surface class must be created with new so that the</span>
<span class="cm">    delete in ~ON_Brep will not cause a crash.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span>
          <span class="n">ON_Surface</span><span class="o">*&amp;</span> <span class="n">pSurface</span>
          <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span>
          <span class="n">ON_NurbsSurface</span><span class="o">*&amp;</span> <span class="n">pNurbsSurface</span>
          <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span>
          <span class="n">ON_PlaneSurface</span><span class="o">*&amp;</span> <span class="n">pPlaneSurface</span>
          <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span>
          <span class="n">ON_RevSurface</span><span class="o">*&amp;</span> <span class="n">pRevSurface</span>
          <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span>
          <span class="n">ON_SumSurface</span><span class="o">*&amp;</span> <span class="n">pSumSurface</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetTolerancesAndFlags</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests the brep to see if its topology information is</span>
<span class="cm">    valid.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the brep topology is not valid and</span>
<span class="cm">        text_log is not NULL, then a brief english</span>
<span class="cm">        description of the problem is appended to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     brep topology is valid</span>
<span class="cm">    false    brep topology is not valid</span>
<span class="cm">  Remarks:</span>
<span class="cm">    ON_Brep::IsValidTopology can be called at any time.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::IsValid</span>
<span class="cm">    ON_Brep::IsValidGeometry</span>
<span class="cm">    ON_Brep::IsValidTolerancesAndFlags</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsValidTopology</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function that tests the brep to see if its</span>
<span class="cm">    geometry information is valid.  The value of</span>
<span class="cm">    brep.IsValidTopology() must be true before</span>
<span class="cm">    brep.IsValidGeometry() can be safely called.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the brep geometry is not valid and</span>
<span class="cm">        text_log is not NULL, then a brief english</span>
<span class="cm">        description of the problem is appended to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     brep geometry is valid</span>
<span class="cm">    false    brep geometry is not valid</span>
<span class="cm">  Remarks:</span>
<span class="cm">    ON_Brep::IsValidTopology must be true before you can</span>
<span class="cm">    safely call ON_Brep::IsValidGeometry.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::IsValid</span>
<span class="cm">    ON_Brep::IsValidTopology</span>
<span class="cm">    ON_Brep::IsValidTolerancesAndFlags</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsValidGeometry</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function that tests the brep to see if its</span>
<span class="cm">    tolerances and flags are valid.  The values of</span>
<span class="cm">    brep.IsValidTopology() and brep.IsValidGeometry() must</span>
<span class="cm">    be true before brep.IsValidTolerancesAndFlags() can</span>
<span class="cm">    be safely called.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the brep tolerance or flags are not</span>
<span class="cm">        valid and text_log is not NULL, then a brief english</span>
<span class="cm">        description of the problem is appended to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     brep tolerance and flags are valid</span>
<span class="cm">    false    brep tolerance and flags are not valid</span>
<span class="cm">  Remarks:</span>
<span class="cm">    ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry</span>
<span class="cm">    must be true before you can safely call</span>
<span class="cm">    ON_Brep::IsValidTolerancesAndFlags.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::IsValid</span>
<span class="cm">    ON_Brep::IsValidTopology</span>
<span class="cm">    ON_Brep::IsValidGeometry</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsValidTolerancesAndFlags</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Tests brep to see if it is valid for</span>
  <span class="c1">//   saving in V2 3DM archives.</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   true if brep is valid for V2 3DM archives.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   V2 breps could not have dangling curves.</span>
  <span class="kt">bool</span> <span class="nf">IsValidForV2</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidForV2</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidForV2</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Objet::Dump() override</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// for debugging</span>

  <span class="c1">// virtual ON_Objet::Write() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Objet::Read() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// virtual ON_Objet::ObjectType() override</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::Dimension() override</span>
  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::ClearBoundingBox() override</span>
  <span class="kt">void</span> <span class="nf">ClearBoundingBox</span><span class="p">();</span>

  <span class="c1">// virtual ON_Geometry::GetBBox() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span> <span class="c1">// returns true if successful</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// minimum</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// maximum</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>  <span class="c1">// true means grow box</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::Transform() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span>
         <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::SwapCoordinates() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">SwapCoordinates</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span>        <span class="c1">// indices of coords to swap</span>
        <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::HasBrepForm() override</span>
  <span class="n">ON_BOOL32</span> <span class="nf">HasBrepForm</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// returns true</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If possible, BrepForm() creates a brep form of the</span>
<span class="cm">    ON_Geometry.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    brep - [in] if not NULL, brep is used to store the brep</span>
<span class="cm">        form of the geometry.</span>
<span class="cm">  Result:</span>
<span class="cm">    If brep is not NULL, then brep = this, otherwise</span>
<span class="cm">    a duplicate of this is returned.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Override of virtual ON_Geometry::BrepForm</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">BrepForm</span><span class="p">(</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">brep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Creation Interface</span>

  <span class="c1">// These add a new geometry piece to the b-rep and return the</span>
  <span class="c1">// index that should be used to reference the geometry.</span>
  <span class="c1">// -1 is returned if the input is not acceptable.</span>
  <span class="c1">// ~ON_Brep() will delete the geometry.</span>
  <span class="kt">int</span> <span class="nf">AddTrimCurve</span><span class="p">(</span> <span class="n">ON_Curve</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// 2d curve used by ON_BrepTrim</span>
  <span class="kt">int</span> <span class="nf">AddEdgeCurve</span><span class="p">(</span> <span class="n">ON_Curve</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// 3d curve used by ON_BrepEdge</span>
  <span class="kt">int</span> <span class="nf">AddSurface</span><span class="p">(</span> <span class="n">ON_Surface</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// 3d surface used by ON_BrepFace</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Set 3d curve geometry used by a b-rep edge.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   edge - [in]</span>
  <span class="c1">//   c3_index - [in] index of 3d curve in m_C3[] array</span>
  <span class="c1">//   sub_domain - [in] if not NULL, sub_domain is an increasing</span>
  <span class="c1">//      sub interval of m_C3[c3_index]-&gt;Domain().</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   true if successful.</span>
  <span class="kt">bool</span> <span class="nf">SetEdgeCurve</span><span class="p">(</span>
    <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edge</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">c3_index</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">*</span> <span class="n">sub_domain</span> <span class="o">=</span> <span class="nb">NULL</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Set 2d curve geometry used by a b-rep trim.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   trim - [in]</span>
  <span class="c1">//   c2_index - [in] index of 2d curve in m_C2[] array</span>
  <span class="c1">//   sub_domain - [in] if not NULL, sub_domain is an increasing</span>
  <span class="c1">//      sub interval of m_C2[c2_index]-&gt;Domain().</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   true if successful.</span>
  <span class="kt">bool</span> <span class="nf">SetTrimCurve</span><span class="p">(</span>
    <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">trim</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">c2_index</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">*</span> <span class="n">sub_domain</span> <span class="o">=</span> <span class="nb">NULL</span>
    <span class="p">);</span>

  <span class="c1">// These add a new topology piece to the b-rep and return a</span>
  <span class="c1">// reference that is intended to be used for initialization.</span>
  <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="n">NewVertex</span><span class="p">();</span>
  <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="n">NewVertex</span><span class="p">(</span>
    <span class="n">ON_3dPoint</span> <span class="n">vertex_point</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">vertex_tolerance</span> <span class="o">=</span> <span class="n">ON_UNSET_VALUE</span>
    <span class="p">);</span>

  <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">NewEdge</span><span class="p">(</span>
                  <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>              <span class="c1">// 3d curve index</span>
                  <span class="p">);</span>
  <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">NewEdge</span><span class="p">(</span>
                  <span class="n">ON_BrepVertex</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// start vertex</span>
                  <span class="n">ON_BrepVertex</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// end vertex</span>
                  <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>       <span class="c1">// 3d curve index</span>
                  <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="c1">// sub_domain</span>
                  <span class="kt">double</span> <span class="n">edge_tolerance</span> <span class="o">=</span> <span class="n">ON_UNSET_VALUE</span>
                  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new face to a brep.  An incomplete face is added.</span>
<span class="cm">    The caller must create and fill in the loops used by</span>
<span class="cm">    the face.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    si - [in] index of surface in brep&#39;s m_S[] array</span>
<span class="cm">  Returns:</span>
<span class="cm">    Reference to new face.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Adding a new face may grow the dynamic m_F array.  When</span>
<span class="cm">    this happens pointers and references to memory in the</span>
<span class="cm">    previous m_F[] array may become invalid.  Use face indices</span>
<span class="cm">    if this is an issue.</span>
<span class="cm">  Example:</span>
<span class="cm">    See ON_BrepBox and ON_BrepSphere source code.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::AddSurface</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">NewFace</span><span class="p">(</span>
                  <span class="kt">int</span> <span class="n">si</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new face to a brep.  This creates a complete face with</span>
<span class="cm">    new vertices at the surface corners, new edges along the surface</span>
<span class="cm">    boundary, etc.  The loop of the returned face has four trims that</span>
<span class="cm">    correspond to the south, east, north, and west side of the</span>
<span class="cm">    surface in that order.  If you use this version of NewFace to</span>
<span class="cm">    add an exiting brep, then you are responsible for using a tool</span>
<span class="cm">    like ON_Brep::JoinEdges() to hook the new face to its</span>
<span class="cm">    neighbors.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    surface - [in] surface is copied.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to new face.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Adding a new face may grow the dynamic arrays used to store</span>
<span class="cm">    vertices, edges, faces, loops, and trims.  When these dyamic</span>
<span class="cm">    arrays are grown, any pointers and references to memory in</span>
<span class="cm">    the previous arrays may become invalid.  Use indices</span>
<span class="cm">    if this is an issue.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::JoinEdges</span>
<span class="cm">    ON_Brep::AddSurface</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">NewFace</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Surface</span><span class="o">&amp;</span> <span class="n">surface</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new face to brep.  This version is for expert users.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    pSurface - [in] the returned face will have an outer loop</span>
<span class="cm">                    that goes around the edges of the surface.</span>
<span class="cm">    vid - [in/out] four vertex indices that specify the vertices at</span>
<span class="cm">                   the (sw,se,nw,ne) corners.  If the input value</span>
<span class="cm">                   of a vertex index is -1, then the vertex will be</span>
<span class="cm">                   created.</span>
<span class="cm">    eid - [in/out] four edge indices that specify the edges for</span>
<span class="cm">                   the (south,east,north,west) sides.  If the input value</span>
<span class="cm">                   of an edge index is -1, then the edge will be created.</span>
<span class="cm">    bRev3d - [in/out] four values of the trim m_bRev3d flags of</span>
<span class="cm">                   the (south,east,north,west) sides.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to the new face or NULL if input is not valid.</span>
<span class="cm">    If null is returned, then the caller must delete pSurace</span>
<span class="cm">    unless it was previously added to the brep&#39;s m_S[] array.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Adding a new face may grow the dynamic m_F array.  When</span>
<span class="cm">    this happens pointers and references to memory in the</span>
<span class="cm">    previous m_F[] array may become invalid.  Use face indices</span>
<span class="cm">    if this is an issue.</span>
<span class="cm">  Example:</span>
<span class="cm">    See ON_BrepBox and ON_BrepSphere source code.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::AddSurface</span>
<span class="cm">    ON_Brep::AddFace( int si )</span>
<span class="cm">    ON_Brep::Create( ON_Surface*&amp; )</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">NewFace</span><span class="p">(</span>
       <span class="n">ON_Surface</span><span class="o">*</span> <span class="n">pSurface</span><span class="p">,</span>
       <span class="kt">int</span> <span class="n">vid</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
       <span class="kt">int</span> <span class="n">eid</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
       <span class="n">ON_BOOL32</span> <span class="n">bRev3d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
       <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new face to the brep whose surface geometry is a</span>
<span class="cm">    ruled surface between two edges.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edgeA - [in] The south side of the face&#39;s surface will</span>
<span class="cm">          run along edgeA.</span>
<span class="cm">    bRevEdgeA - [in] true if the new face&#39;s outer boundary</span>
<span class="cm">          orientation along edgeA is opposite the orientation</span>
<span class="cm">          of edgeA.</span>
<span class="cm">    edgeB - [in] The north side of the face&#39;s surface will</span>
<span class="cm">          run along edgeA.</span>
<span class="cm">    bRevEdgeB - [in] true if the new face&#39;s outer boundary</span>
<span class="cm">          orientation along edgeB is opposite the orientation</span>
<span class="cm">          of edgeB.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to the new face or a NULL if the new face could</span>
<span class="cm">    not be created.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">NewRuledFace</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edgeA</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">bRevEdgeA</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edgeB</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">bRevEdgeB</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new face to the brep whose surface geometry is a</span>
<span class="cm">    ruled cone with the edge as the base and the vertex as</span>
<span class="cm">    the apex point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    vertex - [in] The apex of the cone will be at this vertex.</span>
<span class="cm">                   The north side of the surface&#39;s parameter</span>
<span class="cm">                   space will be a singular point at the vertex.</span>
<span class="cm">    edge - [in] The south side of the face&#39;s surface will</span>
<span class="cm">          run along this edge.</span>
<span class="cm">    bRevEdge - [in] true if the new face&#39;s outer boundary</span>
<span class="cm">          orientation along the edge is opposite the</span>
<span class="cm">          orientation of edge.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to the new face or a NULL if the new face could</span>
<span class="cm">    not be created.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">NewConeFace</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edge</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">bRevEdge</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a new outer boundary loop that runs along the edges</span>
<span class="cm">    of the underlying surface.</span>
<span class="cm">  Returns:</span>
<span class="cm">    New outer boundary loop.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">NewLoop</span><span class="p">(</span> <span class="n">ON_BrepLoop</span><span class="o">::</span><span class="n">TYPE</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a new boundary loop on a face.  After you get this</span>
<span class="cm">    ON_BrepLoop, you still need to create the vertices, edges,</span>
<span class="cm">    and trims that define the loop.</span>
<span class="cm">  Returns:</span>
<span class="cm">    New loop that needs to be filled in.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">NewLoop</span><span class="p">(</span> <span class="n">ON_BrepLoop</span><span class="o">::</span><span class="n">TYPE</span> <span class="n">loop_type</span><span class="p">,</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">face</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a new outer boundary loop that runs along the sides</span>
<span class="cm">    of the face&#39;s surface.  All the necessary trims, edges,</span>
<span class="cm">    and vertices are created and added to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face_index - [in] index of face that needs an outer boundary</span>
<span class="cm">                      that runs along the sides of its surface.</span>
<span class="cm">  Returns:</span>
<span class="cm">    New outer boundary loop that is complete.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">*</span> <span class="nf">NewOuterLoop</span><span class="p">(</span> <span class="kt">int</span> <span class="n">face_index</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new face to brep.  This version is for expert users.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face_index - [in] index of face that will get a new outer</span>
<span class="cm">                   loop running around the sides of the face&#39;s</span>
<span class="cm">                   underlying surface.</span>
<span class="cm">    vid - [in/out] four vertex indices that specify the vertices at</span>
<span class="cm">                   the (sw,se,nw,ne) corners.  If the input value</span>
<span class="cm">                   of a vertex index is -1, then the vertex will be</span>
<span class="cm">                   created.</span>
<span class="cm">    eid - [in/out] four edge indices that specify the edges for</span>
<span class="cm">                   the (south,east,north,west) sides.  If the input value</span>
<span class="cm">                   of an edge index is -1, then the edge will be created.</span>
<span class="cm">    bRev3d - [in/out] four values of the trim m_bRev3d flags of</span>
<span class="cm">                   the (south,east,north,west) sides.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to the new loop or NULL if input is not valid.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Adding a new loop may grow the dynamic m_L array.  When</span>
<span class="cm">    this happens pointers and references to memory in the</span>
<span class="cm">    previous m_L[] array may become invalid.  Use face indices</span>
<span class="cm">    if this is an issue.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::NewFace</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">*</span> <span class="nf">NewOuterLoop</span><span class="p">(</span>
         <span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">vid</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
         <span class="kt">int</span> <span class="n">eid</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
         <span class="n">ON_BOOL32</span> <span class="n">bRev3d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
         <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a planar trimming loop to a planar face.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face_index - [in] index of planar face.  The underlying</span>
<span class="cm">        suface must be an ON_PlaneSurface.</span>
<span class="cm">    loop_type - [in] type of loop to add.  If loop_type is</span>
<span class="cm">        ON_BrepLoop::unknown, then the loop direction is tested</span>
<span class="cm">        and the the new loops type will be set to</span>
<span class="cm">        ON_BrepLoop::outer or ON_BrepLoop::inner.  If the loop_type</span>
<span class="cm">        is ON_BrepLoop::outer, then the direction of the new loop</span>
<span class="cm">        is tested and flipped if it is clockwise. If the loop_type</span>
<span class="cm">        is ON_BrepLoop::inner, then the direction of the new loop</span>
<span class="cm">        is tested and flipped if it is counter-clockwise.</span>
<span class="cm">    boundary - [in] a list of 3d curves that form a simple (no self</span>
<span class="cm">        intersections) closed curve.  These curves define the 3d</span>
<span class="cm">        edge geometry and should be near the planar surface.</span>
<span class="cm">    bDuplicateCurves - [in] If true, then duplicates of the curves</span>
<span class="cm">        in the boundary array are added to the brep.  If false, the</span>
<span class="cm">        curves in the boundary array are added to the brep and will</span>
<span class="cm">        be deleted by ON_Brep::~ON_Brep.</span>
<span class="cm">    Returns:</span>
<span class="cm">      true if successful.  The new loop will be brep.m_L.Last().</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">NewPlanarFaceLoop</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span>
        <span class="n">ON_BrepLoop</span><span class="o">::</span><span class="n">TYPE</span> <span class="n">loop_type</span><span class="p">,</span>
        <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Curve</span><span class="o">*&gt;&amp;</span> <span class="n">boundary</span><span class="p">,</span>
        <span class="n">ON_BOOL32</span> <span class="n">bDuplicateCurves</span> <span class="o">=</span> <span class="nb">true</span>
        <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new trim that will be part of an inner, outer, or slit loop</span>
<span class="cm">    to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    c2i - [in] index of 2d trimming curve</span>
<span class="cm">  Returns:</span>
<span class="cm">    new trim</span>
<span class="cm">  Example:</span>
<span class="cm">    int c2i = brep-&gt;AddTrimCurve( p2dCurve );</span>
<span class="cm">    ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );</span>
<span class="cm">    trim.m_ei = ...;</span>
<span class="cm">    trim.m_li = ...;</span>
<span class="cm">    trim.m_tolerance[0] = ...;</span>
<span class="cm">    trim.m_tolerance[1] = ...;</span>
<span class="cm">    trim.m_type = ...;</span>
<span class="cm">    trim.m_iso = ...;</span>
<span class="cm">  Remarks:</span>
<span class="cm">    You should set the trim&#39;s ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,</span>
<span class="cm">    ON_BrepTrim::m_iso, ON_BrepTrim::m_li, and ON_BrepTrim::m_ei values.</span>
<span class="cm">        In general, you should try to use the</span>
<span class="cm">    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.</span>
<span class="cm">    If you want to add a singular trim, use ON_Brep::NewSingularTrim.</span>
<span class="cm">    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.</span>
<span class="cm">    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetTrimTypeFlags</span>
<span class="cm">    ON_Brep::SetTrimIsoFlags</span>
<span class="cm">    ON_Brep::NewSingularTrim</span>
<span class="cm">    ON_Brep::NewPointOnFace</span>
<span class="cm">    ON_Brep::NewCurveOnFace</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">NewTrim</span><span class="p">(</span>
                  <span class="kt">int</span> <span class="n">c2i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new trim that will be part of an inner, outer, or slit loop</span>
<span class="cm">    to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the</span>
<span class="cm">       edge and trim have opposite directions.</span>
<span class="cm">    loop - [in] trim is appended to this loop</span>
<span class="cm">    c2i - [in] index of 2d trimming curve</span>
<span class="cm">  Returns:</span>
<span class="cm">    new trim</span>
<span class="cm">  Example:</span>
<span class="cm">    int c2i = brep-&gt;AddTrimCurve( p2dCurve );</span>
<span class="cm">    ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );</span>
<span class="cm">    trim.m_ei = ...;</span>
<span class="cm">    trim.m_tolerance[0] = ...;</span>
<span class="cm">    trim.m_tolerance[1] = ...;</span>
<span class="cm">    trim.m_type = ...;</span>
<span class="cm">    trim.m_iso = ...;</span>
<span class="cm">  Remarks:</span>
<span class="cm">    You should set the trim&#39;s ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,</span>
<span class="cm">    ON_BrepTrim::m_iso, and ON_BrepTrim::m_ei values.</span>
<span class="cm">        In general, you should try to use the</span>
<span class="cm">    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.</span>
<span class="cm">    If you want to add a singular trim, use ON_Brep::NewSingularTrim.</span>
<span class="cm">    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.</span>
<span class="cm">    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetTrimTypeFlags</span>
<span class="cm">    ON_Brep::SetTrimIsoFlags</span>
<span class="cm">    ON_Brep::NewSingularTrim</span>
<span class="cm">    ON_Brep::NewPointOnFace</span>
<span class="cm">    ON_Brep::NewCurveOnFace</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">NewTrim</span><span class="p">(</span>
                  <span class="n">ON_BOOL32</span> <span class="n">bRev3d</span><span class="p">,</span>
                  <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">c2i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new trim that will be part of an inner, outer, or slit loop</span>
<span class="cm">    to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge - [in] 3d edge associated with this trim</span>
<span class="cm">    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the</span>
<span class="cm">       edge and trim have opposite directions.</span>
<span class="cm">    c2i - [in] index of 2d trimming curve</span>
<span class="cm">  Returns:</span>
<span class="cm">    new trim</span>
<span class="cm">  Example:</span>
<span class="cm">    int c2i = brep-&gt;AddTrimCurve( p2dCurve );</span>
<span class="cm">    ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, c2i );</span>
<span class="cm">    trim.m_li = ...;</span>
<span class="cm">    trim.m_tolerance[0] = ...;</span>
<span class="cm">    trim.m_tolerance[1] = ...;</span>
<span class="cm">    trim.m_type = ...;</span>
<span class="cm">    trim.m_iso = ...;</span>
<span class="cm">  Remarks:</span>
<span class="cm">    You should set the trim&#39;s ON_BrepTrim::m_tolerance,</span>
<span class="cm">    ON_BrepTrim::m_type, ON_BrepTrim::m_iso,</span>
<span class="cm">    and ON_BrepTrim::m_li values.</span>
<span class="cm">        In general, you should try to use the</span>
<span class="cm">    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.</span>
<span class="cm">    If you want to add a singular trim, use ON_Brep::NewSingularTrim.</span>
<span class="cm">    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.</span>
<span class="cm">    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetTrimTypeFlags</span>
<span class="cm">    ON_Brep::SetTrimIsoFlags</span>
<span class="cm">    ON_Brep::NewSingularTrim</span>
<span class="cm">    ON_Brep::NewPointOnFace</span>
<span class="cm">    ON_Brep::NewCurveOnFace</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">NewTrim</span><span class="p">(</span>
                  <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edge</span><span class="p">,</span>
                  <span class="n">ON_BOOL32</span> <span class="n">bRev3d</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">c2i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new trim that will be part of an inner, outer, or slit loop</span>
<span class="cm">    to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge - [in] 3d edge associated with this trim</span>
<span class="cm">    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the</span>
<span class="cm">       edge and trim have opposite directions.</span>
<span class="cm">    loop - [in] trim is appended to this loop</span>
<span class="cm">    c2i - [in] index of 2d trimming curve</span>
<span class="cm">  Returns:</span>
<span class="cm">    new trim</span>
<span class="cm">  Example:</span>
<span class="cm">    int c2i = brep-&gt;AddTrimCurve( p2dCurve );</span>
<span class="cm">    ON_BrepTrim&amp; trim = brep-&gt;NewTrim( edge, bRev3d, loop, c2i );</span>
<span class="cm">    trim.m_tolerance[0] = ...;</span>
<span class="cm">    trim.m_tolerance[1] = ...;</span>
<span class="cm">  Remarks:</span>
<span class="cm">    You should set the trim&#39;s ON_BrepTrim::m_tolerance values.</span>
<span class="cm">    If c2i is -1, you must set the trim&#39;s ON_BrepTrim::m_iso values.</span>
<span class="cm">    This version of NewTrim sets the trim.m_type value.  If the</span>
<span class="cm">    input edge or loop are not currently valid, then you may</span>
<span class="cm">    need to adjust the trim.m_type value.</span>
<span class="cm">    If you want to add a singular trim, use ON_Brep::NewSingularTrim.</span>
<span class="cm">    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.</span>
<span class="cm">    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetTrimTypeFlags</span>
<span class="cm">    ON_Brep::SetTrimIsoFlags</span>
<span class="cm">    ON_Brep::NewSingularTrim</span>
<span class="cm">    ON_Brep::NewPointOnFace</span>
<span class="cm">    ON_Brep::NewCurveOnFace</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">NewTrim</span><span class="p">(</span>
                  <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edge</span><span class="p">,</span>
                  <span class="n">ON_BOOL32</span> <span class="n">bRev3d</span><span class="p">,</span>
                  <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">c2i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new singular trim to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    vertex - [in] vertex along collapsed surface edge</span>
<span class="cm">    loop - [in] trim is appended to this loop</span>
<span class="cm">    iso - [in] one of ON_Surface::S_iso, ON_Surface::E_iso,</span>
<span class="cm">               ON_Surface::N_iso, or ON_Surface::W_iso.</span>
<span class="cm">    c2i - [in] index of 2d trimming curve</span>
<span class="cm">  Returns:</span>
<span class="cm">    new trim</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::NewTrim</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">NewSingularTrim</span><span class="p">(</span>
                  <span class="k">const</span> <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">,</span>
                  <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span><span class="p">,</span>
                  <span class="n">ON_Surface</span><span class="o">::</span><span class="n">ISO</span> <span class="n">iso</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">c2i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Adds a new point on face to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face - [in] face that vertex lies on</span>
<span class="cm">    s,t - [in] surface parameters</span>
<span class="cm">  Returns:</span>
<span class="cm">    new vertex that represents the point on face.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If a vertex is a point on a face, then brep.m_E[m_ei]</span>
<span class="cm">    will be an edge with no 3d curve.  This edge will have</span>
<span class="cm">    a single trim with type ON_BrepTrim::ptonsrf.  There</span>
<span class="cm">    will be a loop containing this single trim.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="n">NewPointOnFace</span><span class="p">(</span>
    <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">face</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">s</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">t</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add a new curve on face to the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face - [in] face that curve lies on</span>
<span class="cm">    edge - [in] 3d edge associated with this curve on surface</span>
<span class="cm">    bRev3d - [in] true if the 3d edge and the 2d parameter space</span>
<span class="cm">                  curve have opposite directions.</span>
<span class="cm">    c2i - [in] index of 2d curve in face&#39;s parameter space</span>
<span class="cm">  Returns:</span>
<span class="cm">    new trim that represents the curve on surface</span>
<span class="cm">  Remarks:</span>
<span class="cm">    You should set the trim&#39;s ON_BrepTrim::m_tolerance and</span>
<span class="cm">    ON_BrepTrim::m_iso values.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">NewCurveOnFace</span><span class="p">(</span>
                  <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">face</span><span class="p">,</span>
                  <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edge</span><span class="p">,</span>
                  <span class="n">ON_BOOL32</span> <span class="n">bRev3d</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">c2i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                  <span class="p">);</span>

  <span class="c1">// appends a copy of brep to this and updates</span>
  <span class="c1">// indices of appended brep parts.  Duplicates are not removed.</span>
  <span class="kt">void</span> <span class="nf">Append</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="c1">// brep</span>
    <span class="p">);</span>

  <span class="c1">// This function can be used to compute vertex information for a</span>
  <span class="c1">// b-rep when everything but the m_V array is properly filled in.</span>
  <span class="c1">// It is intended to be used when creating a ON_Brep from a</span>
  <span class="c1">// definition that does not include explicit vertex information.</span>
  <span class="kt">void</span> <span class="nf">SetVertices</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

  <span class="c1">// This function can be used to set the ON_BrepTrim::m_iso</span>
  <span class="c1">// flag. It is intended to be used when creating a ON_Brep from</span>
  <span class="c1">// a definition that does not include compatible parameter space</span>
  <span class="c1">// type information.</span>
  <span class="c1">// See Also: ON_BrepSetFlagsAndTolerances</span>
  <span class="kt">bool</span> <span class="nf">SetTrimIsoFlags</span><span class="p">();</span>    <span class="c1">// sets all trim iso flags</span>
  <span class="kt">bool</span> <span class="nf">SetTrimIsoFlags</span><span class="p">(</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetTrimIsoFlags</span><span class="p">(</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetTrimIsoFlags</span><span class="p">(</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calculate the type (singular, mated, boundary, etc.) of</span>
<span class="cm">    an ON_BrepTrim object.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    trim - [in]</span>
<span class="cm">    bLazy - [in] if true and trim.m_type is set to something other</span>
<span class="cm">       than ON_BrepTrim::unknown, then no calculation is</span>
<span class="cm">       performed and the value of trim.m_type is returned.</span>
<span class="cm">       If false, the value of trim.m_type is ignored and is caluculated.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Type of trim.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The trim must be connected to a valid loop.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetTrimTypeFlags</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">::</span><span class="n">TYPE</span> <span class="n">TrimType</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">trim</span><span class="p">,</span>
    <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">true</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// This function can be used to set the ON_BrepTrim::m_type</span>
  <span class="c1">// flag.  If the optional bLazy argument is true, then only</span>
  <span class="c1">// trims with m_type = unknown are set.</span>
  <span class="c1">// See Also: ON_BrepSetFlagsAndTolerances</span>
  <span class="kt">bool</span> <span class="nf">SetTrimTypeFlags</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">);</span>    <span class="c1">// sets all trim iso flags</span>
  <span class="kt">bool</span> <span class="nf">SetTrimTypeFlags</span><span class="p">(</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetTrimTypeFlags</span><span class="p">(</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetTrimTypeFlags</span><span class="p">(</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">);</span>

  <span class="c1">// GetTrim2dStart() evaluates the start of the</span>
  <span class="c1">// parameter space (2d) trim curve.</span>
  <span class="kt">bool</span> <span class="nf">GetTrim2dStart</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">trim_index</span><span class="p">,</span>         <span class="c1">// index of ON_BrepTrim in m_T[] array</span>
          <span class="n">ON_2dPoint</span><span class="o">&amp;</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// GetTrim2dEnd() evaluates end of the</span>
  <span class="c1">// parameter space (2d) trim curve.</span>
  <span class="kt">bool</span> <span class="nf">GetTrim2dEnd</span><span class="p">(</span>
          <span class="kt">int</span><span class="p">,</span>         <span class="c1">// index of ON_BrepTrim in m_T[] array</span>
          <span class="n">ON_2dPoint</span><span class="o">&amp;</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// GetTrim3dStart() evaluates the 3d surface at the start of the</span>
  <span class="c1">// parameter space (2d) trim curve.</span>
  <span class="kt">bool</span> <span class="nf">GetTrim3dStart</span><span class="p">(</span>
          <span class="kt">int</span><span class="p">,</span>         <span class="c1">// index of ON_BrepTrim in m_T[] array</span>
          <span class="n">ON_3dPoint</span><span class="o">&amp;</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// GetTrim3dEnd() evaluates the 3d surface at the end of the</span>
  <span class="c1">// parameter space (2d) trim curve.</span>
  <span class="kt">bool</span> <span class="nf">GetTrim3dEnd</span><span class="p">(</span>
          <span class="kt">int</span><span class="p">,</span>         <span class="c1">// index of ON_BrepTrim in m_T[] array</span>
          <span class="n">ON_3dPoint</span><span class="o">&amp;</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// This function examines the 2d parameter space curves and returns</span>
  <span class="c1">// the loop&#39;s type based on their orientation.  Use this function for</span>
  <span class="c1">// debugging loop orientation problems.</span>
  <span class="n">ON_BrepLoop</span><span class="o">::</span><span class="n">TYPE</span> <span class="n">ComputeLoopType</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// These set the various tolerances.  The optional ON_BOOL32 argument</span>
  <span class="c1">// is called bLazy.  If bLazy is false, the tolerance is recomputed</span>
  <span class="c1">// from its definition.  If bLazy is true, the tolerance is computed</span>
  <span class="c1">// only if its current value is negative.</span>
  <span class="kt">bool</span> <span class="nf">SetVertexTolerance</span><span class="p">(</span> <span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SetTrimTolerance</span><span class="p">(</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">trim</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SetEdgeTolerance</span><span class="p">(</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edge</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the brep&#39;s vertex tolerances.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bLazy - [in] if true, only vertex tolerances with the value</span>
<span class="cm">       ON_UNSET_VALUE will be set.  If false, the vertex tolerance</span>
<span class="cm">       is recomputed from the geometry in the brep.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if successful.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetVertexTolerance</span>
<span class="cm">    ON_Brep::SetTrimTolerance</span>
<span class="cm">    ON_Brep::SetEdgeTolerance</span>
<span class="cm">    ON_Brep::SetVertexTolerances</span>
<span class="cm">    ON_Brep::SetTrimTolerances</span>
<span class="cm">    ON_Brep::SetEdgeTolerances</span>
<span class="cm">    ON_Brep::SetTolerancesAndFlags</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetVertexTolerances</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the brep&#39;s trim tolerances.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bLazy - [in] if true, only trim tolerances with the value</span>
<span class="cm">       ON_UNSET_VALUE will be set.  If false, the trim tolerance</span>
<span class="cm">       is recomputed from the geometry in the brep.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if successful.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetVertexTolerance</span>
<span class="cm">    ON_Brep::SetTrimTolerance</span>
<span class="cm">    ON_Brep::SetEdgeTolerance</span>
<span class="cm">    ON_Brep::SetVertexTolerances</span>
<span class="cm">    ON_Brep::SetTrimTolerances</span>
<span class="cm">    ON_Brep::SetEdgeTolerances</span>
<span class="cm">    ON_Brep::SetTolerancesAndFlags</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetTrimTolerances</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the brep&#39;s edge tolerances.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bLazy - [in] if true, only edge tolerances with the value</span>
<span class="cm">       ON_UNSET_VALUE will be set.  If false, the edge tolerance</span>
<span class="cm">       is recomputed from the geometry in the brep.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if successful.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetVertexTolerance</span>
<span class="cm">    ON_Brep::SetTrimTolerance</span>
<span class="cm">    ON_Brep::SetEdgeTolerance</span>
<span class="cm">    ON_Brep::SetVertexTolerances</span>
<span class="cm">    ON_Brep::SetTrimTolerances</span>
<span class="cm">    ON_Brep::SetEdgeTolerances</span>
<span class="cm">    ON_Brep::SetTolerancesAndFlags</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetEdgeTolerances</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the trim parameter space bounding box (trim.m_pbox).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    trim - [in]</span>
<span class="cm">    bLazy - [in] if true and trim.m_pbox is valid, then</span>
<span class="cm">       the box is not set.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if trim ends up with a valid bounding box.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SetTrimBoundingBox</span><span class="p">(</span> <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">trim</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span><span class="o">=</span><span class="nb">false</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the loop parameter space bounding box (loop.m_pbox).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    loop - [in]</span>
<span class="cm">    bLazy - [in] if true and loop trim trim.m_pbox is valid,</span>
<span class="cm">       then that trim.m_pbox is not recalculated.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if loop ends up with a valid bounding box.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SetTrimBoundingBoxes</span><span class="p">(</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span><span class="o">=</span><span class="nb">false</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the loop and trim parameter space bounding boxes</span>
<span class="cm">    for every loop and trim in the face</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face - [in]</span>
<span class="cm">    bLazy - [in] if true and trim trim.m_pbox is valid,</span>
<span class="cm">       then that trim.m_pbox is not recalculated.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if all the face&#39;s loop and trim parameter space bounding</span>
<span class="cm">    boxes are valid.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SetTrimBoundingBoxes</span><span class="p">(</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">face</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span><span class="o">=</span><span class="nb">false</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the loop and trim parameter space bounding boxes</span>
<span class="cm">    for every loop and trim in the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bLazy - [in] if true and trim trim.m_pbox is valid,</span>
<span class="cm">       then that trim.m_pbox is not recalculated.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if all the loop and trim parameter space bounding boxes</span>
<span class="cm">    are valid.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SetTrimBoundingBoxes</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="n">bLazy</span><span class="o">=</span><span class="nb">false</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set tolerances and flags in a brep</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bLazy - [in] if true, only flags and tolerances that are not</span>
<span class="cm">       set will be calculated.</span>
<span class="cm">    bSetVertexTolerances - [in] true to compute vertex.m_tolerance values</span>
<span class="cm">    bSetEdgeTolerances - [in] true to compute edge.m_tolerance values</span>
<span class="cm">    bSetTrimTolerances - [in] true to compute trim.m_tolerance[0,1] values</span>
<span class="cm">    bSetTrimIsoFlags - [in] true to compute trim.m_iso values</span>
<span class="cm">    bSetTrimTypeFlags - [in] true to compute trim.m_type values</span>
<span class="cm">    bSetLoopTypeFlags - [in] true to compute loop.m_type values</span>
<span class="cm">    bSetTrimBoxes - [in] true to compute trim.m_pbox values</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SetVertexTolerance</span>
<span class="cm">    ON_Brep::SetEdgeTolerance</span>
<span class="cm">    ON_Brep::SetTrimTolerance</span>
<span class="cm">    ON_Brep::SetTrimTypeFlags</span>
<span class="cm">    ON_Brep::SetTrimIsoFlags</span>
<span class="cm">    ON_Brep::ComputeLoopType</span>
<span class="cm">    ON_Brep::SetTrimBoundingBox</span>
<span class="cm">    ON_Brep::SetTrimBoundingBoxes</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetTolerancesBoxesAndFlags</span><span class="p">(</span>
       <span class="n">ON_BOOL32</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
       <span class="n">ON_BOOL32</span> <span class="n">bSetVertexTolerances</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
       <span class="n">ON_BOOL32</span> <span class="n">bSetEdgeTolerances</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
       <span class="n">ON_BOOL32</span> <span class="n">bSetTrimTolerances</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
       <span class="n">ON_BOOL32</span> <span class="n">bSetTrimIsoFlags</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
       <span class="n">ON_BOOL32</span> <span class="n">bSetTrimTypeFlags</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
       <span class="n">ON_BOOL32</span> <span class="n">bSetLoopTypeFlags</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
       <span class="n">ON_BOOL32</span> <span class="n">bSetTrimBoxes</span> <span class="o">=</span> <span class="nb">true</span>
       <span class="p">);</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Query Interface</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine how many brep faces reference m_S[surface_index].</span>
<span class="cm">  Parameters:</span>
<span class="cm">    surface_index - [in] index of the surface in m_S[] array</span>
<span class="cm">    max_count - [in] counting stops if max_count &gt; 0 and</span>
<span class="cm">                     at least max_count faces use the surface.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of brep faces that reference the surface.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SurfaceUseCount</span><span class="p">(</span>
              <span class="kt">int</span> <span class="n">surface_index</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">max_count</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span>
              <span class="k">const</span><span class="p">;</span>
  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine how many brep edges reference m_C3[c3_index].</span>
<span class="cm">  Parameters:</span>
<span class="cm">    c3_index - [in] index of the 3d curve in m_C3[] array</span>
<span class="cm">    max_count - [in] counting stops if max_count &gt; 0 and</span>
<span class="cm">                     at least max_count edges use the 3d curve.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of brep edges that reference the 3d curve.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">EdgeCurveUseCount</span><span class="p">(</span>
              <span class="kt">int</span> <span class="n">c3_index</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">max_count</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span>
              <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine how many brep trims reference m_C2[c2_index].</span>
<span class="cm">  Parameters:</span>
<span class="cm">    c2_index - [in] index of the 2d curve in m_C2[] array</span>
<span class="cm">    max_count - [in] counting stops if max_count &gt; 0 and</span>
<span class="cm">                     at least max_count trims use the 2d curve.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of brep trims that reference the 2d curve.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">TrimCurveUseCount</span><span class="p">(</span>
              <span class="kt">int</span> <span class="n">c2_index</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">max_count</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span>
              <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a single 3d curve that traces the entire loop</span>
<span class="cm">  Parameters:</span>
<span class="cm">    loop - [in] loop whose 3d curve should be duplicated</span>
<span class="cm">    bRevCurveIfFaceRevIsTrue - [in] If false, the returned</span>
<span class="cm">       3d curve has an orientation compatible with the</span>
<span class="cm">       2d curve returned by Loop2dCurve().</span>
<span class="cm">       If true and the m_bRev flag of the loop&#39;s face</span>
<span class="cm">       is true, then the returned curve is reversed.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to a 3d ON_Curve.  The caller must delete</span>
<span class="cm">    this curve.</span>
<span class="cm">  */</span>
  <span class="n">ON_Curve</span><span class="o">*</span> <span class="nf">Loop3dCurve</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span><span class="p">,</span>
    <span class="n">ON_BOOL32</span> <span class="n">bRevCurveIfFaceRevIsTrue</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a list of 3d curves that trace the non-seam edge</span>
<span class="cm">    portions of an entire loop</span>
<span class="cm">  Parameters:</span>
<span class="cm">    loop - [in] loop whose 3d curve should be duplicated</span>
<span class="cm">    curve_list - [out] 3d curves are appended to this list</span>
<span class="cm">    bRevCurveIfFaceRevIsTrue - [in] If false, the returned</span>
<span class="cm">       3d curves have an orientation compatible with the</span>
<span class="cm">       2d curve returned by Loop2dCurve().</span>
<span class="cm">       If true and the m_bRev flag of the loop&#39;s face</span>
<span class="cm">       is true, then the returned curves are reversed.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of curves appended to curve_list.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Loop3dCurve</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Curve</span><span class="o">*&gt;&amp;</span> <span class="n">curve_list</span><span class="p">,</span>
    <span class="n">ON_BOOL32</span> <span class="n">bRevCurveIfFaceRevIsTrue</span> <span class="o">=</span> <span class="nb">false</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a 3d curve that traces the entire loop</span>
<span class="cm">  Parameters:</span>
<span class="cm">    loop - [in] loop whose 2d curve should be duplicated</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to a 2d ON_Curve.  The caller must delete</span>
<span class="cm">    this curve.</span>
<span class="cm">  */</span>
  <span class="n">ON_Curve</span><span class="o">*</span> <span class="nf">Loop2dCurve</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine orientation of a brep.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitle table</span>
<span class="cm">    +2     brep is a solid but orientation cannot be computed</span>
<span class="cm">    +1     brep is a solid with outward facing normals</span>
<span class="cm">    -1     brep is a solid with inward facing normals</span>
<span class="cm">     0     brep is not a solid</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The base class implementation returns 2 or 0.  This</span>
<span class="cm">    function is overridden in the Rhino SDK and returns</span>
<span class="cm">    +1, -1, or 0.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::IsSolid</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">int</span> <span class="nf">SolidOrientation</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Test brep to see if it is a solid.  (A &quot;solid&quot; is</span>
<span class="cm">    a closed oriented manifold.)</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true       brep is a solid</span>
<span class="cm">    fals       brep is not a solid</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::SolidOrientation</span>
<span class="cm">    ON_Brep::IsManifold</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsSolid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Test brep to see if it is an oriented manifold.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    pbIsOriented - [in]  if not null, *pbIsOriented is set</span>
<span class="cm">        to true if b-rep is an oriented manifold and false</span>
<span class="cm">        if brep is not an oriented manifold.</span>
<span class="cm">    pbHasBoundary - [in]  if not null, *pbHasBoundary is set</span>
<span class="cm">        to true if b-rep has a boundary edge and false if</span>
<span class="cm">        brep does not have a boundary edge.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true       brep is a manifold</span>
<span class="cm">    fals       brep is not a manifold</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::IsSolid</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsManifold</span><span class="p">(</span> <span class="c1">// returns true if b-rep is an oriented manifold</span>
    <span class="n">ON_BOOL32</span><span class="o">*</span> <span class="n">pbIsOriented</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">ON_BOOL32</span><span class="o">*</span> <span class="n">pbHasBoundary</span> <span class="o">=</span> <span class="nb">NULL</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine if P is inside Brep.  This question only makes sense</span>
<span class="cm">    when the brep is a closed manifold.  This function does not</span>
<span class="cm">    not check for closed or manifold, so result is not valid in</span>
<span class="cm">    those cases.  Intersects a line through P with brep, finds</span>
<span class="cm">    the intersection point Q closest to P, and looks at face</span>
<span class="cm">    normal at Q.  If the point Q is on an edge or the intersection</span>
<span class="cm">    is not transverse at Q, then another line is used.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] 3d point</span>
<span class="cm">    tolerance - [in] 3d distance tolerance used for intersection</span>
<span class="cm">      and determining strict inclusion.</span>
<span class="cm">    bStrictlInside - [in] If bStrictlInside is true, then this</span>
<span class="cm">      function will return false if the distance from P is within</span>
<span class="cm">      tolerance of a brep face.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if P is in, false if not. See parameter bStrictlyIn.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsPointInside</span><span class="p">(</span>
          <span class="n">ON_3dPoint</span> <span class="n">P</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">tolerance</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bStrictlyInside</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="kt">bool</span> <span class="nf">IsSurface</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>      <span class="c1">// returns true if the b-rep has a single face</span>
                               <span class="c1">// and that face is geometrically the same</span>
                               <span class="c1">// as the underlying surface.  I.e., the face</span>
                               <span class="c1">// has trivial trimming.  In this case, the</span>
                               <span class="c1">// surface is m_S[0].</span>
                               <span class="c1">// The flag m_F[0].m_bRev records</span>
                               <span class="c1">// the correspondence between the surface&#39;s</span>
                               <span class="c1">// natural parametric orientation and the</span>
                               <span class="c1">// orientation of the b-rep.</span>


  <span class="kt">bool</span> <span class="nf">FaceIsSurface</span><span class="p">(</span>          <span class="c1">// returns true if the face has a single</span>
         <span class="kt">int</span> <span class="c1">// index of face  // outer boundary and that boundary runs</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>              <span class="c1">// along the edges of the underlying surface.</span>
                               <span class="c1">// In this case the geometry of the surface</span>
                               <span class="c1">// is the same as the geometry of the face.</span>
                               <span class="c1">// If FaceIsSurface() is true, then</span>
                               <span class="c1">// m_S[m_F[face_index].m_si] is the surface.</span>
                               <span class="c1">// The flag m_F[face_index].m_bRev records</span>
                               <span class="c1">// the correspondence between the surface&#39;s</span>
                               <span class="c1">// natural parametric orientation and the</span>
                               <span class="c1">// orientation of face in the b-rep.</span>

  <span class="kt">bool</span> <span class="nf">LoopIsSurfaceBoundary</span><span class="p">(</span>  <span class="c1">// returns true if the loop&#39;s trims all run</span>
         <span class="kt">int</span> <span class="c1">// index of loop  // along the edge&#39;s of the underlying surface&#39;s</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>              <span class="c1">// parameter space.</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Modification Interface</span>

  <span class="c1">//////////</span>
  <span class="c1">// Clears all ON_BrepFace.m_bRev flags by ON_BrepFace::Transpose</span>
  <span class="c1">// on each face with a true m_bRev.</span>
  <span class="kt">bool</span> <span class="nf">FlipReversedSurfaces</span><span class="p">();</span>

  <span class="c1">//////////</span>
  <span class="c1">// Change the domain of a trim&#39;s 2d curve.  This changes only the</span>
  <span class="c1">// parameterization of the 2d trimming curve; the locus of the</span>
  <span class="c1">// 2d trimming curve is not changed.</span>
  <span class="kt">bool</span> <span class="nf">SetTrimDomain</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span> <span class="c1">// index of trim in m_T[] array</span>
         <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">&amp;</span>
         <span class="p">);</span>

  <span class="c1">//////////</span>
  <span class="c1">// Change the domain of an edge.  This changes only the</span>
  <span class="c1">// parameterization of the 3d edge curve; the locus of the</span>
  <span class="c1">// 3d edge curve is not changed.</span>
  <span class="kt">bool</span> <span class="nf">SetEdgeDomain</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span> <span class="c1">// index of edge in m_E[] array</span>
         <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">&amp;</span>
         <span class="p">);</span>

  <span class="c1">// Reverses entire brep orientation of all faces by toggling</span>
  <span class="c1">// value of all face&#39;s ON_BrepFace::m_bRev flag.</span>
  <span class="kt">void</span> <span class="nf">Flip</span><span class="p">();</span>

  <span class="c1">// reverses orientation of a face by toggling ON_BrepFace::m_bRev</span>
  <span class="kt">void</span> <span class="nf">FlipFace</span><span class="p">(</span><span class="n">ON_BrepFace</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// Reverses orientation of trimming loop.</span>
  <span class="c1">// This function is intended to be used by brep experts and does</span>
  <span class="c1">// does NOT modify ON_BrepLoop::m_type.  You should make sure</span>
  <span class="c1">// ON_BrepLoop::m_type jibes with the loop&#39;s direction.  (Outer loops</span>
  <span class="c1">// should be counter-clockwise and inner loops should be clockwise.)</span>
  <span class="c1">// You can use ON_Brep::LoopDirection() to determine the direction of</span>
  <span class="c1">// a loop.</span>
  <span class="kt">void</span> <span class="nf">FlipLoop</span><span class="p">(</span><span class="n">ON_BrepLoop</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// reverses orientation of trimming loop</span>

  <span class="c1">// LoopDirection() examines the 2d trimming curve geometry that defines</span>
  <span class="c1">// the loop and returns</span>
  <span class="c1">//</span>
  <span class="c1">//   @untitled table</span>
  <span class="c1">//   +1    the loop is a counter-clockwise loop.</span>
  <span class="c1">//   -1    the loop is a clockwise loop.</span>
  <span class="c1">//    0    the loop is not a continuous closed loop.</span>
  <span class="c1">//</span>
  <span class="c1">// Since LoopDirection() calculates its result based on the 2d trimming</span>
  <span class="c1">// curve geometry, it can be use to set ON_BrepLoop::m_type to outer/inner</span>
  <span class="c1">// when translating from data definition where this distinction is murky.</span>
  <span class="kt">int</span> <span class="nf">LoopDirection</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sort the face.m_li[] array by loop type</span>
<span class="cm">    (outer, inner, slit, crvonsrf, ptonsrf)</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face - [in/out] face whose m_li[] array should be sorted.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true      success</span>
<span class="cm">    false     failure - no loops or loops with unset loop.m_type</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::ComputeLoopType</span>
<span class="cm">    ON_Brep::LoopDirection</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SortFaceLoops</span><span class="p">(</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">face</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::JoinEdges</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CombineCoincidentVertices</span><span class="p">(</span><span class="n">ON_BrepVertex</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepVertex</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// moves information to first vertex and deletes second</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::JoinEdges</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CombineCoincidentEdges</span><span class="p">(</span><span class="n">ON_BrepEdge</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepEdge</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// moves information to first edge and deletes second</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function.</span>
<span class="cm">    Combines contiguous edges into a single edge.  The edges</span>
<span class="cm">    must share a common vertex, then angle between the edge</span>
<span class="cm">    tangents are the common vertex must be less than or</span>
<span class="cm">    equal to angle_tolerance_radians, and any associated</span>
<span class="cm">    trims must be contiguous in there respective boundaries.</span>
<span class="cm">  Parameters;</span>
<span class="cm">    edge_index0 - [in]</span>
<span class="cm">    edge_index1 - [in]</span>
<span class="cm">    angle_tolerance_radians - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to the new edge or NULL if the edges cannot</span>
<span class="cm">    be combined into a single edge.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The input edges are deleted but are still in the</span>
<span class="cm">    brep&#39;s m_E[] arrays.  Use ON_Brep::Compact to remove</span>
<span class="cm">    the unused edges.</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepEdge</span><span class="o">*</span> <span class="nf">CombineContiguousEdges</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">edge_index0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">edge_iindex1</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">angle_tolerance_radians</span> <span class="o">=</span> <span class="n">ON_PI</span><span class="o">/</span><span class="mf">180.0</span>
    <span class="p">);</span>

  <span class="c1">// These remove a topology piece from a b-rep but do not</span>
  <span class="c1">// rearrange the arrays that hold the brep objects.  The</span>
  <span class="c1">// deleted objects have their indices set to -1.  Deleting</span>
  <span class="c1">// an object that is connected to other objects will</span>
  <span class="c1">// modify thos objects.</span>
  <span class="kt">void</span> <span class="nf">DeleteVertex</span><span class="p">(</span><span class="n">ON_BrepVertex</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">DeleteEdge</span><span class="p">(</span><span class="n">ON_BrepEdge</span><span class="o">&amp;</span> <span class="n">edge</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bDeleteEdgeVertices</span><span class="p">);</span> <span class="c1">// pass true to delete vertices used only by edge</span>
  <span class="kt">void</span> <span class="nf">DeleteTrim</span><span class="p">(</span><span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">trim</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bDeleteTrimEdges</span><span class="p">);</span> <span class="c1">// pass true to delete edges and vertices used only by trim</span>
  <span class="kt">void</span> <span class="nf">DeleteLoop</span><span class="p">(</span><span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="n">loop</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bDeleteLoopEdges</span><span class="p">);</span> <span class="c1">// pass true to delete edges and vertices used only by trim</span>
  <span class="kt">void</span> <span class="nf">DeleteFace</span><span class="p">(</span><span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">face</span><span class="p">,</span> <span class="n">ON_BOOL32</span> <span class="n">bDeleteFaceEdges</span><span class="p">);</span> <span class="c1">// pass true to delete edges and vertices used only by face</span>
  <span class="kt">void</span> <span class="nf">DeleteSurface</span><span class="p">(</span><span class="kt">int</span> <span class="n">s_index</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">Delete2dCurve</span><span class="p">(</span><span class="kt">int</span> <span class="n">c2_index</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">Delete3dCurve</span><span class="p">(</span><span class="kt">int</span> <span class="n">c3_index</span><span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Set m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,</span>
  <span class="c1">//   and m_trim_user.i values of faces of component including</span>
  <span class="c1">//   m_F[face_index] to label. Numbering starts at 1.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   face_index - [in] index of face in component</span>
  <span class="c1">//   label - [in] value for m_*_user.i</span>
  <span class="c1">// Returns:</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   Chases through trim lists of face edges to find adjacent faces.</span>
  <span class="c1">//   Does NOT check for vertex-vertex connections</span>
  <span class="kt">void</span> <span class="nf">LabelConnectedComponent</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">label</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set  m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,</span>
<span class="cm">    and m_trim_user.i values values to distinguish connected components.</span>
<span class="cm">  Parameters:</span>
<span class="cm">  Returns:</span>
<span class="cm">    number of connected components</span>
<span class="cm">  Remarks:</span>
<span class="cm">    For each face in the ith component, sets m_face_user.i to i&gt;0.</span>
<span class="cm">    Chases through trim lists of face edges to find adjacent faces.</span>
<span class="cm">    Numbering starts at 1. Does NOT check for vertex-vertex connections.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::GetConnectedComponents</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">LabelConnectedComponents</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If this brep has two or more connected components,</span>
<span class="cm">    then duplicates of the connected components are appended</span>
<span class="cm">    to the components[] array.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    components - [in] connected components are appended to this array.</span>
<span class="cm">    bDuplicateMeshes - [in] if true, any meshes on this brep are copied</span>
<span class="cm">         to the output breps.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of connected components appended to components[] or zero</span>
<span class="cm">    if this brep has only one connected component.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::GetConnectedComponents</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetConnectedComponents</span><span class="p">(</span>
          <span class="n">ON_SimpleArray</span><span class="o">&lt;</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="o">&gt;&amp;</span> <span class="n">components</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bDuplicateMeshes</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Copy a subset of this brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    subfi_count - [in] length of sub_fi[] array.</span>
<span class="cm">    sub_fi - [in] array of face indices in this</span>
<span class="cm">      brep to copy. (If any values inf sub_fi[]</span>
<span class="cm">      are out of range or if sub_fi[] contains</span>
<span class="cm">      duplicates, this function will return null.)</span>
<span class="cm">    sub_brep - [in] if this pointer is not null,</span>
<span class="cm">      then the subbrep will be created in this</span>
<span class="cm">      class.</span>
<span class="cm">  Returns:</span>
<span class="cm">    If the input is valid, a pointer to the</span>
<span class="cm">    subbrep is returned.  If the input is not</span>
<span class="cm">    valid, null is returned.  The faces in</span>
<span class="cm">    in the subbrep&#39;s m_F array are in the same</span>
<span class="cm">    order as they were specified in sub_fi[].</span>
<span class="cm">  */</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">SubBrep</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">subfi_count</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">sub_fi</span><span class="p">,</span>
    <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">sub_brep</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">///////////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// region topology</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">HasRegionTopology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get region topology information:</span>
<span class="cm">    In order to keep the ON_Brep class efficient, rarely used</span>
<span class="cm">    region topology information is not maintained.  If you</span>
<span class="cm">    require this information, call RegionTopology().</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_BrepRegionTopology</span><span class="o">&amp;</span> <span class="n">RegionTopology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get region topology information:</span>
<span class="cm">    In order to keep the ON_Brep class efficient, rarely used</span>
<span class="cm">    region topology information is not maintained.  If you</span>
<span class="cm">    require this information, call RegionTopology().</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DestroyRegionTopology</span><span class="p">();</span>
  <span class="c1">// Description:</span>
  <span class="c1">//   Duplicate a single brep face.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   face_index - [in] index of face to duplicate</span>
  <span class="c1">//   bDuplicateMeshes - [in] if true, any attached meshes are duplicated</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Single face brep.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,</span>
  <span class="c1">//   and m_trim_user.i values of the returned brep are are set to the</span>
  <span class="c1">//   indices of the objects they duplicate.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Brep::DeleteFace, ON_Brep::ExtractFace</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">DuplicateFace</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span>
    <span class="n">ON_BOOL32</span> <span class="n">bDuplicateMeshes</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Duplicate a a subset of a brep</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   face_count - [in] length of face_index[] array</span>
  <span class="c1">//   face_index - [in] array of face indices</span>
  <span class="c1">//   bDuplicateMeshes - [in] if true, any attached meshes are duplicated</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   A brep made by duplicating the faces listed in the face_index[] array.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,</span>
  <span class="c1">//   and m_trim_user.i values of the returned brep are are set to the</span>
  <span class="c1">//   indices of the objects they duplicate.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Brep::DuplicateFace</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">DuplicateFaces</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">face_count</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">face_index</span><span class="p">,</span>
    <span class="n">ON_BOOL32</span> <span class="n">bDuplicateMeshes</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Extract a face from a brep.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   face_index - [in] index of face to extract</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Single face brep.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Brep::DeleteFace, ON_Brep::DuplicateFace</span>
  <span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ExtractFace</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">face_index</span>
    <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Standardizes the relationship between an ON_BrepEdge</span>
<span class="cm">    and the 3d curve it uses.  When done, the edge will</span>
<span class="cm">    be the only edge that references its 3d curve, the</span>
<span class="cm">    domains of the edge and 3d curve will be the same,</span>
<span class="cm">    and the edge will use the entire locus of the 3d curve.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge_index - [in] index of edge to standardize.</span>
<span class="cm">    bAdjustEnds - [in] if true, move edge curve endpoints to vertices</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StandardizeEdgeCurves</span>
<span class="cm">    ON_Brep::Standardize</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">StandardizeEdgeCurve</span><span class="p">(</span> <span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bAdjustEnds</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user only.  Same as above, but to be used when the edge</span>
<span class="cm">    curve use count is known for the edge.</span>
<span class="cm">    Standardizes the relationship between an ON_BrepEdge</span>
<span class="cm">    and the 3d curve it uses.  When done, the edge will</span>
<span class="cm">    be the only edge that references its 3d curve, the</span>
<span class="cm">    domains of the edge and 3d curve will be the same,</span>
<span class="cm">    and the edge will use the entire locus of the 3d curve.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge_index - [in] index of edge to standardize.</span>
<span class="cm">    bAdjustEnds - [in] if true, move edge curve endpoints to vertices</span>
<span class="cm">    EdgeCurveUse - [in] if &gt; 1, then the edge curve for this edge is used by more than one</span>
<span class="cm">        edge.  if 1, then the edge curve is used only for this edge.</span>
<span class="cm">        If &lt;= 0, then use count is unknown.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StandardizeEdgeCurves</span>
<span class="cm">    ON_Brep::Standardize</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">StandardizeEdgeCurve</span><span class="p">(</span> <span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bAdjustEnds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">EdgeCurveUse</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Standardize all edges in the brep.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bAdjustEnds - [in] if true, move edge curve endpoints to vertices</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StandardizeEdgeCurve</span>
<span class="cm">    ON_Brep::Standardize</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">StandardizeEdgeCurves</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bAdjustEnds</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Standardizes the relationship between an ON_BrepTrim</span>
<span class="cm">    and the 2d curve it uses.  When done, the trim will</span>
<span class="cm">    be the only trim that references its 2d curve, the</span>
<span class="cm">    domains of the trim and 2d curve will be the same,</span>
<span class="cm">    and the trim will use the entire locus of the 2d curve.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    trim_index - [in] index of trim to standardize.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StandardizeTrimCurves</span>
<span class="cm">    ON_Brep::Standardize</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">StandardizeTrimCurve</span><span class="p">(</span> <span class="kt">int</span> <span class="n">trim_index</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Standardize all trims in the brep.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StandardizeTrimCurve</span>
<span class="cm">    ON_Brep::Standardize</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">StandardizeTrimCurves</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Standardizes the relationship between an ON_BrepFace</span>
<span class="cm">    and the 3d surface it uses.  When done, the face will</span>
<span class="cm">    be the only face that references its 3d surface, and</span>
<span class="cm">    the orientations of the face and 3d surface will be</span>
<span class="cm">    the same.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face_index - [in] index of face to standardize.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StardardizeFaceSurfaces</span>
<span class="cm">    ON_Brep::Standardize</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">StandardizeFaceSurface</span><span class="p">(</span> <span class="kt">int</span> <span class="n">face_index</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Standardize all faces in the brep.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StandardizeFaceSurface</span>
<span class="cm">    ON_Brep::Standardize</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">StandardizeFaceSurfaces</span><span class="p">();</span>

  <span class="c1">// misspelled function name is obsolete</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">void</span> <span class="nf">StardardizeFaceSurfaces</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Standardize all trims, edges, and faces in the brep.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    After standardizing, there may be unused curves and surfaces</span>
<span class="cm">    in the brep.  Call ON_Brep::Compact to remove these unused</span>
<span class="cm">    curves and surfaces.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::StandardizeTrimCurves</span>
<span class="cm">    ON_Brep::StandardizeEdgeCurves</span>
<span class="cm">    ON_Brep::StandardizeFaceSurface</span>
<span class="cm">    ON_Brep::Compact</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Standardize</span><span class="p">();</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sometimes the ON_Surface used by a face extends far</span>
<span class="cm">    beyond the face&#39;s outer boundary.  ShrinkSurface uses</span>
<span class="cm">    ON_Surface::Trim to remove portions of the surface that</span>
<span class="cm">    extend beyond the face&#39;s outer boundary loop.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face - [in] face to test and whose surface should be shrunk.</span>
<span class="cm">    DisableSide - [in] This is a bit field.  A set bit indicates not to shrink</span>
<span class="cm">                the surface on a given side.  The default of 0 enables shrinking</span>
<span class="cm">                on all four sides.</span>
<span class="cm">      @table</span>
<span class="cm">      value       meaning</span>
<span class="cm">      0x0001     Dont shrink on the west side of domain.</span>
<span class="cm">      0x0002     Dont shrink on the south side of domain.</span>
<span class="cm">      0x0004     Dont shrink on the east side of domain.</span>
<span class="cm">      0x0008     Dont shrink on the north side of domain.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true        successful</span>
<span class="cm">    false       failure</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If a surface needs to be shrunk it is copied.  After shrinking,</span>
<span class="cm">    you may want to call ON_Brep::CullUnusedSurfaces to remove</span>
<span class="cm">    any unused surfaces.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::ShrinkSurfaces</span>
<span class="cm">    ON_Brep::CullUnusedSurfaces</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ShrinkSurface</span><span class="p">(</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">face</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DisableSide</span><span class="o">=</span><span class="mi">0</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sometimes the ON_Surface used by a face extends far</span>
<span class="cm">    beyond the face&#39;s outer boundary.  ShrinkSurfaces calls</span>
<span class="cm">    ON_Shrink::ShrinkSurface on each face to remove portions</span>
<span class="cm">    of surfaces that extend beyond their face&#39;s outer boundary</span>
<span class="cm">    loop.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true        successful</span>
<span class="cm">    false       failure</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If a surface needs to be shrunk it is copied.  After shrinking,</span>
<span class="cm">    you may want to call ON_Brep::CullUnusedSurfaces to remove</span>
<span class="cm">    any unused surfaces.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::ShrinkSurface</span>
<span class="cm">    ON_Brep::CullUnusedSurfaces</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ShrinkSurfaces</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Uses the CullUnused*() members to delete any unreferenced</span>
<span class="cm">    objects from arrays, reindexes as needed, and shrinks</span>
<span class="cm">    arrays to minimum required size.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::CullUnusedFaces</span>
<span class="cm">    ON_Brep::CullUnusedLoops</span>
<span class="cm">    ON_Brep::CullUnusedTrims</span>
<span class="cm">    ON_Brep::CullUnusedEdges</span>
<span class="cm">    ON_Brep::CullUnusedVertices</span>
<span class="cm">    ON_Brep::CullUnused3dCurves</span>
<span class="cm">    ON_Brep::CullUnused2dCurves</span>
<span class="cm">    ON_Brep::CullUnusedSurfaces</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Compact</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">CullUnusedFaces</span><span class="p">();</span> <span class="c1">// culls faces with m_face_index == -1</span>
  <span class="kt">bool</span> <span class="nf">CullUnusedLoops</span><span class="p">();</span> <span class="c1">// culls loops with m_loop_index == -1</span>
  <span class="kt">bool</span> <span class="nf">CullUnusedTrims</span><span class="p">();</span> <span class="c1">// culls trims with m_trim_index == -1</span>
  <span class="kt">bool</span> <span class="nf">CullUnusedEdges</span><span class="p">();</span> <span class="c1">// culls edges with m_edge_index == -1</span>
  <span class="kt">bool</span> <span class="nf">CullUnusedVertices</span><span class="p">();</span> <span class="c1">// culls vertices with m_vertex_index == -1</span>
  <span class="kt">bool</span> <span class="nf">CullUnused3dCurves</span><span class="p">();</span> <span class="c1">// culls 2d curves not referenced by a trim</span>
  <span class="kt">bool</span> <span class="nf">CullUnused2dCurves</span><span class="p">();</span> <span class="c1">// culls 3d curves not referenced by an edge</span>
  <span class="kt">bool</span> <span class="nf">CullUnusedSurfaces</span><span class="p">();</span> <span class="c1">// culls surfaces not referenced by a face</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Navigation Interface</span>

  <span class="c1">// for moving around loops - returns trim index of prev/next trim in loop</span>
  <span class="kt">int</span> <span class="nf">PrevTrim</span><span class="p">(</span>
        <span class="kt">int</span> <span class="o">//</span> <span class="n">index</span> <span class="n">of</span> <span class="n">current</span> <span class="n">trim</span> <span class="p">(</span><span class="n">m_trim_index</span><span class="p">)</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">NextTrim</span><span class="p">(</span>
        <span class="kt">int</span> <span class="o">//</span> <span class="n">index</span> <span class="n">of</span> <span class="n">current</span> <span class="n">trim</span> <span class="p">(</span><span class="n">m_trim_index</span><span class="p">)</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    This is a simple tool for getting running through the edges</span>
<span class="cm">    that begin and end at a vertex.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    current_edge_index - [in]</span>
<span class="cm">    endi - [in] 0 = use the edge start vertex, 1 = use the edge end vertex</span>
<span class="cm">    prev_endi - [out] 0 if previous edge begins at the vertex,</span>
<span class="cm">                      1 if previous edge ends at the vertex</span>
<span class="cm">  Returns:</span>
<span class="cm">    edge index of the previous edge or -1 if there is only one edge</span>
<span class="cm">    that begins or ends at the vertex.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This is a tool that simplifies searching through the</span>
<span class="cm">    ON_BrepVertex.m_ei[] array.</span>
<span class="cm">    The edges are in no particular order.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::NextEdge</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">PrevEdge</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">current_edge_index</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">endi</span><span class="p">,</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">prev_endi</span> <span class="o">=</span> <span class="nb">NULL</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    This is a simple tool for getting running through the edges</span>
<span class="cm">    that begin and end at a vertex.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    current_edge_index - [in]</span>
<span class="cm">    endi - [in] 0 = use the edge start vertex, 1 = use the edge end vertex</span>
<span class="cm">    next_endi - [out] 0 if next edge begins at the vertex,</span>
<span class="cm">                      1 if next edge ends at the vertex</span>
<span class="cm">  Returns:</span>
<span class="cm">    edge index of the next edge or -1 if there is only one edge</span>
<span class="cm">    that begins or ends at the vertex.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This is a tool that simplifies searching through the</span>
<span class="cm">    ON_BrepVertex.m_ei[] array.</span>
<span class="cm">    The edges are in no particular order.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::NextEdge</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">NextEdge</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">current_edge_index</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">endi</span><span class="p">,</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">next_endi</span> <span class="o">=</span> <span class="nb">NULL</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a brep component from its index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    component_index - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    A const pointer to the component.  Do not delete</span>
<span class="cm">    the returned object.  It points to an object managed</span>
<span class="cm">    by this brep.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::Face</span>
<span class="cm">    ON_Brep::Edge</span>
<span class="cm">    ON_Brep::Loop</span>
<span class="cm">    ON_Brep::Trim</span>
<span class="cm">    ON_Brep::Vertex</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_Geometry</span><span class="o">*</span> <span class="nf">BrepComponent</span><span class="p">(</span>
    <span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get vertex from trim index or component index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    vertex_index - [in] either an index into m_V[] or a component index</span>
<span class="cm">                      of type brep_vertex.</span>
<span class="cm">  Returns:</span>
<span class="cm">    If the index is a valid vertex index or a valid vertex component</span>
<span class="cm">    index, then a pointer to the ON_BrepVertex is returned.  Otherwise</span>
<span class="cm">    NULL is returned.</span>
<span class="cm">  See Also</span>
<span class="cm">    ON_Brep::Component( const ON_BrepVertex&amp; )</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepVertex</span><span class="o">*</span> <span class="nf">Vertex</span><span class="p">(</span> <span class="kt">int</span> <span class="n">vertex_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BrepVertex</span><span class="o">*</span> <span class="nf">Vertex</span><span class="p">(</span> <span class="n">ON_COMPONENT_INDEX</span> <span class="n">vertex_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get edge from edge index or component index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge_index - [in] either an index into m_E[] or a component index</span>
<span class="cm">                      of type brep_edge.</span>
<span class="cm">  Returns:</span>
<span class="cm">    If the index is a valid edge index or a valid edge component</span>
<span class="cm">    index, then a pointer to the ON_BrepEdge is returned.  Otherwise</span>
<span class="cm">    NULL is returned.</span>
<span class="cm">  See Also</span>
<span class="cm">    ON_Brep::Component( const ON_BrepEdge&amp; )</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepEdge</span><span class="o">*</span> <span class="nf">Edge</span><span class="p">(</span> <span class="kt">int</span> <span class="n">edge_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BrepEdge</span><span class="o">*</span> <span class="nf">Edge</span><span class="p">(</span> <span class="n">ON_COMPONENT_INDEX</span> <span class="n">edge_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get trim from trim index or component index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    trim_index - [in] either an index into m_T[] or a component index</span>
<span class="cm">                      of type brep_trim.</span>
<span class="cm">  Returns:</span>
<span class="cm">    If the index is a valid trim index or a valid trim component</span>
<span class="cm">    index, then a pointer to the ON_BrepTrim is returned.  Otherwise</span>
<span class="cm">    NULL is returned.</span>
<span class="cm">  See Also</span>
<span class="cm">    ON_Brep::Component( const ON_BrepTrim&amp; )</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepTrim</span><span class="o">*</span> <span class="nf">Trim</span><span class="p">(</span> <span class="kt">int</span> <span class="n">trim_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BrepTrim</span><span class="o">*</span> <span class="nf">Trim</span><span class="p">(</span> <span class="n">ON_COMPONENT_INDEX</span> <span class="n">trim_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get loop from loop index or component index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    loop_index - [in] either an index into m_L[] or a component index</span>
<span class="cm">                      of type brep_loop.</span>
<span class="cm">  Returns:</span>
<span class="cm">    If the index is a valid loop index or a valid loop component</span>
<span class="cm">    index, then a pointer to the ON_BrepLoop is returned.  Otherwise</span>
<span class="cm">    NULL is returned.</span>
<span class="cm">  See Also</span>
<span class="cm">    ON_Brep::Component( const ON_BrepLoop&amp; )</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepLoop</span><span class="o">*</span> <span class="nf">Loop</span><span class="p">(</span> <span class="kt">int</span> <span class="n">loop_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BrepLoop</span><span class="o">*</span> <span class="nf">Loop</span><span class="p">(</span> <span class="n">ON_COMPONENT_INDEX</span> <span class="n">loop_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get face from face index or component index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    face_index - [in] either an index into m_F[] or a component index</span>
<span class="cm">                      of type brep_face.</span>
<span class="cm">  Returns:</span>
<span class="cm">    If the index is a valid face index or a valid face component</span>
<span class="cm">    index, then a pointer to the ON_BrepFace is returned.  Otherwise</span>
<span class="cm">    NULL is returned.</span>
<span class="cm">  See Also</span>
<span class="cm">    ON_Brep::Component( const ON_BrepFace&amp; )</span>
<span class="cm">  */</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">Face</span><span class="p">(</span> <span class="kt">int</span> <span class="n">face_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BrepFace</span><span class="o">*</span> <span class="nf">Face</span><span class="p">(</span> <span class="n">ON_COMPONENT_INDEX</span> <span class="n">face_index</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    remove slit trims and slit boundaries from each face.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if any slits were removed</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Caller should call Compact() afterwards.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">RemoveSlits</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    remove slit trims and slit boundaries from a face.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    F - [in] brep face</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if any slits were removed</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Caller should call Compact() when done.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">RemoveSlits</span><span class="p">(</span><span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If fid0 != fid1 and m_F[fid0] and m_F[fid1] have the same surface (m_si is identical),</span>
<span class="cm">    and they are joined along a set of edges that do not have any other faces, then this will</span>
<span class="cm">    combine the two faces into one.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fid0, fid1 - [in] indices into m_F of faces to be merged.</span>
<span class="cm">  Returns:</span>
<span class="cm">    id of merged face if faces were successfully merged. -1 if not merged.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Caller should call Compact() when done.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">MergeFaces</span><span class="p">(</span><span class="kt">int</span> <span class="n">fid0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fid1</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Merge all possible faces that have the same m_si</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if any faces were successfully merged.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Caller should call Compact() when done.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">MergeFaces</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Removes nested polycurves from the m_C2[] and m_C3[] arrays.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bExtractSingleSegments - [in] if true, polycurves with a</span>
<span class="cm">      single segment are replaced with the segment curve.</span>
<span class="cm">    bEdges - [in] if true, the m_C3[] array is processed</span>
<span class="cm">    bTrimCurves - [in] if true, the m_C2[] array is processed.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if any nesting was removed and false if no nesting</span>
<span class="cm">    was removed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">RemoveNesting</span><span class="p">(</span>
          <span class="kt">bool</span> <span class="n">bExtractSingleSegments</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bEdges</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bTrimCurves</span> <span class="o">=</span> <span class="nb">true</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool to collapse a &quot;short&quot; edge to a vertex.</span>
<span class="cm">    The edge is removed and the topology is repaired</span>
<span class="cm">    so that everything that used to connect to the edge</span>
<span class="cm">    connects the specified vertex.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge_index - [in] index of edge to remove</span>
<span class="cm">    bCloseTrimGap - [in] if true and the removal of the</span>
<span class="cm">       edge creates a gap in the parameter space trimming</span>
<span class="cm">       loop, then the 2d trim curves will be adjusted to</span>
<span class="cm">       close the gap.</span>
<span class="cm">    vertex_index - [in] if &gt;= 0, this the edge is collapsed</span>
<span class="cm">       to this vertex.  Otherwise a vertex is automatically</span>
<span class="cm">       selected or created.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if edge was successfully collapsed.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    After you finish cleaning up the brep, you need</span>
<span class="cm">    to call ON_Brep::Compact() to remove unused edge,</span>
<span class="cm">    trim, and vertex information from the brep&#39;s m_E[],</span>
<span class="cm">    m_V[], m_T[], m_C2[], and m_C3[] arrays.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CollapseEdge</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bCloseTrimGap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">vertex_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool to move trims and edges from</span>
<span class="cm">    one vertex to another.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    old_vi - [in] index of old vertex</span>
<span class="cm">    new_vi - [in] index of new vertex</span>
<span class="cm">    bClearTolerances - [in] if true, then tolerances of</span>
<span class="cm">       edges and trims that are connected ot the old</span>
<span class="cm">       vertex are set to ON_UNSET_VALUE.</span>
<span class="cm">    vertex_index - [in] if &gt;= 0, this the edge is collapsed</span>
<span class="cm">       to this vertex.  Otherwise a vertex is automatically</span>
<span class="cm">       selected or created.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    After you finish cleaning up the brep, you need</span>
<span class="cm">    to call ON_Brep::Compact() to remove unused edge,</span>
<span class="cm">    trim, and vertex information from the brep&#39;s m_E[],</span>
<span class="cm">    m_V[], m_T[], m_C2[], and m_C3[] arrays.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ChangeVertex</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">old_vi</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">new_vi</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bClearTolerances</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool to remove any gap between adjacent trims.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    trim0 - [in]</span>
<span class="cm">    trim1 - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The trims must be in the same trimming loop.  The vertex</span>
<span class="cm">    at the end of trim0 must be the same as the vertex at</span>
<span class="cm">    the start of trim1.  The trim&#39;s m_iso and m_type flags</span>
<span class="cm">    need to be correctly set.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CloseTrimGap</span><span class="p">(</span>
    <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">trim0</span><span class="p">,</span>
    <span class="n">ON_BrepTrim</span><span class="o">&amp;</span> <span class="n">trim1</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Remove edges that are not connected to a face.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bDeleteVertices - [in] if true, then the vertices</span>
<span class="cm">      at the ends of the wire edges are deleted if</span>
<span class="cm">      they are not connected to face trimming edges.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of edges that were removed.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    After you finish cleaning up the brep, you need</span>
<span class="cm">    to call ON_Brep::Compact() to remove unused edge,</span>
<span class="cm">    trim, and vertex information from the brep&#39;s m_E[],</span>
<span class="cm">    m_V[], m_T[], m_C2[], and m_C3[] arrays.</span>

<span class="cm">    If you want to remove wire edges and wiere</span>
<span class="cm">    After you finish cleaning up the brep, you need</span>
<span class="cm">    to call ON_Brep::Compact() to remove deleted vertices</span>
<span class="cm">    from the m_V[] array.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::RemoveWireVertices</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">RemoveWireEdges</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDeleteVertices</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Remove vertices that are not connected to an edge.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of vertices that were deleted.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    After you finish cleaning up the brep, you need</span>
<span class="cm">    to call ON_Brep::Compact() to remove deleted</span>
<span class="cm">    vertices from the m_V[] array.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Brep::RemoveWireEdges</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">RemoveWireVertices</span><span class="p">();</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// &quot;Expert&quot; Interface</span>

  <span class="kt">void</span> <span class="nf">Set_user</span><span class="p">(</span><span class="n">ON_U</span> <span class="n">u</span><span class="p">);</span> <span class="c1">// set every brep m_*_user value to u</span>
  <span class="kt">void</span> <span class="nf">Clear_vertex_user_i</span><span class="p">();</span> <span class="c1">// zero all brep&#39;s m_vertex_user values</span>
  <span class="kt">void</span> <span class="nf">Clear_edge_user_i</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>   <span class="c1">// zero all brep&#39;s m_edge_user values</span>
  <span class="kt">void</span> <span class="nf">Clear_edge_user_i</span><span class="p">();</span>   <span class="c1">// zero all brep&#39;s m_edge_user values</span>
  <span class="kt">void</span> <span class="nf">Clear_trim_user_i</span><span class="p">();</span>   <span class="c1">// zero all brep&#39;s m_trim_user values</span>
  <span class="kt">void</span> <span class="nf">Clear_loop_user_i</span><span class="p">();</span>   <span class="c1">// zero all brep&#39;s m_loop_user values</span>
  <span class="kt">void</span> <span class="nf">Clear_face_user_i</span><span class="p">();</span>   <span class="c1">// zero all brep&#39;s m_face_user values</span>
  <span class="kt">void</span> <span class="nf">Clear_user_i</span><span class="p">();</span>        <span class="c1">// zero all brep&#39;s m_*_user values</span>

  <span class="c1">// Union available for application use.</span>
  <span class="c1">// The constructor zeros m_brep_user.</span>
  <span class="c1">// The value is of m_brep_user is not saved in 3DM</span>
  <span class="c1">// archives and may be changed by some computations.</span>
  <span class="n">ON_U</span> <span class="n">m_brep_user</span><span class="p">;</span>

  <span class="c1">// geometry</span>
  <span class="c1">// (all geometry is deleted by ~ON_Brep().  Pointers can be NULL</span>
  <span class="c1">// or not referenced.  Use Compact() to remove unreferenced geometry.</span>
  <span class="n">ON_CurveArray</span>   <span class="n">m_C2</span><span class="p">;</span>  <span class="c1">// Pointers to parameter space trimming curves</span>
                         <span class="c1">// (used by trims).</span>
  <span class="n">ON_CurveArray</span>   <span class="n">m_C3</span><span class="p">;</span>  <span class="c1">// Pointers to 3d curves (used by edges).</span>
  <span class="n">ON_SurfaceArray</span> <span class="n">m_S</span><span class="p">;</span>   <span class="c1">// Pointers to parametric surfaces (used by faces)</span>

  <span class="c1">// topology</span>
  <span class="c1">// (all topology is deleted by ~ON_Brep().  Objects can be unreferenced.</span>
  <span class="c1">// Use Compact() to to remove unreferenced geometry.</span>
  <span class="n">ON_BrepVertexArray</span>  <span class="n">m_V</span><span class="p">;</span>   <span class="c1">// vertices</span>
  <span class="n">ON_BrepEdgeArray</span>    <span class="n">m_E</span><span class="p">;</span>   <span class="c1">// edges</span>
  <span class="n">ON_BrepTrimArray</span>    <span class="n">m_T</span><span class="p">;</span>   <span class="c1">// trims</span>
  <span class="n">ON_BrepLoopArray</span>    <span class="n">m_L</span><span class="p">;</span>   <span class="c1">// loops</span>
  <span class="n">ON_BrepFaceArray</span>    <span class="n">m_F</span><span class="p">;</span>   <span class="c1">// faces</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_BrepFace</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_BrepRegion</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_BrepFaceSide</span><span class="p">;</span>
  <span class="n">ON_BoundingBox</span> <span class="n">m_bbox</span><span class="p">;</span>

  <span class="c1">// Never directly set m_is_solid, use calls to IsSolid() and/or</span>
  <span class="c1">// SolidOrientation() when you need to know the answer to this</span>
  <span class="c1">// question.</span>
  <span class="c1">// 0 = unset</span>
  <span class="c1">// 1 = solid with normals pointing out</span>
  <span class="c1">// 2 = solid with normals pointing in</span>
  <span class="c1">// 3 = not solid</span>
  <span class="kt">int</span> <span class="n">m_is_solid</span><span class="p">;</span>

  <span class="c1">// These are friends so legacy tol values stored in v1 3dm files</span>
  <span class="c1">// can be used to set brep edge and trimming tolerances with a call</span>
  <span class="c1">// to ON_Brep::SetTolsFromLegacyValues().</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">ON_BinaryArchive</span><span class="o">::</span><span class="n">ReadV1_TCODE_LEGACY_FAC</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">ON_BinaryArchive</span><span class="o">::</span><span class="n">ReadV1_TCODE_LEGACY_SHL</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">Initialize</span><span class="p">();</span>

  <span class="c1">// helpers to set ON_BrepTrim::m_iso flag</span>
  <span class="kt">void</span> <span class="nf">SetTrimIsoFlag</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
  <span class="kt">void</span> <span class="nf">SetTrimIsoFlag</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="c1">// helpers to create and set vertices</span>
  <span class="kt">bool</span> <span class="nf">SetEdgeVertex</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">HopAcrossEdge</span><span class="p">(</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">SetTrimStartVertex</span><span class="p">(</span> <span class="k">const</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">SetLoopVertices</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">ClearTrimVertices</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">ClearEdgeVertices</span><span class="p">();</span>

  <span class="c1">// helpers for SwapFaceParameters()</span>
  <span class="kt">bool</span> <span class="nf">SwapLoopParameters</span><span class="p">(</span>
        <span class="kt">int</span> <span class="c1">// index of loop</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SwapTrimParameters</span><span class="p">(</span>
        <span class="kt">int</span> <span class="c1">// index of trim</span>
        <span class="p">);</span>

  <span class="c1">// helpers for validation checking</span>
  <span class="kt">bool</span> <span class="nf">IsValidTrim</span><span class="p">(</span><span class="kt">int</span> <span class="n">trim_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidTrimTopology</span><span class="p">(</span><span class="kt">int</span> <span class="n">trim_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidTrimGeometry</span><span class="p">(</span><span class="kt">int</span> <span class="n">trim_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidTrimTolerancesAndFlags</span><span class="p">(</span><span class="kt">int</span> <span class="n">trim_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">IsValidLoop</span><span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidLoopTopology</span><span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidLoopGeometry</span><span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidLoopTolerancesAndFlags</span><span class="p">(</span><span class="kt">int</span> <span class="n">loop_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">IsValidFace</span><span class="p">(</span><span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidFaceTopology</span><span class="p">(</span><span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidFaceGeometry</span><span class="p">(</span><span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidFaceTolerancesAndFlags</span><span class="p">(</span><span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">IsValidEdge</span><span class="p">(</span><span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidEdgeTopology</span><span class="p">(</span><span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidEdgeGeometry</span><span class="p">(</span><span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidEdgeTolerancesAndFlags</span><span class="p">(</span><span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">IsValidVertex</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidVertexTopology</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidVertexGeometry</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValidVertexTolerancesAndFlags</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex_index</span><span class="p">,</span><span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">SetTolsFromLegacyValues</span><span class="p">();</span>

  <span class="c1">// read helpers to support various versions</span>
  <span class="kt">bool</span> <span class="nf">ReadOld100</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// reads legacy old RhinoIO toolkit b-rep</span>
  <span class="kt">bool</span> <span class="nf">ReadOld101</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// reads legacy Rhino 1.1 b-rep</span>
  <span class="kt">bool</span> <span class="nf">ReadOld200</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span> <span class="c1">// reads legacy trimmed surface</span>
  <span class="n">ON_Curve</span><span class="o">*</span> <span class="nf">Read100_BrepCurve</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_Surface</span><span class="o">*</span> <span class="nf">Read100_BrepSurface</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// helpers for reading legacy v1 trimmed surfaces and breps</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_LegacyTrimStuff</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_LegacyTrim</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepLoop</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_LegacyLoopStuff</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_LegacyLoop</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_LegacyFaceStuff</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_LegacyShellStuff</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
<span class="p">};</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// brep construction tools</span>
<span class="c1">//</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Create a brep representation of a mesh.</span>
<span class="cm">Parameters:</span>
<span class="cm">  mesh_topology - [in]</span>
<span class="cm">  bTrimmedTriangles - [in] if true, triangles in the mesh</span>
<span class="cm">     will be represented by trimmed planes in the brep.</span>
<span class="cm">     If false, triangles in the mesh will be represented by</span>
<span class="cm">     untrimmed singular bilinear NURBS surfaces in the brep.</span>
<span class="cm">  pBrep - [in] If not NULL, this the mesh representation will</span>
<span class="cm">     be put into this brep.</span>
<span class="cm">Example:</span>

<span class="cm">          ON_Mesh mesh = ...;</span>
<span class="cm">          ON_Brep* pBrep = ON_BrepFromMesh( mesh.Topology() );</span>
<span class="cm">          ...</span>
<span class="cm">          delete pBrep;</span>

<span class="cm">See Also</span>
<span class="cm">  ON_BrepFromMesh( const ON_Mesh&amp; mesh, ... );</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepFromMesh</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_MeshTopology</span><span class="o">&amp;</span> <span class="n">mesh_topology</span><span class="p">,</span>
          <span class="n">ON_BOOL32</span> <span class="n">bTrimmedTriangles</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
          <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep definition of a box.</span>
<span class="cm">Parameters:</span>
<span class="cm">  box_corners - [in] 8 points defining the box corners</span>
<span class="cm">     arranged as the vN lables indicate.</span>

<span class="cm">          v7_______e6_____v6</span>
<span class="cm">           |\             |\</span>
<span class="cm">           | e7           | e5</span>
<span class="cm">           |  \ ______e4_____\</span>
<span class="cm">          e11  v4         |   v5</span>
<span class="cm">           |   |        e10   |</span>
<span class="cm">           |   |          |   |</span>
<span class="cm">          v3---|---e2----v2   e9</span>
<span class="cm">           \   e8         \   |</span>
<span class="cm">            e3 |           e1 |</span>
<span class="cm">             \ |            \ |</span>
<span class="cm">              \v0_____e0_____\v1</span>

<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the box with topology</span>

<span class="cm">   edge              vertices</span>
<span class="cm">    m_E[ 0]           m_V[0], m_V[1]</span>
<span class="cm">    m_E[ 1]           m_V[1], m_V[2]</span>
<span class="cm">    m_E[ 2]           m_V[2], m_V[3]</span>
<span class="cm">    m_E[ 3]           m_V[3], m_V[0]</span>
<span class="cm">    m_E[ 4]           m_V[4], m_V[5]</span>
<span class="cm">    m_E[ 5]           m_V[5], m_V[6]</span>
<span class="cm">    m_E[ 6]           m_V[6], m_V[7]</span>
<span class="cm">    m_E[ 7]           m_V[7], m_V[4]</span>
<span class="cm">    m_E[ 8]           m_V[0], m_V[4]</span>
<span class="cm">    m_E[ 9]           m_V[1], m_V[5]</span>
<span class="cm">    m_E[10]           m_V[2], m_V[6]</span>
<span class="cm">    m_E[11]           m_V[3], m_V[7]</span>

<span class="cm">   face              boundary edges</span>
<span class="cm">    m_F[0]            +m_E[0] +m_E[9]  -m_E[4] -m_E[8]</span>
<span class="cm">    m_F[1]            +m_E[1] +m_E[10] -m_E[5] -m_E[9]</span>
<span class="cm">    m_F[2]            +m_E[2] +m_E[11] -m_E[6] -m_E[10]</span>
<span class="cm">    m_F[3]            +m_E[3] +m_E[8]  -m_E[7] -m_E[11]</span>
<span class="cm">    m_F[4]            -m_E[3] -m_E[2]  -m_E[1] -m_E[0]</span>
<span class="cm">//     m_F[5]            +m_E[4] +m_E[5]  +m_E[6] +m_E[7]</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepBox</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">box_corners</span><span class="p">,</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep definition of a wedge.</span>
<span class="cm">Parameters:</span>
<span class="cm">  corners - [in] 6 points defining the box corners</span>
<span class="cm">     arranged as the vN lables indicate.</span>

<span class="cm">                     /v5</span>
<span class="cm">                    /|\</span>
<span class="cm">                   / | \</span>
<span class="cm">                  e5 |  e4</span>
<span class="cm">                 /   e8  \</span>
<span class="cm">                /__e3_____\</span>
<span class="cm">              v3|    |    |v4</span>
<span class="cm">                |    |    |</span>
<span class="cm">                |    /v2  |</span>
<span class="cm">                e6  / \   e7</span>
<span class="cm">                |  /   \  |</span>
<span class="cm">                | e2    e1|</span>
<span class="cm">                |/       \|</span>
<span class="cm">                /____e0___\</span>
<span class="cm">              v0           v1</span>

<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the wedge with topology</span>

<span class="cm">  edge              vertices</span>
<span class="cm">    m_E[ 0]           m_V[0], m_V[1]</span>
<span class="cm">    m_E[ 1]           m_V[1], m_V[2]</span>
<span class="cm">    m_E[ 2]           m_V[2], m_V[0]</span>
<span class="cm">    m_E[ 3]           m_V[3], m_V[4]</span>
<span class="cm">    m_E[ 4]           m_V[4], m_V[5]</span>
<span class="cm">    m_E[ 5]           m_V[5], m_V[0]</span>
<span class="cm">    m_E[ 6]           m_V[0], m_V[3]</span>
<span class="cm">    m_E[ 7]           m_V[1], m_V[4]</span>
<span class="cm">    m_E[ 8]           m_V[2], m_V[5]</span>

<span class="cm">  face              boundary edges</span>
<span class="cm">    m_F[0]            +m_E[0] +m_E[7]  -m_E[3] -m_E[6]</span>
<span class="cm">    m_F[1]            +m_E[1] +m_E[8]  -m_E[4] -m_E[7]</span>
<span class="cm">    m_F[2]            +m_E[2] +m_E[6]  -m_E[5] -m_E[8]</span>
<span class="cm">    m_F[3]            +m_E[3] +m_E[8]  -m_E[7] -m_E[11]</span>
<span class="cm">    m_F[4]            -m_E[2]  -m_E[1] -m_E[0]</span>
<span class="cm">    m_F[5]            +m_E[3] +m_E[4]  +m_E[5]</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepWedge</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">corners</span><span class="p">,</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep definition of a sphere.</span>
<span class="cm">Parameters:</span>
<span class="cm">  sphere - [in]</span>
<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the sphere with a single face,</span>
<span class="cm">  a single edge along the seam, and vertices at the north</span>
<span class="cm">  and south poles.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepSphere</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Sphere</span><span class="o">&amp;</span> <span class="n">sphere</span><span class="p">,</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep definition of a torus.</span>
<span class="cm">Parameters:</span>
<span class="cm">  torus - [in]</span>
<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the torus with a single face</span>
<span class="cm">  a two edges along the seams.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepTorus</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Torus</span><span class="o">&amp;</span> <span class="n">torus</span><span class="p">,</span> <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep definition of a cylinder.</span>
<span class="cm">Parameters:</span>
<span class="cm">  cylinder - [in] cylinder.IsFinite() must be true</span>
<span class="cm">  bCapBottom - [in] if true end at cylinder.m_height[0] should be capped</span>
<span class="cm">  bCapTop - [in] if true end at cylinder.m_height[1] should be capped</span>
<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the cylinder with a single</span>
<span class="cm">  face for the cylinder, an edge along the cylinder seam,</span>
<span class="cm">  and vertices at the bottom and top ends of this seam edge.</span>
<span class="cm">  The optional bottom/top caps are single faces with one</span>
<span class="cm">  circular edge starting and ending at the bottom/top vertex.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepCylinder</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Cylinder</span><span class="o">&amp;</span> <span class="n">cylinder</span><span class="p">,</span>
                          <span class="n">ON_BOOL32</span> <span class="n">bCapBottom</span><span class="p">,</span>
                          <span class="n">ON_BOOL32</span> <span class="n">bCapTop</span><span class="p">,</span>
                          <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep definition of a cone.</span>
<span class="cm">Parameters:</span>
<span class="cm">  cylinder - [in] cylinder.IsFinite() must be true</span>
<span class="cm">  bCapBase - [in] if true the base of the cone should be capped.</span>
<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the cone with a single</span>
<span class="cm">  face for the cone, an edge along the cone seam,</span>
<span class="cm">  and vertices at the base and apex ends of this seam edge.</span>
<span class="cm">  The optional cap is asingle face with one circular edge</span>
<span class="cm">  starting and ending at the base vertex.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepCone</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_Cone</span><span class="o">&amp;</span> <span class="n">cone</span><span class="p">,</span>
          <span class="n">ON_BOOL32</span> <span class="n">bCapBottom</span><span class="p">,</span>
          <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep form of a surface of revolution.</span>
<span class="cm">Parameters:</span>
<span class="cm">  pRevSurface - [in] pointer to a surface of revolution.</span>
<span class="cm">     The brep will manage this pointer and delete it in ~ON_Brep.</span>
<span class="cm">  bCapStart - [in] if true, the start of the revolute is</span>
<span class="cm">     not on the axis of revolution, and the surface of revolution</span>
<span class="cm">     is closed, then a circular cap will be added to close</span>
<span class="cm">     of the hole at the start of the revolute.</span>
<span class="cm">  bCapEnd - [in] if true, the end of the revolute is</span>
<span class="cm">     not on the axis of revolution, and the surface of revolution</span>
<span class="cm">     is closed, then a circular cap will be added to close</span>
<span class="cm">     of the hole at the end of the revolute.</span>
<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  true     successful</span>
<span class="cm">  false    brep cannot be created from this surface.</span>
<span class="cm">Remarks:</span>
<span class="cm">  The surface class must be created with new because</span>
<span class="cm">  it will be destroyed with the delete operator</span>
<span class="cm">  in ~ON_Brep.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepRevSurface</span><span class="p">(</span>
          <span class="n">ON_RevSurface</span><span class="o">*&amp;</span> <span class="n">pRevSurface</span><span class="p">,</span>
          <span class="n">ON_BOOL32</span> <span class="n">bCapStart</span><span class="p">,</span>
          <span class="n">ON_BOOL32</span> <span class="n">bCapEnd</span><span class="p">,</span>
          <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span>
          <span class="p">);</span>



<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Create an ON_Brep trimmed plane.</span>
<span class="cm">Parameters:</span>
<span class="cm">  plane - [in] plane that will be trimmed.</span>
<span class="cm">  boundary - [in] a simple (no self intersections) closed</span>
<span class="cm">      curve that defines the outer boundary of the trimmed</span>
<span class="cm">      plane.  This curve is copied for use in the brep.</span>
<span class="cm">  pBrep - [in] if not NULL, this brep will be used and returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the trimmed plane with a single face.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_Brep::NewPlanarFaceLoop()</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepTrimmedPlane</span><span class="p">(</span>
            <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">&amp;</span> <span class="n">boundary</span><span class="p">,</span>
            <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Get an ON_Brep definition of a trimmed plane.</span>
<span class="cm">Parameters:</span>
<span class="cm">  plane - [in] plane that will be trimmed.</span>
<span class="cm">  boundary - [in] a list of 3d curves that form a simple</span>
<span class="cm">      (no self intersections) closed curve that defines the</span>
<span class="cm">      outer boundary of the trimmed plane.</span>
<span class="cm">  bDuplicateCurves - [in] if true, duplicates of the</span>
<span class="cm">       curves in the boundary array are used in the brep.  If false</span>
<span class="cm">       the curves in the boundary array are used in the brep</span>
<span class="cm">       and the brep&#39;s destructor will delete the curves.</span>
<span class="cm">  pBrep - [in] if not NULL, this brep will be used and</span>
<span class="cm">               returned.</span>
<span class="cm">Returns:</span>
<span class="cm">  An ON_Brep representation of the trimmed plane with a singe face.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_Brep::NewPlanarFaceLoop()</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_BrepTrimmedPlane</span><span class="p">(</span>
            <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
            <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Curve</span><span class="o">*&gt;&amp;</span> <span class="n">boundary</span><span class="p">,</span>
            <span class="n">ON_BOOL32</span> <span class="n">bDuplicateCurves</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
            <span class="n">ON_Brep</span><span class="o">*</span> <span class="n">pBrep</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Extrude a brep</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  path_curve - [in] path to extrude along.</span>
<span class="cm">  bCap - [in] if true, the extusion is capped with a translation</span>
<span class="cm">              of the input brep.</span>
<span class="cm">Returns:</span>
<span class="cm">  True if successful.</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrudeFace</span>
<span class="cm">  ON_BrepExtrudeLoop</span>
<span class="cm">  ON_BrepExtrudeEdge</span>
<span class="cm">  ON_BrepExtrudeVertex</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new faces are appended to brep.m_F[]. It is the caller&#39;s</span>
<span class="cm">  responsibility to insure the result does not self intersect.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_BrepExtrude</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">&amp;</span> <span class="n">path_curve</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bCap</span> <span class="o">=</span> <span class="nb">true</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Extrude a face in a brep.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  face_index - [in] index of face to extrude.</span>
<span class="cm">  path_curve - [in] path to extrude along.</span>
<span class="cm">  bCap - [in] if true, the extusion is capped with a translation</span>
<span class="cm">              of the face being extruded.</span>
<span class="cm">Example:</span>
<span class="cm">  Extrude a face along a vector.</span>

<span class="cm">          ON_Brep brep = ...;</span>
<span class="cm">          int face_index = ...;</span>
<span class="cm">          ON_3dVector v = ...;</span>
<span class="cm">          ON_LineCurve line_curve( ON_Line( ON_origin, vector ) );</span>
<span class="cm">          ON_BrepExtrudeFace( brep, face_index, line_curve, true );</span>

<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  0    failure</span>
<span class="cm">  1    successful - no cap added</span>
<span class="cm">  2    successful - cap added as last face</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrude</span>
<span class="cm">  ON_BrepExtrudeLoop</span>
<span class="cm">  ON_BrepExtrudeEdge</span>
<span class="cm">  ON_BrepExtrudeVertex</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new faces are appended to brep.m_F[].  If a cap is requested</span>
<span class="cm">  it is the last face in the returned brep.m_F[]</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_BrepExtrudeFace</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">&amp;</span> <span class="n">path_curve</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bCap</span> <span class="o">=</span> <span class="nb">true</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Extrude a loop in a brep.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  loop_index - [in] index of face to extrude.</span>
<span class="cm">  path_curve - [in] path to extrude along.</span>
<span class="cm">  bCap - [in] if true and the loop is closed, the extusion</span>
<span class="cm">              is capped.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  0    failure</span>
<span class="cm">  1    successful - no cap added</span>
<span class="cm">  2    successful - cap added as last face</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrude</span>
<span class="cm">  ON_BrepExtrudeFace</span>
<span class="cm">  ON_BrepExtrudeEdge</span>
<span class="cm">  ON_BrepExtrudeVertex</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new faces are appended to brep.m_F[].  If a cap is requested</span>
<span class="cm">  it is the last face in the returned brep.m_F[]</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_BrepExtrudeLoop</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">loop_index</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">&amp;</span> <span class="n">path_curve</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bCap</span> <span class="o">=</span> <span class="nb">true</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Extrude an edge in a brep.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  edge_index - [in] index of face to extrude.</span>
<span class="cm">  path_curve - [in] path to extrude along.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  0    failure</span>
<span class="cm">  1    successful</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrude</span>
<span class="cm">  ON_BrepExtrudeFace</span>
<span class="cm">  ON_BrepExtrudeLoop</span>
<span class="cm">  ON_BrepExtrudeVertex</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new face is appended to brep.m_F[].</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_BrepExtrudeEdge</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">&amp;</span> <span class="n">path_curve</span>
          <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Extrude a vertex in a brep.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  vertex_index - [in] index of vertex to extrude.</span>
<span class="cm">  path_curve - [in] path to extrude along.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  0    failure</span>
<span class="cm">  1    successful</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrude</span>
<span class="cm">  ON_BrepExtrudeFace</span>
<span class="cm">  ON_BrepExtrudeLoop</span>
<span class="cm">  ON_BrepExtrudeEdge</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new vertex is appended to brep.m_V[] and</span>
<span class="cm">  the new edge is appended to brep.m_E[].</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_BrepExtrudeVertex</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">vertex_index</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Curve</span><span class="o">&amp;</span> <span class="n">path_curve</span>
          <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Cone a face in a brep.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  face_index - [in] index of face to extrude.</span>
<span class="cm">  apex_point - [in] apex of cone.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  0    failure</span>
<span class="cm">  1    successful</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrudeFace</span>
<span class="cm">  ON_BrepExtrudeLoop</span>
<span class="cm">  ON_BrepExtrudeEdge</span>
<span class="cm">  ON_BrepExtrudeVertex</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new faces are appended to brep.m_F[].</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_BrepConeFace</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span>
          <span class="n">ON_3dPoint</span> <span class="n">apex_point</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Cone a loop in a brep.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  loop_index - [in] index of face to extrude.</span>
<span class="cm">  apex_point - [in] apex of cone.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  0    failure</span>
<span class="cm">  1    successful</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrudeFace</span>
<span class="cm">  ON_BrepExtrudeLoop</span>
<span class="cm">  ON_BrepExtrudeEdge</span>
<span class="cm">  ON_BrepExtrudeVertex</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new faces are appended to brep.m_F[].</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_BrepConeLoop</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">loop_index</span><span class="p">,</span>
          <span class="n">ON_3dPoint</span> <span class="n">apex_point</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Cone an edge in a brep.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep - [in/out]</span>
<span class="cm">  edge_index - [in] index of face to extrude.</span>
<span class="cm">  apex_point - [in] apex of cone.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  0    failure</span>
<span class="cm">  1    successful</span>
<span class="cm">See Also:</span>
<span class="cm">  ON_BrepExtrudeFace</span>
<span class="cm">  ON_BrepExtrudeLoop</span>
<span class="cm">  ON_BrepExtrudeEdge</span>
<span class="cm">  ON_BrepExtrudeVertex</span>
<span class="cm">  ON_BrepConeFace</span>
<span class="cm">  ON_BrepConeLoop</span>
<span class="cm">  ON_BrepConeEdge</span>
<span class="cm">Remarks:</span>
<span class="cm">  The new face is appended to brep.m_F[].</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_BrepConeEdge</span><span class="p">(</span>
          <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">edge_index</span><span class="p">,</span>
          <span class="n">ON_3dPoint</span> <span class="n">apex_point</span>
          <span class="p">);</span>

<span class="c1">//These merge adjacent faces that have the same underlying surface.</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_BrepMergeFaces</span><span class="p">(</span><span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">B</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fid0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fid1</span><span class="p">);</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_BrepMergeFaces</span><span class="p">(</span><span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">B</span><span class="p">);</span>

<span class="c1">//This removes all slit trims  from F that are not joined to another face.</span>
<span class="c1">//Unlike ON_Brep::RemoveSlits(), this will remove slit pairs from a loop in cases</span>
<span class="c1">//that will result in the creation of more loops. Caller is responsible for calling</span>
<span class="c1">//ON_Brep::Compact() to get rid of deleted trims and loops.</span>

<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_BrepRemoveSlits</span><span class="p">(</span><span class="n">ON_BrepFace</span><span class="o">&amp;</span> <span class="n">F</span><span class="p">);</span>

<span class="c1">//Merges all possible edges</span>
<span class="n">ON_DECL</span>
<span class="kt">void</span> <span class="nf">ON_BrepMergeAllEdges</span><span class="p">(</span><span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">B</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Merges two breps into a single brep.  The</span>
<span class="cm">  result may be non-manifold or have multiple</span>
<span class="cm">  connected components.</span>
<span class="cm">Parameters:</span>
<span class="cm">  brep0 - [in]</span>
<span class="cm">  brep1 - [in]</span>
<span class="cm">  tolerance - [in]</span>
<span class="cm">Returns:</span>
<span class="cm">  Merged brep or NULL if calculation failed.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Brep</span><span class="o">*</span> <span class="nf">ON_MergeBreps</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep0</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Brep</span><span class="o">&amp;</span> <span class="n">brep1</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">tolerance</span>
          <span class="p">);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_circle.h.html" class="btn btn-neutral float-right" title="File opennurbs_circle.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_brep.h.html" class="btn btn-neutral float-left" title="File opennurbs_brep.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>