

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_archive.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_array.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_array.h.html" />
    <link rel="prev" title="File opennurbs_archive.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_archive.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_archive.h.html">File opennurbs_archive.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_archive.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_archive.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-archive-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-archive-h"></span><h1>Program Listing for File opennurbs_archive.h<a class="headerlink" href="#program-listing-for-file-opennurbs-archive-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_archive.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-archive-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_archive.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="cp">#if !defined(ON_ARCHIVE_INC_)</span>
<span class="cp">#define ON_ARCHIVE_INC_</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_FileStream</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fopen().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    filename - [in]</span>
<span class="cm">    mode - [in]</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Use the ON_FileStream static functions for reading, writing,</span>
<span class="cm">    seeking, position finding with the FILE pointer returned</span>
<span class="cm">    by this function.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">Open</span><span class="p">(</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">mode</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fopen().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    filename - [in]</span>
<span class="cm">    mode - [in]</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Use the ON_FileStream static functions for reading, writing,</span>
<span class="cm">    seeking, position finding with the FILE pointer returned</span>
<span class="cm">    by this function.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">FILE</span><span class="o">*</span> <span class="nf">Open</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fclose().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">  Returns:</span>
<span class="cm">       0: successful</span>
<span class="cm">      -1: null fp parameter</span>
<span class="cm">    != 0: fclose() failure code</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">Close</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime ftell().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">  Returns:</span>
<span class="cm">    &gt;= 0: current file position</span>
<span class="cm">      -1: an error occured</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">ON__INT64</span> <span class="nf">CurrentPosition</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fseek(fp,offset,SEEK_CUR).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">    offset - [in]</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SeekFromCurrentPosition</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ON__INT64</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fseek(fp,offset,SEEK_SET).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">    offset - [in]</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SeekFromStart</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ON__INT64</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fseek(fp,offset,SEEK_END).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">    offset - [in]</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SeekFromEnd</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ON__INT64</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fseek(fp,offset,origin).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">    offset - [in]</span>
<span class="cm">    origin - [in]</span>
<span class="cm">      SEEK_SET (0): seek from beginning of file.</span>
<span class="cm">      SEEK_CUR (1): seek from current position of file pointer.</span>
<span class="cm">      SEEK_END (2): seek from end of file.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Seek</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ON__INT64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">orgin</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fread(buffer,1,count,fp).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open()</span>
<span class="cm">    count - [in]</span>
<span class="cm">      number of bytes to read.</span>
<span class="cm">    buffer - [out]</span>
<span class="cm">      read bytes are stored in this buffer</span>
<span class="cm">  Returns:</span>
<span class="cm">    number of bytes read</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">ON__UINT64</span> <span class="nf">Read</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ON__UINT64</span> <span class="n">count</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fwrite(buffer,1,count,fp).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open()</span>
<span class="cm">    count - [in]</span>
<span class="cm">      number of bytes to write</span>
<span class="cm">    buffer - [in]</span>
<span class="cm">      data to be written</span>
<span class="cm">  Returns:</span>
<span class="cm">    number of bytes written.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="n">ON__UINT64</span> <span class="nf">Write</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ON__UINT64</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fflush(fp).</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if flush was successful.  False if an error occured.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Flush</span><span class="p">(</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Portable wrapper for C runtime fstat().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      FILE pointer returned by ON_FileStream::Open().</span>
<span class="cm">    file_size - [out]</span>
<span class="cm">      If file_size is not null, the the size of the file</span>
<span class="cm">      in bytes returned here</span>
<span class="cm">    file_creation_time - [out]</span>
<span class="cm">      If file_creation_time is not null, then the time the file</span>
<span class="cm">      was created is returned here as the number of seconds since</span>
<span class="cm">      midnight January 1, 1970.</span>
<span class="cm">    file_last_modified_time - [out]</span>
<span class="cm">      If file_last_modified_time is not null, then the time the file</span>
<span class="cm">      was last modified is returned here as the number of seconds</span>
<span class="cm">      since midnight January 1, 1970.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if the query was successful.  False if an error occured.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">GetFileInformation</span><span class="p">(</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">,</span>
    <span class="n">ON__UINT64</span><span class="o">*</span> <span class="n">file_size</span><span class="p">,</span>
    <span class="n">ON__UINT64</span><span class="o">*</span> <span class="n">file_create_time</span><span class="p">,</span>
    <span class="n">ON__UINT64</span><span class="o">*</span> <span class="n">file_last_modified_time</span>
    <span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_FileIterator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_FileIterator</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_FileIterator</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Find the first matching file in the directory.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    directory_name - [in]</span>
<span class="cm">      The directory to look in.</span>
<span class="cm">    file_name_filter - [in]</span>
<span class="cm">      If this paramter is null, then the iteration</span>
<span class="cm">      includes all names in the directory.</span>
<span class="cm">      The file name to search for. This parameter can</span>
<span class="cm">      include wildcard characters, such as an</span>
<span class="cm">      asterisk (*) or a question mark (?). For example,</span>
<span class="cm">      &quot;\rootdir\subdir\*.*&quot;  will iterate all files in</span>
<span class="cm">      the \rootdir\subdir\ directory.</span>

<span class="cm">  Example:</span>
<span class="cm">          // Iterate through the files in a directory named &quot;\rootdir\subdir&quot;</span>
<span class="cm">          FILE* fp = 0;</span>
<span class="cm">          ON_FileIterator fit;</span>
<span class="cm">          const char* directory = &quot;\\rootdir\\subdir&quot;;</span>
<span class="cm">          for ( const wchar_t* filename = fit.FirstFile( directory, &quot;*.3dm&quot; );</span>
<span class="cm">                0 != filename;</span>
<span class="cm">                filename = fit.NextFile()</span>
<span class="cm">              )</span>
<span class="cm">          {</span>
<span class="cm">            if ( fit.CurrentFileIsDirectory() )</span>
<span class="cm">              continue;</span>
<span class="cm">            ON_String fullpath = directory;</span>
<span class="cm">            fullpath += &#39;\\&#39;;</span>
<span class="cm">            fullpath += filename;</span>
<span class="cm">            FILE* fp = ON_FileStream::Open(fullpath,&quot;rb&quot;);</span>
<span class="cm">            if ( 0 == fp )</span>
<span class="cm">            {</span>
<span class="cm">              continue;</span>
<span class="cm">            }</span>
<span class="cm">            ...</span>
<span class="cm">            ON_FileStream::Close(fp);</span>
<span class="cm">            fp = 0;</span>
<span class="cm">          }</span>
<span class="cm">        }</span>

<span class="cm">  Returns:</span>
<span class="cm">    NULL if no matching files are present in the directory.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">FirstFile</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">directory_name</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">file_name_filter</span>
    <span class="p">);</span>

  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">FirstFile</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">directory_name</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file_name_filter</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Find the next matching file in the directory.</span>
<span class="cm">  Returns:</span>
<span class="cm">    NULL if no more matching files are present in the directory.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">NextFile</span><span class="p">();</span>

  <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="nf">CurrentFileName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON__UINT64</span> <span class="nf">CurrentFileSize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns</span>
<span class="cm">    true if the current &quot;file&quot; is a directory.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CurrentFileIsDirectory</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns</span>
<span class="cm">    true if the current file or directory is hidden.</span>
<span class="cm">    This means its name begins with a &#39;.&#39; or it&#39;s</span>
<span class="cm">    Windows hidden attribute is true.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CurrentFileIsHidden</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">GetCurrentFullPathFileName</span><span class="p">(</span> <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">filename</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    File creation time in seconds since January 1, 1970</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">CurrentFileCreateTime</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    File last modified time in seconds since January 1, 1970</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">CurrentFileLastModifiedTime</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    File last access time in seconds since January 1, 1970</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">CurrentFileLastAccessTime</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of matching files returned so far.</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">Count</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Used by Windows ::Find</span>
  <span class="n">ON__UINT64</span> <span class="n">m_count</span><span class="p">;</span>
  <span class="n">ON_wString</span> <span class="n">m_directory</span><span class="p">;</span>

<span class="cp">#if defined(ON_COMPILER_MSC)</span>
  <span class="n">ON__UINT32</span> <span class="n">m_file_attributes_mask</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">m_h</span><span class="p">;</span>
  <span class="n">WIN32_FIND_DATA</span> <span class="n">m_fd</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="n">ON_wString</span> <span class="n">m_ws_file_name_filter</span><span class="p">;</span>
  <span class="n">ON_String</span> <span class="n">m_utf8_file_name_filter</span><span class="p">;</span>
  <span class="kt">DIR</span><span class="o">*</span> <span class="n">m_dir</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">dirent</span> <span class="n">m_dirent</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">m_dirent_name_buffer</span><span class="p">[</span><span class="n">NAME_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// &lt; this field provide storage for m_dirent.d_name[]</span>

  <span class="c1">// information about the current file</span>
  <span class="kt">wchar_t</span> <span class="n">m_current_name</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="n">ON__UINT64</span> <span class="n">m_current_file_attributes</span><span class="p">;</span> <span class="c1">// 1 = regular file, 2 = directory</span>
  <span class="n">ON__UINT64</span> <span class="n">m_current_file_size</span><span class="p">;</span>
  <span class="n">ON__UINT64</span> <span class="n">m_current_file_create_time</span><span class="p">;</span>
  <span class="n">ON__UINT64</span> <span class="n">m_current_last_modified_time</span><span class="p">;</span>
  <span class="n">ON__UINT64</span> <span class="n">m_current_last_access_time</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>


<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// ON_Buffer</span>
<span class="c1">//</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ON_Buffer_ErrorHandler</span><span class="p">)(</span><span class="k">class</span> <span class="nc">ON_Buffer</span><span class="o">*</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_Buffer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_Buffer</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_Buffer</span><span class="p">();</span>

  <span class="n">ON_Buffer</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>
  <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Compare contents of buffers.</span>
<span class="cm">  Paramters:</span>
<span class="cm">    a - [in]</span>
<span class="cm">    b - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    -1: a &lt; b</span>
<span class="cm">     0: a == b</span>
<span class="cm">     1: a &gt; b</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">Compare</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if Size() == CurrentPosition().</span>
<span class="cm">  Remarks:</span>
<span class="cm">    It is possible to seek beyond the end of the buffer.</span>
<span class="cm">    In this case, the current position will be past the end</span>
<span class="cm">    of the buffer and AtEnd() will return false.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">AtEnd</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of bytes currently in the buffer.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    It is possible to seek beyond the end of the buffer.</span>
<span class="cm">    In this case, the current position will be past the end</span>
<span class="cm">    of the buffer and CurrentPosition() will be greater than</span>
<span class="cm">    Size().</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">Size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    32-bit CRC of the buffer contents.</span>
<span class="cm">  Remarks:</span>

<span class="cm">  */</span>
  <span class="n">ON__UINT32</span> <span class="nf">CRC32</span><span class="p">(</span> <span class="n">ON__UINT32</span> <span class="n">current_remainder</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Current position in the buffer.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    It is possible to seek beyond the end of the buffer.</span>
<span class="cm">    In this case, the current position will be past the end</span>
<span class="cm">    of the buffer and CurrentPosition() will be greater than</span>
<span class="cm">    Size().</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">CurrentPosition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    size - [in]</span>
<span class="cm">      number of bytes to write.</span>
<span class="cm">    buffer - [in]</span>
<span class="cm">      values to write.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of bytes written buffer.</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    size - [in]</span>
<span class="cm">      number of bytes to read.</span>
<span class="cm">    buffer - [out]</span>
<span class="cm">      read values are returned in buffer.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of bytes read into buffer. For example,</span>
<span class="cm">    if CurrentPosition() &lt;= Size() and</span>
<span class="cm">    size &gt; (Size() - CurrentPosition()) and</span>
<span class="cm">    buffer is not null, then the value</span>
<span class="cm">    (Size() - CurrentPosition()) is returned.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If the size parameter is zero, then nothing is done.</span>
<span class="cm">    When CurrentPosition() &lt;= Size(), attempts to read more</span>
<span class="cm">    than (Size() - CurrentPosition()) bytes do not generate</span>
<span class="cm">    an error. When CurrentPosition() &gt; Size(), any attempt</span>
<span class="cm">    to read generates an error.</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="p">);</span>

  <span class="k">enum</span>
  <span class="p">{</span>
    <span class="n">seek_from_beginning_of_file</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">seek_from_current_position</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">seek_from_end_of_file</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    offset - [in]</span>
<span class="cm">      number of bytes to seek from origin</span>
<span class="cm">    origin - [in]</span>
<span class="cm">      initial position.</span>
<span class="cm">        0 (SEEK_SET) Seek from beginning of file.</span>
<span class="cm">        1 (SEEK_CUR) Seek from current position.</span>
<span class="cm">        2 (SEEK_END) Seek from end of file.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">    False if the seek would result in a file position</span>
<span class="cm">    before the beginning of the file. If false is</span>
<span class="cm">    returned, the current position is not changed.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Seeking beyond the end of the buffer is succeeds.</span>
<span class="cm">    Seeking before the beginning of the buffer fails.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Seek</span><span class="p">(</span>
    <span class="n">ON__INT64</span> <span class="n">offset</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">origin</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    offset - [in] (&gt;= 0)</span>
<span class="cm">      number of bytes to seek from the start of the buffer.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">    False if the seek would result in a file position</span>
<span class="cm">    before the beginning of the file. If false is</span>
<span class="cm">    returned, the current position is not changed.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Seeking beyond the end of the buffer is succeeds.</span>
<span class="cm">    Seeking before the beginning of the buffer fails.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SeekFromStart</span><span class="p">(</span> <span class="n">ON__INT64</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    offset - [in]</span>
<span class="cm">      number of bytes to seek from the current position.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">    False if the seek would result in a file position</span>
<span class="cm">    before the beginning of the file. If false is</span>
<span class="cm">    returned, the current position is not changed.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Seeking beyond the end of the buffer is succeeds.</span>
<span class="cm">    Seeking before the beginning of the buffer fails.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SeekFromCurrentPosition</span><span class="p">(</span> <span class="n">ON__INT64</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    offset - [in]</span>
<span class="cm">      number of bytes to seek from the end fo the buffer.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">    False if the seek would result in a file position</span>
<span class="cm">    before the beginning of the file. If false is</span>
<span class="cm">    returned, the current position is not changed.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Seeking beyond the end of the buffer is succeeds.</span>
<span class="cm">    Seeking before the beginning of the buffer fails.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SeekFromEnd</span><span class="p">(</span> <span class="n">ON__INT64</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    buffer_size - [in]</span>
<span class="cm">      new size of buffer.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The current position is not changed and may be beyond the</span>
<span class="cm">    end of the file. Use Seek to set the current position after</span>
<span class="cm">    calling ChangeSize().</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ChangeSize</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">buffer_size</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Return unused memory to heap.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Call this function after creating an ON_Buffer that will persist for</span>
<span class="cm">    and extended amount of time. There are never more than 16 pages of</span>
<span class="cm">    unsued memory (16*4096 bytes on most computers) in an ON_Buffer.</span>
<span class="cm">    Compact() can be called at any time, but calling Compact() the then</span>
<span class="cm">    writing at the end of the buffer is not an efficient use of time</span>
<span class="cm">    or memory.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Compact</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns</span>
<span class="cm">    True if the ON_Buffer is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Value that identifies most recent error.</span>
<span class="cm">    0: no error</span>
<span class="cm">    1: attempt to seek to a negative position</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT32</span> <span class="nf">LastError</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">ClearLastError</span><span class="p">();</span>

  <span class="n">ON_Buffer_ErrorHandler</span> <span class="nf">ErrorHandler</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">SetErrorHandler</span><span class="p">(</span><span class="n">ON_Buffer_ErrorHandler</span> <span class="n">error_handler</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Use WriteToBinaryArchive() to save an entire ON_Buffer inside</span>
<span class="cm">    a binary archive.  Use ReadFromBinaryArchive() to retrieve</span>
<span class="cm">    the ON_Buffer from the ON_BinaryArchive.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">WriteToBinaryArchive</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Use ReadFromBinaryArchive() to retrieve an entire ON_Buffer</span>
<span class="cm">    that was written using WriteToBinaryArchive().</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadFromBinaryArchive</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Compress this buffer</span>

<span class="cm">  Parameters:</span>
<span class="cm">    compressed_buffer - [out]</span>
<span class="cm">      (The reference can be *this)</span>

<span class="cm">  Example:</span>

<span class="cm">        // compress a buffer in place</span>
<span class="cm">        ON_Buffer buffer;</span>
<span class="cm">        buffer = ...;</span>
<span class="cm">        if ( !buffer.Compress(buffer) )</span>
<span class="cm">        {</span>
<span class="cm">           // compression failed</span>
<span class="cm">        }</span>
<span class="cm">        else</span>
<span class="cm">        {</span>
<span class="cm">           // buffer is now compressed</span>
<span class="cm">        }</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if successful.  False if failed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Compress</span><span class="p">(</span> <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="n">compressed_buffer</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Uncompress this buffer which must have been compressed using</span>
<span class="cm">    ON_Buffer::Compress().</span>

<span class="cm">  Parameters:</span>
<span class="cm">    uncompressed_buffer - [out]</span>
<span class="cm">      (The reference can be *this)</span>

<span class="cm">  Example:</span>
<span class="cm">        // silly example that compresses and then uncompresses a buffer in place</span>
<span class="cm">        // to show how to call the functions.</span>
<span class="cm">        ON_Buffer buffer;</span>
<span class="cm">        buffer = ...; // buffer is in it uncompressed form</span>
<span class="cm">        if ( buffer.Compress(buffer) )</span>
<span class="cm">        {</span>
<span class="cm">           // buffer is now compressed</span>
<span class="cm">           if ( buffer.Uncompress(buffer) )</span>
<span class="cm">           {</span>
<span class="cm">              // buffer is uncompressed again.</span>
<span class="cm">           }</span>
<span class="cm">        }</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if successful.  False if failed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Uncompress</span><span class="p">(</span> <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="n">uncompressed_buffer</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>

  <span class="n">ON__UINT64</span> <span class="n">m_buffer_size</span><span class="p">;</span> <span class="c1">// total number of bytes in the buffer</span>
  <span class="n">ON__UINT64</span> <span class="n">m_current_position</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">ON_BUFFER_SEGMENT</span><span class="o">*</span> <span class="n">m_first_segment</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ON_BUFFER_SEGMENT</span><span class="o">*</span> <span class="n">m_last_segment</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ON_BUFFER_SEGMENT</span><span class="o">*</span> <span class="n">m_current_segment</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">SetCurrentSegment</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">Copy</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Buffer</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="n">ON_MEMORY_POOL</span><span class="o">*</span> <span class="n">m_heap</span><span class="p">;</span>
  <span class="n">ON_Buffer_ErrorHandler</span> <span class="n">m_error_handler</span><span class="p">;</span>

  <span class="n">ON__UINT32</span> <span class="n">m_last_error</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">m_reserved</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>

<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// ON_BinaryArchive</span>
<span class="c1">//      virtual class for CPU independent serialization</span>
<span class="c1">//</span>
<span class="c1">// ON_BinaryFile</span>
<span class="c1">//      simple class for CPU independent binary file I/O</span>
<span class="c1">//      includes optional CRC support</span>
<span class="c1">//</span>

<span class="k">class</span> <span class="nc">ON_Object</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Group</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Font</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_DimStyle</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Arc</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_ObjectAttributes</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_InstanceDefinition</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_HatchPattern</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Linetype</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ON_3DM_CHUNK</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">m_offset</span><span class="p">;</span> <span class="c1">// In read or write_using_fseek mode, this is the</span>
                   <span class="c1">// file position of first byte after chunk&#39;s length.</span>
                   <span class="c1">// In write_using_buffer mode, this of the m_buffer[]</span>
                   <span class="c1">// position of first byte after chunk&#39;s length.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_typecode</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_do_length</span><span class="p">;</span> <span class="c1">// true if chunk is a long chunk with length</span>
  <span class="n">ON__UINT16</span> <span class="n">m_do_crc16</span><span class="p">;</span> <span class="c1">// 16 bit CRC using CCITT polynomial</span>
  <span class="n">ON__UINT16</span> <span class="n">m_crc16</span><span class="p">;</span>
  <span class="n">ON__UINT32</span> <span class="n">m_do_crc32</span><span class="p">;</span> <span class="c1">// 32 bit CRC</span>
  <span class="n">ON__UINT32</span> <span class="n">m_crc32</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_3DM_BIG_CHUNK</span>
<span class="p">{</span>
  <span class="n">ON__UINT64</span> <span class="n">m_big_offset</span><span class="p">;</span> <span class="c1">// In read or write_using_fseek mode, this is the</span>
                           <span class="c1">// file position of first byte after chunk&#39;s length.</span>
                           <span class="c1">// In write_using_buffer mode, this of the m_buffer[]</span>
                           <span class="c1">// position of first byte after chunk&#39;s length.</span>

  <span class="n">ON__UINT64</span> <span class="nf">Length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 0 for short chunks</span>

  <span class="n">ON__INT64</span> <span class="n">m_big_value</span><span class="p">;</span>
  <span class="n">ON__UINT32</span> <span class="n">m_typecode</span><span class="p">;</span>

  <span class="n">ON__UINT8</span> <span class="n">m_bLongChunk</span><span class="p">;</span> <span class="c1">// true if chunk is a long chunk and m_big_value is a length.</span>
  <span class="n">ON__UINT8</span> <span class="n">m_reserved1</span><span class="p">;</span>
  <span class="n">ON__UINT8</span> <span class="n">m_reserved2</span><span class="p">;</span>
  <span class="n">ON__UINT8</span> <span class="n">m_reserved3</span><span class="p">;</span>

  <span class="c1">// CRC settings</span>
  <span class="n">ON__UINT8</span> <span class="n">m_do_crc16</span><span class="p">;</span> <span class="c1">// true (1) if we are calculating 16 bit CRC</span>
  <span class="n">ON__UINT8</span> <span class="n">m_do_crc32</span><span class="p">;</span> <span class="c1">// true (1) if we are calculating 32 bit CRC</span>
  <span class="n">ON__UINT16</span> <span class="n">m_crc16</span><span class="p">;</span> <span class="c1">// current 16 bit CRC value</span>
  <span class="n">ON__UINT32</span> <span class="n">m_crc32</span><span class="p">;</span> <span class="c1">// current 32 bit CRC value</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="nf">ON_IsLongChunkTypecode</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">typecode</span><span class="p">);</span>

<span class="kt">bool</span> <span class="nf">ON_IsShortChunkTypecode</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">typecode</span><span class="p">);</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3DM_CHUNK</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3DM_BIG_CHUNK</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>

<span class="k">class</span> <span class="nc">ON_Light</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Bitmap</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_TextureMapping</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Material</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_Layer</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_3dmProperties</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_3dmSettings</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_3dmObjectAttributes</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_3dmGoo</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ON_BinaryArchive</span><span class="p">;</span>

<span class="c1">// Used int ON_3dmProperties::Read() to set ON_BinaryArchive.m_3dm_opennurbs_version</span>
<span class="c1">// Do not call directly.</span>
<span class="kt">void</span> <span class="nf">ON_SetBinaryArchiveOpenNURBSVersion</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_BinaryArchive</span> <span class="c1">// use for generic serialization of binary data</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BinaryArchive</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span> <span class="p">);</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ON_BinaryArchive</span><span class="p">();</span>

  <span class="k">virtual</span>
  <span class="kt">size_t</span> <span class="nf">CurrentPosition</span><span class="p">(</span> <span class="o">//</span> <span class="n">current</span> <span class="n">offset</span> <span class="p">(</span><span class="n">in</span> <span class="n">bytes</span><span class="p">)</span> <span class="n">into</span> <span class="n">archive</span> <span class="p">(</span> <span class="n">like</span> <span class="n">ftell</span><span class="p">()</span> <span class="p">)</span>
                <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SeekFromCurrentPosition</span><span class="p">(</span> <span class="o">//</span> <span class="n">seek</span> <span class="n">from</span> <span class="n">current</span> <span class="n">position</span> <span class="p">(</span> <span class="n">like</span> <span class="n">fseek</span><span class="p">(</span> <span class="p">,</span><span class="n">SEEK_CUR</span><span class="p">)</span> <span class="p">)</span>
                <span class="kt">int</span> <span class="c1">// byte offset ( &gt;= -CurrentPostion() )</span>
                <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">SeekFromStart</span><span class="p">(</span>  <span class="o">//</span> <span class="n">seek</span> <span class="n">from</span> <span class="n">current</span> <span class="n">position</span> <span class="p">(</span> <span class="n">like</span> <span class="n">fseek</span><span class="p">(</span> <span class="p">,</span><span class="n">SEEK_SET</span><span class="p">)</span> <span class="p">)</span>
                <span class="kt">size_t</span> <span class="c1">// byte offset ( &gt;= 0 )</span>
                <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">AtEnd</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// true if at end of file</span>

  <span class="kt">bool</span> <span class="nf">BigSeekFromStart</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">offset</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">BigSeekForward</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">offset</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">BigSeekBackward</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">offset</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">BigSeekFromCurrentPosition</span><span class="p">(</span> <span class="n">ON__INT64</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tool for swapping bytes when doing I/O on</span>
<span class="cm">    using big endian CPUs.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    3dm files are always saved with little endian byte order.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_BinaryArchive::Endian</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="kt">bool</span> <span class="nf">ToggleByteOrder</span><span class="p">(</span>
    <span class="kt">int</span><span class="p">,</span> <span class="c1">// number of elements</span>
    <span class="kt">int</span><span class="p">,</span> <span class="o">//</span> <span class="n">size</span> <span class="n">of</span> <span class="n">element</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span> <span class="n">or</span> <span class="mi">8</span><span class="p">)</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span>  <span class="c1">// source buffer</span>
    <span class="kt">void</span><span class="o">*</span>         <span class="c1">// destination buffer (can be same a source buffer)</span>
    <span class="p">);</span>

  <span class="k">static</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">TypecodeName</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcode</span> <span class="p">);</span>

  <span class="k">static</span>
  <span class="kt">char</span><span class="o">*</span> <span class="nf">ON_TypecodeParse</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcode</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">typecode_name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">max_length</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadMode</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// true if reading is permitted</span>
  <span class="kt">bool</span> <span class="nf">WriteMode</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// true if writing is permitted</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">     Endian-ness of the cpu reading this file.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    3dm files are alwasy saved with little endian byte order.</span>
<span class="cm">  */</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">endian</span> <span class="n">Endian</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// endian-ness of cpu</span>

  <span class="kt">int</span> <span class="nf">BadCRCCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// number of chunks read with bad CRC</span>

  <span class="kt">bool</span> <span class="nf">ReadByte</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// must fail if mode is not read or readwrite</span>

  <span class="kt">bool</span> <span class="nf">WriteByte</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// must fail if mode is not write or readwrite</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function that uses Read() to load a buffer.</span>
<span class="cm">  Paramters:</span>
<span class="cm">    sizeof_buffer - [in] number of bytes to attempt to read.</span>
<span class="cm">    buffer - [out] read bytes are stored in this buffer</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of bytes actually read, which may be less than</span>
<span class="cm">    sizeof_buffer if the end of file is encountered.</span>
<span class="cm">  */</span>
  <span class="n">ON__UINT64</span> <span class="nf">ReadBuffer</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">sizeof_buffer</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function to control CRC calculation while reading and writing.</span>
<span class="cm">    Typically this is used when seeking around and reading/writing information</span>
<span class="cm">    in non-serial order.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bEnable  - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    Current state of CRC calculation.  Use the returned value to restore the</span>
<span class="cm">    CRC calculation setting after you are finished doing your fancy pants</span>
<span class="cm">    expert IO.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">EnableCRCCalculation</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bEnable</span> <span class="p">);</span>

  <span class="c1">// ReadCompressedBuffer()/WriteCompressedBuffer() use zlib 1.1.3</span>
  <span class="c1">// to inflate/deflate the data buffer.</span>
  <span class="c1">// Care must be used to get an endian independent file.</span>
  <span class="c1">// See ON_Mesh::Read()/ON_Mesh::Write() for an example of an endian</span>
  <span class="c1">// independent use of compression. See also ToggleByteOrder() and Endian().</span>
  <span class="c1">//</span>
  <span class="c1">// To read data archived by WriteCompressedBuffer( sizeof_buffer, buffer )</span>
  <span class="c1">// do something like:</span>
  <span class="c1">//</span>
  <span class="c1">//   size_t sizeof_buffer = 0;</span>
  <span class="c1">//   ReadCompressedBufferSize(&amp;sizeof_buffer);</span>
  <span class="c1">//   buffer = something with sizeof_buffer bytes.</span>
  <span class="c1">//   int bFailedCRC = false;</span>
  <span class="c1">//   bool ok = ReadCompressedBuffer( sizeof_buffer, buffer, &amp;bFailedCRC );</span>
  <span class="c1">//</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Red the size of a compressed buffer.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sizeof__outbuffer - [out] size of the uncompressed buffer in bytes</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if read was successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadCompressedBufferSize</span><span class="p">(</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">sizeof__outbuffer</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Read compressed information from an archive and uncompress it.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sizeof__outbuffer - [in] size of the uncompressed buffer in bytes</span>
<span class="cm">    outbuffer - [out] uncompressed buffer returned here</span>
<span class="cm">    bFailedCRC - [out] true if cyclic redundancy check fails</span>
<span class="cm">                      on uncompressed buffer</span>

<span class="cm">  Example:</span>

<span class="cm">          size_t sizeof_buffer = 0;</span>
<span class="cm">          ReadCompressedBufferSize(&amp;sizeof_buffer);</span>
<span class="cm">          buffer = ...; // something with sizeof_buffer bytes.</span>
<span class="cm">          int bFailedCRC = false;</span>
<span class="cm">          bool ok = ReadCompressedBuffer( sizeof_buffer, buffer, &amp;bFailedCRC );</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if read was successful.  You need to check the value</span>
<span class="cm">    of bFailedCRC to see if the information that was read is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadCompressedBuffer</span><span class="p">(</span>
          <span class="kt">size_t</span> <span class="n">sizeof__outbuffer</span><span class="p">,</span>
          <span class="kt">void</span><span class="o">*</span> <span class="n">outbuffer</span><span class="p">,</span>
          <span class="kt">int</span><span class="o">*</span> <span class="n">bFailedCRC</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Compress buffer and write the compressed information to the archive.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sizeof__inbuffer - [in] size of the uncompressed buffer in bytes</span>
<span class="cm">    inbuffer - [in] uncompressed buffer</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if write was successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">WriteCompressedBuffer</span><span class="p">(</span>
    <span class="kt">size_t</span> <span class="n">sizeof__inbuffer</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">inbuffer</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadBool</span><span class="p">(</span> <span class="kt">bool</span><span class="o">*</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadChar</span><span class="p">(</span>    <span class="c1">// Read an array of 8 bit chars</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of chars to read</span>
      <span class="kt">char</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadChar</span><span class="p">(</span>    <span class="c1">// Read an array of 8 bit unsigned chars</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of unsigned chars to read</span>
      <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadChar</span><span class="p">(</span>    <span class="c1">// Read a single 8 bit char</span>
      <span class="kt">char</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadChar</span><span class="p">(</span>    <span class="c1">// Read a single 8 bit unsigned char</span>
      <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadShort</span><span class="p">(</span>   <span class="c1">// Read an array of 16 bit shorts</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of shorts to read</span>
      <span class="kt">short</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadShort</span><span class="p">(</span>   <span class="c1">// Read an array of 16 bit unsigned shorts</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of shorts to read</span>
      <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadShort</span><span class="p">(</span>   <span class="c1">// Read a single 16 bit short</span>
      <span class="kt">short</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadShort</span><span class="p">(</span>   <span class="c1">// Read a single 16 bit unsigned short</span>
      <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadInt</span><span class="p">(</span> <span class="c1">// Read an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to read</span>
      <span class="kt">int</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInt</span><span class="p">(</span> <span class="c1">// Read an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to read</span>
      <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInt</span><span class="p">(</span> <span class="c1">// Read a single 32 bit integer</span>
      <span class="kt">int</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInt</span><span class="p">(</span> <span class="c1">// Read a single 32 bit unsigned integer</span>
      <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadBigInt</span><span class="p">(</span> <span class="c1">// Read an array of 64 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to read</span>
      <span class="n">ON__INT64</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadBigInt</span><span class="p">(</span> <span class="c1">// Read an array of 64 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to read</span>
      <span class="n">ON__UINT64</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadBigInt</span><span class="p">(</span> <span class="c1">// Read a single 64 bit integer</span>
      <span class="n">ON__INT64</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadBigInt</span><span class="p">(</span> <span class="c1">// Read a single 64 bit unsigned integer</span>
      <span class="n">ON__UINT64</span><span class="o">*</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadLong</span><span class="p">(</span> <span class="c1">// Read an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to read</span>
      <span class="kt">long</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadLong</span><span class="p">(</span> <span class="c1">// Read an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to read</span>
      <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadLong</span><span class="p">(</span> <span class="c1">// Read a single 32 bit integer</span>
      <span class="kt">long</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadLong</span><span class="p">(</span> <span class="c1">// Read a single 32 bit unsigned integer</span>
      <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadSize</span><span class="p">(</span> <span class="c1">// Read a single size_t</span>
      <span class="kt">size_t</span><span class="o">*</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadBigSize</span><span class="p">(</span> <span class="kt">size_t</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// 64 bits</span>

  <span class="kt">bool</span> <span class="nf">ReadBigTime</span><span class="p">(</span> <span class="kt">time_t</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// UCT seconds since 1 January 1970 (64 bits)</span>


  <span class="kt">bool</span> <span class="nf">ReadFloat</span><span class="p">(</span>   <span class="c1">// Read an array of floats</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of floats</span>
      <span class="kt">float</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadFloat</span><span class="p">(</span>   <span class="c1">// Read a single float</span>
      <span class="kt">float</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadDouble</span><span class="p">(</span>  <span class="c1">// Read an array of IEEE doubles</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of doubles</span>
      <span class="kt">double</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadDouble</span><span class="p">(</span>  <span class="c1">// Read a single double</span>
      <span class="kt">double</span><span class="o">*</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadColor</span><span class="p">(</span>
    <span class="n">ON_Color</span><span class="o">&amp;</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadPoint</span> <span class="p">(</span>
    <span class="n">ON_2dPoint</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadPoint</span> <span class="p">(</span>
    <span class="n">ON_3dPoint</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadPoint</span> <span class="p">(</span>
    <span class="n">ON_4dPoint</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadVector</span> <span class="p">(</span>
    <span class="n">ON_2dVector</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadVector</span> <span class="p">(</span>
    <span class="n">ON_3dVector</span><span class="o">&amp;</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadBoundingBox</span><span class="p">(</span><span class="n">ON_BoundingBox</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadXform</span><span class="p">(</span><span class="n">ON_Xform</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadPlaneEquation</span><span class="p">(</span><span class="n">ON_PlaneEquation</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadPlane</span><span class="p">(</span><span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadLine</span><span class="p">(</span><span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadArc</span><span class="p">(</span><span class="n">ON_Arc</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadCircle</span><span class="p">(</span><span class="n">ON_Circle</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadInterval</span><span class="p">(</span> <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadUuid</span><span class="p">(</span> <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadDisplayMaterialRef</span><span class="p">(</span> <span class="n">ON_DisplayMaterialRef</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadLinetypeSegment</span><span class="p">(</span> <span class="n">ON_LinetypeSegment</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// All times are stored in coordinated universal time</span>
  <span class="c1">// ( a.k.a GMT, UTC ).  Use ANSI C time() and gmtime() calls.</span>
  <span class="kt">bool</span> <span class="nf">ReadTime</span><span class="p">(</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    str_array_count - [out]</span>
<span class="cm">      Number of elements in the string array. All ON_BinaryArchive string</span>
<span class="cm">      WriteString() functions write a null terminator to the file and</span>
<span class="cm">      the null terminator is included in the count. This means that</span>
<span class="cm">      if a string has a non-zero element, then str_array_count &gt;= 2.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Modify your code to use ReadStringUTF8ElementCount() when reading</span>
<span class="cm">    UTF-8 encoded strings and ReadStringUTF16ElementCount()</span>
<span class="cm">    when reading UTF-16 encoded strings.</span>
<span class="cm">  */</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">bool</span> <span class="nf">ReadStringSize</span><span class="p">(</span>
      <span class="kt">size_t</span><span class="o">*</span> <span class="n">str_array_count</span>
      <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    string_utf8_element_count - [out]</span>
<span class="cm">      Number of bytes in the string array. All ON_BinaryArchive string</span>
<span class="cm">      WriteString() functions write a null terminator to the file and</span>
<span class="cm">      the null terminator is included in string_element_count. This means</span>
<span class="cm">      that if opennurbs wrote the string, either string_element_count = 0</span>
<span class="cm">      or string_element_count &gt;= 2.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadStringUTF8ElementCount</span><span class="p">(</span>
    <span class="kt">size_t</span><span class="o">*</span> <span class="n">string_utf8_element_count</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    string_utf16_element_count - [out]</span>
<span class="cm">      Number of elements in the string array. All ON_BinaryArchive string</span>
<span class="cm">      WriteString() functions write a null terminator to the file and</span>
<span class="cm">      the null terminator is included in string_element_count. This means</span>
<span class="cm">      that if opennurbs wrote the string, either string_element_count = 0</span>
<span class="cm">      or string_element_count &gt;= 2.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadStringUTF16ElementCount</span><span class="p">(</span>
    <span class="kt">size_t</span><span class="o">*</span> <span class="n">string_utf16_element_count</span>
    <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    str_array_count - [in]</span>
<span class="cm">      Number of char elements in str_array[], including the null</span>
<span class="cm">      terminator.  The value of str_array_count is returned by</span>
<span class="cm">      ReadCharStringElementCount().</span>
<span class="cm">    str_array - [in/out]</span>
<span class="cm">      Pass in an array with at least str_array_count elements.</span>
<span class="cm">      If true is returned and str_array_count &gt; 0,</span>
<span class="cm">      then str_array[str_array_count-1] = 0. All strings with</span>
<span class="cm">      char elements written by Rhino are UTF-8 encoded</span>
<span class="cm">      unicode strings.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadString</span><span class="p">(</span>
      <span class="kt">size_t</span> <span class="n">str_array_count</span><span class="p">,</span>
      <span class="kt">char</span><span class="o">*</span> <span class="n">str_array</span>
      <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    str_array_count - [in]</span>
<span class="cm">      Number of unsignd char elements in str_array[], including</span>
<span class="cm">      the null terminator. The value of str_array_count is returned</span>
<span class="cm">      by ReadCharStringElementCount().</span>
<span class="cm">    str_array - [in/out]</span>
<span class="cm">      Pass in an array with at least str_array_count elements.</span>
<span class="cm">      If true is returned and str_array_count &gt; 0,</span>
<span class="cm">      then str_array[str_array_count-1] = 0. All strings with</span>
<span class="cm">      unsigned char elements written by Rhino are UTF-8 encoded</span>
<span class="cm">      unicode strings.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadString</span><span class="p">(</span>
      <span class="kt">size_t</span> <span class="n">str_array_count</span><span class="p">,</span>
      <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str_array</span>
      <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    str_array_count - [in]</span>
<span class="cm">      Number of unsigned short elements in str_array[],</span>
<span class="cm">      including the null terminator. The value of</span>
<span class="cm">      str_array_count is returned by ReadWideCharStringElementCount().</span>
<span class="cm">    str_array - [in/out]</span>
<span class="cm">      Pass in an array with at least str_array_count elements.</span>
<span class="cm">      If true is returned and str_array_count &gt; 0,</span>
<span class="cm">      then str_array[str_array_count-1] = 0. All strings with</span>
<span class="cm">      unsigned short elements written by Rhino are UTF-16 encoded</span>
<span class="cm">      unicode strings.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadString</span><span class="p">(</span>
      <span class="kt">size_t</span> <span class="n">str_array_count</span><span class="p">,</span>
      <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span>  <span class="n">str_array</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadString</span><span class="p">(</span> <span class="n">ON_String</span><span class="o">&amp;</span> <span class="n">sUTF8</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadString</span><span class="p">(</span> <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadComponentIndex</span><span class="p">(</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Color</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3dPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_4dPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3dVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Xform</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2fPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3fPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_4fPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2fVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3fVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_UUID</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_UuidIndex</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_SurfaceCurvature</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_String</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_wString</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_DisplayMaterialRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_LinetypeSegment</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MappingChannel</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_MaterialRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_MappingRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_ObjRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_ObjRef_IRefID</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_ClippingPlaneInfo</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_Layer</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadArray</span><span class="p">(</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_Layer</span><span class="o">*&gt;&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteBool</span><span class="p">(</span> <span class="kt">bool</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteChar</span><span class="p">(</span>    <span class="c1">// Write an array of 8 bit chars</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of chars to write</span>
      <span class="k">const</span> <span class="kt">char</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteChar</span><span class="p">(</span>    <span class="c1">// Write an array of 8 bit unsigned chars</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of unsigned chars to write</span>
      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteChar</span><span class="p">(</span>    <span class="c1">// Write a single 8 bit char</span>
      <span class="kt">char</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteChar</span><span class="p">(</span>    <span class="c1">// Write a single 8 bit unsigned char</span>
      <span class="kt">unsigned</span> <span class="kt">char</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteShort</span><span class="p">(</span>   <span class="c1">// Write an array of 16 bit shorts</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of shorts to write</span>
      <span class="k">const</span> <span class="kt">short</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteShort</span><span class="p">(</span>   <span class="c1">// Write an array of 16 bit unsigned shorts</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of shorts to write</span>
      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteShort</span><span class="p">(</span>   <span class="c1">// Write a single 16 bit short</span>
      <span class="kt">short</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteShort</span><span class="p">(</span>   <span class="c1">// Write a single 16 bit unsigned short</span>
      <span class="kt">unsigned</span> <span class="kt">short</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteInt</span><span class="p">(</span> <span class="c1">// Write an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to write</span>
      <span class="k">const</span> <span class="kt">int</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteInt</span><span class="p">(</span> <span class="c1">// Write an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to write</span>
      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteInt</span><span class="p">(</span> <span class="c1">// Write a single 32 bit integer</span>
      <span class="kt">int</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteInt</span><span class="p">(</span> <span class="c1">// Write a single 32 bit unsigned integer</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteBigInt</span><span class="p">(</span> <span class="c1">// Write an array of 64 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to write</span>
      <span class="k">const</span> <span class="n">ON__INT64</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteBigInt</span><span class="p">(</span> <span class="c1">// Write an array of 64 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to write</span>
      <span class="k">const</span> <span class="n">ON__UINT64</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteBigInt</span><span class="p">(</span> <span class="c1">// Write a single 64 bit integer</span>
      <span class="n">ON__INT64</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteBigInt</span><span class="p">(</span> <span class="c1">// Write a single 64 bit unsigned integer</span>
      <span class="n">ON__UINT64</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteLong</span><span class="p">(</span> <span class="c1">// Write an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to write</span>
      <span class="k">const</span> <span class="kt">long</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteLong</span><span class="p">(</span> <span class="c1">// Write an array of 32 bit integers</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of ints to write</span>
      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteLong</span><span class="p">(</span> <span class="c1">// Write a single 32 bit integer</span>
      <span class="kt">long</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteLong</span><span class="p">(</span> <span class="c1">// Write a single 32 bit unsigned integer</span>
      <span class="kt">unsigned</span> <span class="kt">long</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteSize</span><span class="p">(</span> <span class="c1">// Write a single size_t</span>
      <span class="kt">size_t</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteBigSize</span><span class="p">(</span> <span class="kt">size_t</span> <span class="p">);</span> <span class="c1">// 64 bits</span>

  <span class="kt">bool</span> <span class="nf">WriteBigTime</span><span class="p">(</span> <span class="kt">time_t</span> <span class="p">);</span> <span class="c1">// UCT seconds since 1 January 1970 (64 bits)</span>

  <span class="kt">bool</span> <span class="nf">WriteFloat</span><span class="p">(</span>   <span class="c1">// Write a number of IEEE floats</span>
      <span class="kt">size_t</span><span class="p">,</span>       <span class="c1">// number of doubles</span>
      <span class="k">const</span> <span class="kt">float</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteFloat</span><span class="p">(</span>   <span class="c1">// Write a single float</span>
      <span class="kt">float</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteDouble</span><span class="p">(</span>  <span class="c1">// Write a single double</span>
      <span class="kt">size_t</span><span class="p">,</span>
      <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>
      <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteDouble</span><span class="p">(</span>  <span class="c1">// Write a single double</span>
      <span class="kt">double</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteColor</span> <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Color</span><span class="o">&amp;</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WritePoint</span> <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WritePoint</span> <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WritePoint</span> <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_4dPoint</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteVector</span> <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_2dVector</span><span class="o">&amp;</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteVector</span> <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteBoundingBox</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteXform</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WritePlaneEquation</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_PlaneEquation</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WritePlane</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteLine</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Line</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteArc</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Arc</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteCircle</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Circle</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteInterval</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteUuid</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteDisplayMaterialRef</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_DisplayMaterialRef</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteLinetypeSegment</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_LinetypeSegment</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// All times are stored in universal coordinated time</span>
  <span class="c1">// ( a.k.a GMT, UCT ).  Use ANSI C time() and gmtime() calls.</span>
  <span class="kt">bool</span> <span class="nf">WriteTime</span><span class="p">(</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tm</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sUTF8 - [in]</span>
<span class="cm">      A null terminated UTF-8 encoded unicode string.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    To read a string written with WriteString(const char*),</span>
<span class="cm">    call ReadStringUTF8ElementCount(&amp;string_utf8_element_count)</span>
<span class="cm">    to get the number of char elements written in the file,</span>
<span class="cm">    obtain a buffer with at least string_utf8_element_count</span>
<span class="cm">    char elements and then call</span>
<span class="cm">    ReadString(string_utf8_element_count,buffer) to read the</span>
<span class="cm">    char elements.</span>

<span class="cm">    If 0 == sUTF8 or 0 == SUTF8[0], a 4 byte int with</span>
<span class="cm">    value = 0 is written, otherwise a 4 byte int with</span>
<span class="cm">    value = strlen + 1 is written, followed by the string,</span>
<span class="cm">    followed by the null terminator.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">WriteString</span><span class="p">(</span>
      <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sUTF8</span>
      <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sUTF8 - [in]</span>
<span class="cm">      A null terminated UTF-8 encoded unicode string.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    To read a string written with WriteString(const unsigned char*),</span>
<span class="cm">    call ReadStringUTF8ElementCount(&amp;string_utf8_element_count) to</span>
<span class="cm">    get the number of unsigned char elements written in the file,</span>
<span class="cm">    obtain a buffer with at least string_utf8_element_count</span>
<span class="cm">    unsigned char elements and then call</span>
<span class="cm">    ReadString(string_utf8_element_count,buffer) to read the</span>
<span class="cm">    unsigned charelements.</span>

<span class="cm">    If 0 == sUTF8 or 0 == SUTF8[0], a 4 byte int with</span>
<span class="cm">    value = 0 is written, otherwise a 4 byte int with</span>
<span class="cm">    value = strlen + 1 is written, followed by the string,</span>
<span class="cm">    followed by the null terminator.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">WriteString</span><span class="p">(</span>
      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sUTF8</span>
      <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sUTF16 - [in]</span>
<span class="cm">      A null terminated UTF-16 encoded unicode string.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    To read a string written with WriteString(const unsigned short*),</span>
<span class="cm">    call ReadStringUTF16ElementCount(&amp;string_utf16_element_count) to</span>
<span class="cm">    get the number of unsigned short elements written in the file,</span>
<span class="cm">    obtain a buffer with at least string_utf16_element_count</span>
<span class="cm">    unsigned short elements and then call</span>
<span class="cm">    ReadString(string_utf16_element_count,buffer) to read the</span>
<span class="cm">    unsigned short elements.</span>

<span class="cm">    If 0 == sUTF8 or 0 == SUTF8[0], a 4 byte int with</span>
<span class="cm">    value = 0 is written, otherwise a 4 byte int with</span>
<span class="cm">    value = strlen + 1 is written, followed by the string,</span>
<span class="cm">    followed by the null terminator.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">WriteString</span><span class="p">(</span>
      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span> <span class="n">sUTF16</span>
      <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteString</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_String</span><span class="o">&amp;</span> <span class="n">sUTF8</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteString</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteComponentIndex</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_COMPONENT_INDEX</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Color</span><span class="o">&gt;&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3dPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_4dPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3dVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2fPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3fPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_4fPoint</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2fVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3fVector</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Xform</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_UUID</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_UuidIndex</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_SurfaceCurvature</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_String</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_wString</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_DisplayMaterialRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_LinetypeSegment</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MappingChannel</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_MaterialRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_MappingRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_ObjRef</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_ObjRef_IRefID</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ON_ClippingPlaneInfo</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_Layer</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteArray</span><span class="p">(</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_Layer</span><span class="o">*</span><span class="k">const</span><span class="o">*</span> <span class="p">);</span>

  <span class="c1">/////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Read/Write classes derived from ON_Object</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Reads and object from a 3dm archive;</span>
<span class="cm">  Parameters:</span>
<span class="cm">    ppObject - [out]  object is allocated and a pointer to the</span>
<span class="cm">                      allocated object is returned as *ppObject;</span>
<span class="cm">  Returns:</span>
<span class="cm">    0: failure - unable to read object because of file IO problems</span>
<span class="cm">    1: success</span>
<span class="cm">    3: unable to read object because it&#39;s UUID is not registered</span>
<span class="cm">       this could happen in cases where old code is attempting to read</span>
<span class="cm">       new objects.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">ReadObject</span><span class="p">(</span>
         <span class="n">ON_Object</span><span class="o">**</span> <span class="n">ppObject</span>
         <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Reads and object from a 3dm archive.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    object - [in] The value of object.ON_ClassId()-&gt;Uuid() must</span>
<span class="cm">                  exactly match the class uuid in of the next</span>
<span class="cm">                  object in the archive.</span>
<span class="cm">  Returns:</span>
<span class="cm">    0: failure - unable to read object because of file IO problems.</span>
<span class="cm">    1: success</span>
<span class="cm">    2: unable to read object because the class id in the archive</span>
<span class="cm">       did not match pObject-&gt;ClassId.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">ReadObject</span><span class="p">(</span>
         <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="n">object</span>
         <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteObject</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// writes object definition</span>
  <span class="kt">bool</span> <span class="nf">WriteObject</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// writes object definition</span>


  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// 3DM Interface - ignore if not reading/writing a 3DM file</span>
  <span class="c1">//                 this is here so that the infrastructure</span>
  <span class="c1">//                 for writing 3dm archives is available for</span>
  <span class="c1">//                 any type of serialization device.</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">EnableSave3dmRenderMeshes</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// returns previous state</span>
  <span class="kt">bool</span> <span class="nf">Save3dmRenderMeshes</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">EnableSave3dmAnalysisMeshes</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// returns previous state</span>
  <span class="kt">bool</span> <span class="nf">Save3dmAnalysisMeshes</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">EnableSaveUserData</span><span class="p">(</span> <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// returns previous state</span>
  <span class="kt">bool</span> <span class="nf">SaveUserData</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    50 (The Rhino 5.0 opennurbs file version.)</span>
<span class="cm">    This is the value of version to pass to ON_BinaryArchive</span>
<span class="cm">    functions like Write3dmStartSection() when you want to use the</span>
<span class="cm">    the current opennurbs version number and you do not want to have</span>
<span class="cm">    to update your code when this version number changes.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">CurrentArchiveVersion</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 1: REQUIRED - Write/Read Start Section</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    version - [in]</span>
<span class="cm">       0, 2, 3, 4, 5 or 50 (5 is treated as 50)</span>

<span class="cm">       If version is 0, then the value of ON_BinaryArchive::CurrentArchiveVersion()</span>
<span class="cm">       is used.</span>

<span class="cm">       Use either 0 or the value of ON_BinaryArchive::CurrentArchiveVersion()</span>
<span class="cm">       for the version parameter when you want your code to write the most</span>
<span class="cm">       up to date file version.</span>

<span class="cm">    sStartSectionComment - [in]</span>
<span class="cm">      NULL or ASCII string with application name, et cetera.</span>
<span class="cm">      This information is primarily used when debugging files</span>
<span class="cm">      that contain problems.  McNeel and Associates stores</span>
<span class="cm">      application name, application version, compile date,</span>
<span class="cm">      and the OS in use when file was written.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Write3dmStartSection</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sStartSectionComment</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    version - [out]</span>
<span class="cm">       .3dm file version (2, 3, 4, 5 or 50)</span>
<span class="cm">    sStartSectionComment - [out]</span>
<span class="cm">      string passed to Write3dmStartSection()</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Read3dmStartSection</span><span class="p">(</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">version</span><span class="p">,</span>
        <span class="n">ON_String</span><span class="o">&amp;</span> <span class="n">sStartSectionComment</span>
        <span class="p">);</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 2: REQUIRED - Write/Read properties table</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">Write3dmProperties</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dmProperties</span><span class="o">&amp;</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Read3dmProperties</span><span class="p">(</span>
        <span class="n">ON_3dmProperties</span><span class="o">&amp;</span>
        <span class="p">);</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 3: REQUIRED - Write/Read settings table</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">Write3dmSettings</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dmSettings</span><span class="o">&amp;</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Read3dmSettings</span><span class="p">(</span>
        <span class="n">ON_3dmSettings</span><span class="o">&amp;</span>
        <span class="p">);</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 4: REQUIRED - Write/Read bitmap table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmBitmapTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmBitmap</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Bitmap</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmBitmapTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmBitmapTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmBitmap</span><span class="p">(</span>   <span class="c1">// returns 0 at end of light table</span>
                        <span class="c1">//         1 bitmap successfully read</span>
            <span class="n">ON_Bitmap</span><span class="o">**</span> <span class="c1">// bitmap returned here</span>
            <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmBitmapTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 5: REQUIRED - Write/Read render material table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmTextureMappingTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmTextureMapping</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_TextureMapping</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmTextureMappingTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmTextureMappingTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmTextureMapping</span><span class="p">(</span> <span class="c1">// returns 0 at end of table</span>
            <span class="n">ON_TextureMapping</span><span class="o">**</span> <span class="c1">// layer returned here</span>
            <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmTextureMappingTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 6: REQUIRED - Write/Read render material table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmMaterialTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmMaterial</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Material</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmMaterialTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmMaterialTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmMaterial</span><span class="p">(</span> <span class="c1">// returns 0 at end of table</span>
            <span class="n">ON_Material</span><span class="o">**</span> <span class="c1">// layer returned here</span>
            <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmMaterialTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 7: REQUIRED - Write/Read linetype table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmLinetypeTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmLinetype</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Linetype</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmLinetypeTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmLinetypeTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmLinetype</span><span class="p">(</span><span class="n">ON_Linetype</span><span class="o">**</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmLinetypeTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 8: REQUIRED - Write/Read layer table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmLayerTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmLayer</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Layer</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmLayerTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmLayerTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmLayer</span><span class="p">(</span> <span class="c1">// returns 0 at end of table</span>
            <span class="n">ON_Layer</span><span class="o">**</span> <span class="c1">// layer returned here</span>
            <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmLayerTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 9: REQUIRED - Write/Read group table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmGroupTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmGroup</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Group</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmGroupTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmGroupTable</span><span class="p">();</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Reads groups from group table.  If the group definition is</span>
  <span class="c1">//   read, a group is created by calling new ON_Group(),</span>
  <span class="c1">//   initialized with values stored in the archive, and</span>
  <span class="c1">//   returned.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   ppGroup - If the group definition is</span>
  <span class="c1">//   read, a group is created by calling new ON_Group(),</span>
  <span class="c1">//   initialized with values stored in the archive, and</span>
  <span class="c1">//   a pointer to the new group is returned in *ppGroup.</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//</span>
  <span class="c1">//   @untitled table</span>
  <span class="c1">//   0     at the end of the group table</span>
  <span class="c1">//   1     group definition was successfully read</span>
  <span class="c1">//   -1    archive is corrupt at this point</span>
  <span class="c1">//</span>
  <span class="c1">// Example:</span>
  <span class="c1">//   Calls to Read3dmGroup need to be bracketed by calls</span>
  <span class="c1">//   to BeginRead3dmGroupTable() / EndRead3dmGroupTable().</span>
  <span class="c1">//</span>
  <span class="c1">//           archive.BeginRead3dmGroupTable();</span>
  <span class="c1">//           ON_Group* pGroup;</span>
  <span class="c1">//           int rc = 1;</span>
  <span class="c1">//           while(rc==1)</span>
  <span class="c1">//           { //</span>
  <span class="c1">//             pGroup = 0;</span>
  <span class="c1">//             archive.Read3dmGroup(&amp;pGroup);</span>
  <span class="c1">//             if ( pGroup )</span>
  <span class="c1">//               do something with pGroup</span>
  <span class="c1">//           } //</span>
  <span class="c1">//           archive.EndRead3dmGroupTable();</span>
  <span class="c1">//</span>
  <span class="kt">int</span>  <span class="nf">Read3dmGroup</span><span class="p">(</span>
            <span class="n">ON_Group</span><span class="o">**</span> <span class="c1">// ppGroup</span>
            <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">EndRead3dmGroupTable</span><span class="p">();</span>


  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 10: REQUIRED - Write/Read font table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmFontTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmFont</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Font</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmFontTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmFontTable</span><span class="p">();</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Reads fonts from font table.  If the font definition is</span>
  <span class="c1">//   read, a font is created by calling new ON_Font(),</span>
  <span class="c1">//   initialized with values stored in the archive, and</span>
  <span class="c1">//   returned.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   ppFont - If the font definition is</span>
  <span class="c1">//   read, a font is created by calling new ON_Font(),</span>
  <span class="c1">//   initialized with values stored in the archive, and</span>
  <span class="c1">//   a pointer to the new font is returned in *ppFont.</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//</span>
  <span class="c1">//   @untitled table</span>
  <span class="c1">//   0     at the end of the font table</span>
  <span class="c1">//   1     font definition was successfully read</span>
  <span class="c1">//   -1    archive is corrupt at this point</span>
  <span class="c1">//</span>
  <span class="c1">// Example:</span>
  <span class="c1">//   Calls to Read3dmFont need to be bracketed by calls</span>
  <span class="c1">//   to BeginRead3dmFontTable() / EndRead3dmFontTable().</span>
  <span class="c1">//</span>
  <span class="c1">//           archive.BeginRead3dmFontTable();</span>
  <span class="c1">//           int rc = 1;</span>
  <span class="c1">//           ON_Font* pFont;</span>
  <span class="c1">//           while(rc==1)</span>
  <span class="c1">//           { //</span>
  <span class="c1">//             pFont = 0;</span>
  <span class="c1">//             archive.Read3dmFont(&amp;pFont);</span>
  <span class="c1">//             if ( pFont )</span>
  <span class="c1">//               do something with pFont</span>
  <span class="c1">//           } //</span>
  <span class="c1">//           archive.EndRead3dmFontTable();</span>
  <span class="c1">//</span>
  <span class="kt">int</span> <span class="nf">Read3dmFont</span><span class="p">(</span>
            <span class="n">ON_Font</span><span class="o">**</span> <span class="c1">// ppFont</span>
            <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">EndRead3dmFontTable</span><span class="p">();</span>


  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 11: REQUIRED - Write/Read dimstyle table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmDimStyleTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmDimStyle</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_DimStyle</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmDimStyleTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmDimStyleTable</span><span class="p">();</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Reads annotation dimension styles from dimension style table.</span>
  <span class="c1">//   If the dimension style definition is read,</span>
  <span class="c1">//   a dimension style is created by calling new ON_DimStyle(),</span>
  <span class="c1">//   initialized with values stored in the archive, and</span>
  <span class="c1">//   returned.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   ppDimStyle - If the dimstyle definition is</span>
  <span class="c1">//   read, a dimstyle is created by calling new ON_DimStyle(),</span>
  <span class="c1">//   initialized with values stored in the archive, and</span>
  <span class="c1">//   a pointer to the new dimstyle is returned in *ppDimStyle.</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//</span>
  <span class="c1">//   @untitled table</span>
  <span class="c1">//   0     at the end of the dimension style table</span>
  <span class="c1">//   1     dimension style definition was successfully read</span>
  <span class="c1">//   -1    archive is corrupt at this point</span>
  <span class="c1">//</span>
  <span class="c1">// Example:</span>
  <span class="c1">//   Calls to Read3dmDimStyle need to be bracketed by calls</span>
  <span class="c1">//   to BeginRead3dmDimStyleTable() / EndRead3dmDimStyleTable().</span>
  <span class="c1">//</span>
  <span class="c1">//           archive.BeginRead3dmDimStyleTable();</span>
  <span class="c1">//           int rc = 1;</span>
  <span class="c1">//           ON_DimStyle* pDimStyle;</span>
  <span class="c1">//           while(rc==1)</span>
  <span class="c1">//           { //</span>
  <span class="c1">//             pDimStyle = 0;</span>
  <span class="c1">//             archive.Read3dmDimStyle(&amp;pDimStyle);</span>
  <span class="c1">//             if ( pDimStyle )</span>
  <span class="c1">//               do something with pDimStyle</span>
  <span class="c1">//           } //</span>
  <span class="c1">//           archive.EndRead3dmDimStyleTable();</span>
  <span class="c1">//</span>
  <span class="kt">int</span> <span class="nf">Read3dmDimStyle</span><span class="p">(</span>
            <span class="n">ON_DimStyle</span><span class="o">**</span> <span class="c1">// ppDimStyle</span>
            <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">EndRead3dmDimStyleTable</span><span class="p">();</span>


  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 12: REQUIRED - Write/Read render light table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmLightTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmLight</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Light</span><span class="o">&amp;</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">ON_3dmObjectAttributes</span><span class="o">*</span> <span class="c1">// optional</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmLightTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmLightTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmLight</span><span class="p">(</span>  <span class="c1">// returns 0 at end of light table</span>
                      <span class="c1">//         1 light successfully read</span>
                      <span class="c1">//        -1 if file is corrupt</span>
            <span class="n">ON_Light</span><span class="o">**</span><span class="p">,</span> <span class="c1">// light returned here</span>
            <span class="n">ON_3dmObjectAttributes</span><span class="o">*</span> <span class="c1">// optional - if NOT NULL, object attributes are</span>
                                    <span class="c1">//            returned here</span>
            <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmLightTable</span><span class="p">();</span>


  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 13: REQUIRED - Write/Read hatch pattern table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmHatchPatternTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmHatchPattern</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_HatchPattern</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmHatchPatternTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmHatchPatternTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmHatchPattern</span><span class="p">(</span><span class="n">ON_HatchPattern</span><span class="o">**</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmHatchPatternTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 14: REQUIRED - Write/Read instance definition table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmInstanceDefinitionTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmInstanceDefinition</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_InstanceDefinition</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmInstanceDefinitionTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmInstanceDefinitionTable</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">   Description:</span>
<span class="cm">     Reads instance definitions from instance defintion table.</span>

<span class="cm">   Parameters:</span>
<span class="cm">     ppInstanceDefinition - If an instance defintion is</span>
<span class="cm">     read, an instance defintion is created by calling new</span>
<span class="cm">     ON_InstanceDefinition(), initialized with values stored</span>
<span class="cm">     in the archive, and a pointer to the new instance defintion</span>
<span class="cm">     is returned in *ppInstanceDefinition.</span>

<span class="cm">   Returns:</span>

<span class="cm">     @untitled table</span>
<span class="cm">     0     at the end of the instance defintion table</span>
<span class="cm">     1     instance defintion was successfully read</span>
<span class="cm">     -1    archive is corrupt at this point</span>

<span class="cm">   Example:</span>
<span class="cm">     Calls to Read3dmInstanceDefinition need to be bracketed by calls</span>
<span class="cm">     to BeginRead3dmInstanceDefinitionTable() / EndRead3dmInstanceDefinitionTable().</span>

<span class="cm">             archive.BeginRead3dmInstanceDefinitionTable();</span>
<span class="cm">             int rc = 1;</span>
<span class="cm">             ON_InstanceDefinition* pInstanceDefinition;</span>
<span class="cm">             while(rc==1)</span>
<span class="cm">             {</span>
<span class="cm">               pInstanceDefinition = 0;</span>
<span class="cm">               archive.Read3dmInstanceDefinition(&amp;pInstanceDefinition);</span>
<span class="cm">               if ( pInstanceDefinition )</span>
<span class="cm">                 do something with pInstanceDefinition</span>
<span class="cm">             }</span>
<span class="cm">             archive.EndRead3dmInstanceDefinitionTable();</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Read3dmInstanceDefinition</span><span class="p">(</span>
            <span class="n">ON_InstanceDefinition</span><span class="o">**</span> <span class="c1">// ppInstanceDefinition</span>
            <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">EndRead3dmInstanceDefinitionTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 15: REQUIRED - Write/Read geometry and annotation table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmObjectTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmObject</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">ON_3dmObjectAttributes</span><span class="o">*</span> <span class="c1">// optional</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmObjectTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmObjectTable</span><span class="p">();</span>
  <span class="kt">int</span>  <span class="nf">Read3dmObject</span><span class="p">(</span> <span class="c1">// returns 0 at end of object table</span>
                      <span class="c1">//         1 if object is read</span>
                      <span class="c1">//         2 if object is skipped because it does not match filter</span>
                      <span class="c1">//        -1 if file is corrupt</span>
          <span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span> <span class="o">//</span> <span class="n">object</span> <span class="n">returned</span> <span class="n">here</span> <span class="p">(</span><span class="nb">NULL</span> <span class="k">if</span> <span class="n">skipped</span><span class="p">)</span>
          <span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">,</span> <span class="c1">// optional - if NOT NULL, object attributes are</span>
                                   <span class="c1">//            returned here</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// optional filter made by setting ON::object_type bits</span>
          <span class="p">);</span>  <span class="c1">// returns NULL at end of object table</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmObjectTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 16: REQUIRED - Write/Read history record table (it can be empty)</span>
  <span class="c1">//</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmHistoryRecordTable</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write3dmHistoryRecord</span><span class="p">(</span>
         <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_HistoryRecord</span><span class="o">&amp;</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmHistoryRecordTable</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginRead3dmHistoryRecordTable</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">           0 at end of object table</span>
<span class="cm">           1 if object is read</span>
<span class="cm">          -1 if file is corrupt</span>
<span class="cm">  */</span>
  <span class="kt">int</span>  <span class="nf">Read3dmHistoryRecord</span><span class="p">(</span>
          <span class="k">class</span> <span class="nc">ON_HistoryRecord</span><span class="o">*&amp;</span>
          <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmHistoryRecordTable</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 17: OPTIONAL - Write/Read 0 or more user tables</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Write the user table header information that must precede</span>
<span class="cm">    the user table information written by a plug-in.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plugin_id - [in]</span>
<span class="cm">    bSavingGoo - [in]</span>
<span class="cm">      Set to false if a plug-in will be used to write</span>
<span class="cm">      the user table.  Set to true if a user table written by</span>
<span class="cm">      a missing plug-in is being resaved. In this case,</span>
<span class="cm">      goo_3dm_version and goo_opennurbs_version must also be</span>
<span class="cm">      set.  In practice, you should use Write3dmAnonymousUserTableRecord()</span>
<span class="cm">      to handle writing &quot;goo&quot; and use this function only when</span>
<span class="cm">      the plug-in in present.</span>
<span class="cm">    goo_3dm_version - [in]</span>
<span class="cm">      If bSavingGoo is false, this parameter must be zero and</span>
<span class="cm">      ON_BinaryArchive::Archive3dmVersion() will be used.</span>
<span class="cm">      If bSavingGoo is true, this parameter must be the version of</span>
<span class="cm">      the 3dm archive (1,2,3,4,5,50,...) the plug-in code used to</span>
<span class="cm">      write the user table.</span>
<span class="cm">    goo_opennurbs_version - [in]</span>
<span class="cm">      If bSavingGoo is false, this parameter must be zero and</span>
<span class="cm">      ON_BinaryArchive::ArchiveOpenNURBSVersion() will be used.</span>
<span class="cm">      If bSavingGoo is true, this parameter must be the version</span>
<span class="cm">      of the opennurbs (YYYYMMDDN) the plug-in code used to</span>
<span class="cm">      write the user table.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the the user information can be written.</span>
<span class="cm">    False if user informtion should not be written.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmUserTable</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="n">plugin_id</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bSavingGoo</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">goo_3dm_version</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">goo_opennurbs_version</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">EndWrite3dmUserTable</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If Read3dmAnaonymousUserTable() was used to read ON_3dmGoo because a</span>
<span class="cm">    plug-in was not present, then use Write3dmAnonymousUserTableRecord()</span>
<span class="cm">    to put than information back into the archive.</span>
<span class="cm">    Write3dmAnonymousUserTableRecord() writes the entire record.</span>
<span class="cm">    Do NOT call BeginWrite3dmUserTable() / EndWrite3dmUserTable() when</span>
<span class="cm">    using Write3dmAnonymousUserTableRecord().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plugin_id - [in]</span>
<span class="cm">    goo_version - [in]</span>
<span class="cm">      The version of the archive (1,2,3,4,5,50,...) that was used when</span>
<span class="cm">      the plug-in wrote the user table.</span>
<span class="cm">    goo_opennurbs_version - [in]</span>
<span class="cm">      The version of opennurbs ( YYYMMDDN ) that was used when the</span>
<span class="cm">      plug-in wrote the user table.</span>
<span class="cm">    goo - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the goo was written or skipped because it could not be robustly</span>
<span class="cm">    saved.  False if a catastrophic IO error occured.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Write3dmAnonymousUserTableRecord</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="n">plugin_id</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">goo_3dm_version</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">goo_opennurbs_version</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="n">goo</span>
    <span class="p">);</span>

  <span class="c1">// OBSOLETE - use BeginWrite3dmUserTable(plugin_id, bSavingGoo, 3dm_version, opennurbs_version )</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">bool</span> <span class="nf">BeginWrite3dmUserTable</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="c1">// OBSOLETE - use Write3dmAnonymousUserTableRecord(plugin_id, ..., goo)</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">bool</span> <span class="nf">Write3dmAnonymousUserTable</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plugin_id - [out]</span>
<span class="cm">      id of plug-in that wrote the user table</span>
<span class="cm">    bLastSavedAsGoo - [out]</span>
<span class="cm">      True if this table was saved into this archive as goo because</span>
<span class="cm">      the plug-in was not present at the time of the save.</span>
<span class="cm">    archive_3dm_version - [out]</span>
<span class="cm">      Version of the archive the plug-in wrote to.  When bLastSavedAsGoo</span>
<span class="cm">      is true, this number can be different from Archive3dmVersion().</span>
<span class="cm">    archive_opennurbs_version - [out]</span>
<span class="cm">      Version of opennurbs the plug-in used to write the archive.</span>
<span class="cm">      When bLastSavedAsGoo is true, this number can be different</span>
<span class="cm">      from ArchiveOpenNURBSVersion().</span>
<span class="cm">  Returns:</span>
<span class="cm">    False when there are no more user tables or an IO error occurs.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">BeginRead3dmUserTable</span><span class="p">(</span>
    <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="n">plugin_id</span><span class="p">,</span>
    <span class="kt">bool</span><span class="o">*</span> <span class="n">bLastSavedAsGoo</span><span class="p">,</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">archive_3dm_version</span><span class="p">,</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">archive_opennurbs_version</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If the plug-in that wrote the user table is not present and you need</span>
<span class="cm">    to read and resave the user table, then use Read3dmAnonymousUserTable()</span>
<span class="cm">    to load the information into &quot;goo&quot;.</span>
<span class="cm">    If you do not need to resave the information, then simply call EndRead3dmUserTable()</span>
<span class="cm">    to skip over this table.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Read3dmAnonymousUserTable</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">archive_3dm_version</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">archive_opennurbs_version</span><span class="p">,</span>
    <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="n">goo</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">EndRead3dmUserTable</span><span class="p">();</span>

  <span class="c1">// OBSOLETE - use BeginRead3dmUserTable( plugin_id, bLastSavedAsGoo, archive_3dm_version, ... )</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">bool</span> <span class="nf">BeginRead3dmUserTable</span><span class="p">(</span>
    <span class="n">ON_UUID</span><span class="o">&amp;</span>
    <span class="p">);</span>

  <span class="c1">// OBSOLETE - use Read3dmAnonymousUserTable( archive_3dm_version, archive_opennurbs_version, goo )</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">bool</span> <span class="nf">Read3dmAnonymousUserTable</span><span class="p">(</span> <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="p">);</span>




  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Step 18: REQUIRED when writing / OPTIONAL when reading</span>
  <span class="c1">//         Write end of file marker.  This information is primarily</span>
  <span class="c1">//         used when debugging files to make sure the end of the file</span>
  <span class="c1">//         hasn&#39;t been cut off.</span>
  <span class="c1">//</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Writes a TCODE_ENDOFFILE chunk that contains the number</span>
  <span class="c1">//   of bytes in the archive.</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   true if successful, false if unable to write to archive.</span>
  <span class="kt">bool</span> <span class="nf">Write3dmEndMark</span><span class="p">();</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Checks for a TCODE_ENDOFFILE chunk at the current position.</span>
  <span class="c1">//   If it finds one, it reads it and returns the number</span>
  <span class="c1">//   of bytes in the archive.  Comparing this number with</span>
  <span class="c1">//   the current file position can help detect files that</span>
  <span class="c1">//   have been damaged by loosing sections.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   sizeof_archive - [out] number of bytes written to archive</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   true if successful, false if unable to find or read</span>
  <span class="c1">//   a TCODE_ENDOFFILE chunk.</span>
  <span class="kt">bool</span> <span class="nf">Read3dmEndMark</span><span class="p">(</span>
           <span class="kt">size_t</span><span class="o">*</span> <span class="c1">// sizeof_archive</span>
           <span class="p">);</span>

  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Low level tools to  Write/Read chunks. See opennurbs_3dm.h for details</span>
  <span class="c1">// about the structure of chunks.  Every chunk must begin with a</span>
  <span class="c1">// call to BeginWrite/ReadChunk().</span>
  <span class="c1">// If BeginWriteChunk()/BeginReadChunk() returns true, then</span>
  <span class="c1">// you must call EndWrite/ReadChunk() or cease using the archive.</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Writes a chunk header containing 4 byte typecode and value.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   typecode - [in] a TCODE_* number from opennurbs_3dm.h</span>
  <span class="c1">//   value    - [in] if (typecode&amp;TCODE_SHORT) is nonzero, then</span>
  <span class="c1">//              this is the value to be saved.  Othewise, pass</span>
  <span class="c1">//              a zero and the EndWrite3dmChunk() call will</span>
  <span class="c1">//              store the length of the chunk.</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   true if write was successful.</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmChunk</span><span class="p">(</span>
        <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="c1">// typecode</span>
        <span class="kt">int</span> <span class="c1">// value</span>
        <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">BeginWrite3dmBigChunk</span><span class="p">(</span>
        <span class="n">ON__UINT32</span> <span class="n">typecode</span><span class="p">,</span>
        <span class="n">ON__INT64</span> <span class="n">value</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Begins writing a chunk.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    tcode - [in] chunk&#39;s typecode from opennurbs_3dm.h.  This cannot be a short tcode.</span>
<span class="cm">    major_version - [in] ( &gt;= 1)</span>
<span class="cm">    minor_version - [in] ( &gt;= 0 )</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if input was valid and chunk was started.  In this case</span>
<span class="cm">    You must call EndWrite3dmChunk(), even if something goes wrong</span>
<span class="cm">    while you attempt to write the contents of the chunk.</span>
<span class="cm">    False if input was not valid or the write failed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">BeginWrite3dmChunk</span><span class="p">(</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcode</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">major_version</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">minor_version</span>
        <span class="p">);</span>


  <span class="c1">// updates length in chunk header</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmChunk</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">Write3dmGoo</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// call to write &quot;goo&quot;</span>

  <span class="c1">// OBSOLETE - Use BeginRead3dmBigChunk()</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">bool</span> <span class="nf">BeginRead3dmChunk</span><span class="p">(</span>
        <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span>   <span class="c1">// typecode from opennurbs_3dm.h</span>
        <span class="kt">int</span><span class="o">*</span>             <span class="c1">// value</span>
        <span class="p">);</span>

  <span class="c1">// When the end of the 3dm file is reached, BeginReadChunk() will</span>
  <span class="c1">// return true with a typecode of TCODE_ENDOFFILE.</span>
  <span class="kt">bool</span> <span class="nf">BeginRead3dmBigChunk</span><span class="p">(</span>
        <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span>   <span class="c1">// typecode from opennurbs_3dm.h</span>
        <span class="n">ON__INT64</span><span class="o">*</span>       <span class="c1">// value</span>
        <span class="p">);</span>
  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Begins reading a chunk that must be in the archive at this location.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    expected_tcode - [in] chunk&#39;s typecode from opennurbs_3dm.h</span>
<span class="cm">    major_version - [out]</span>
<span class="cm">    minor_version - [out]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if beginning of the chunk was read.  In this case</span>
<span class="cm">    You must call EndRead3dmChunk(), even if something goes wrong</span>
<span class="cm">    while you attempt to read the interior of the chunk.</span>
<span class="cm">    False if the chunk did not exist at the current location in the file.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">BeginRead3dmChunk</span><span class="p">(</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expected_tcode</span><span class="p">,</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">major_version</span><span class="p">,</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">minor_version</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calling this will skip rest of stuff in chunk if it was only partially read.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bSupressPartiallyReadChunkWarning - [in]</span>
<span class="cm">      Generally, a call to ON_WARNING is made when a chunk is partially</span>
<span class="cm">      read.  If bSupressPartiallyReadChunkWarning is true, then</span>
<span class="cm">      no warning is issued for partially read chunks.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmChunk</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmChunk</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bSupressPartiallyReadChunkWarning</span><span class="p">);</span>


  <span class="c1">///////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Tools for dictionary IO (used in .NET)</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Begins writing a dictionary.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dictionary_id - [in]</span>
<span class="cm">    version - [in]</span>
<span class="cm">      It is suggested that you use YYYYMMDD as the version number.</span>
<span class="cm">    dictionary_name - [in]</span>
<span class="cm">      You may pass NULL.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Begins a new chunk with tcode TCODE_DICTIONARY and then writes</span>
<span class="cm">    a TCODE_DICTIONARY_ID chunk containing the id, version and name.</span>
<span class="cm">    After calling this function, you may either write entries by</span>
<span class="cm">    calling</span>
<span class="cm">      BeginWriteDictionaryEntry();</span>
<span class="cm">      write entry definition...</span>
<span class="cm">      EndWriteDictionaryEntry();</span>
<span class="cm">    or you may finish writing the dictionay by calling</span>
<span class="cm">      EndWriteDictionary();</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">BeginWriteDictionary</span><span class="p">(</span>
          <span class="n">ON_UUID</span> <span class="n">dictionary_id</span><span class="p">,</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">dictionary_name</span>
          <span class="p">);</span>
  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Begins writing a dictionary entry.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    de_type - [in]</span>
<span class="cm">    entry_name - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    true</span>
<span class="cm">      Entry header was written and you must call EndWriteDictionary()</span>
<span class="cm">      after writing the entry data.</span>
<span class="cm">    false</span>
<span class="cm">      Failed to write entry header.  Do not call EndWriteDictionary().</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Begins a new chunk with tcode TCODE_DICTIONARY_ENTRY,</span>
<span class="cm">    then writes the int, and then writes the string.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">EndWriteDictionary</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Begins writing a dictionary entry.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    de_type - [in]</span>
<span class="cm">    entry_name - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    true</span>
<span class="cm">      Entry header was written and you must call EndWriteDictionary()</span>
<span class="cm">      after writing the entry data.</span>
<span class="cm">    false</span>
<span class="cm">      Failed to write entry header.  Do not call EndWriteDictionary().</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Begins a new chunk with tcode TCODE_DICTIONARY_ENTRY,</span>
<span class="cm">    then writes the int, and then writes the string.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">BeginWriteDictionaryEntry</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">de_type</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">entry_name</span>
          <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWriteDictionaryEntry</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">BeginReadDictionary</span><span class="p">(</span>
          <span class="n">ON_UUID</span><span class="o">*</span> <span class="n">dictionary_id</span><span class="p">,</span>
          <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">version</span><span class="p">,</span>
          <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">dictionary_name</span>
          <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndReadDictionary</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Begin reading a dictionary entry.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    de_type - [out]</span>
<span class="cm">    entry_name - [out]</span>
<span class="cm">  Returns:</span>
<span class="cm">    0: serious IO error</span>
<span class="cm">    1: success</span>
<span class="cm">        read information and then call EndReadDictionaryEntry()</span>
<span class="cm">    2: at end of dictionary</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">BeginReadDictionaryEntry</span><span class="p">(</span>
          <span class="kt">int</span><span class="o">*</span> <span class="n">de_type</span><span class="p">,</span>
          <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">entry_name</span>
          <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndReadDictionaryEntry</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">Read3dmGoo</span><span class="p">(</span> <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// Call to read &quot;goo&quot;</span>

  <span class="c1">// OBSOLETE - Use PeekAt3dmBigChunkType()</span>
  <span class="n">ON_DEPRECATED</span> <span class="kt">bool</span> <span class="nf">PeekAt3dmChunkType</span><span class="p">(</span> <span class="c1">// does not change file position</span>
        <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">,</span>   <span class="c1">// typecode from opennurbs_3dm.h</span>
        <span class="kt">int</span><span class="o">*</span>             <span class="c1">// value</span>
        <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">PeekAt3dmBigChunkType</span><span class="p">(</span> <span class="c1">// does not change file position</span>
        <span class="n">ON__UINT32</span><span class="o">*</span> <span class="n">typecode</span><span class="p">,</span>
        <span class="n">ON__INT64</span><span class="o">*</span> <span class="n">big_value</span>
        <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Seek3dmChunkFromStart</span><span class="p">(</span>
        <span class="c1">// beginning at the start of the active chunk, search portion of</span>
        <span class="c1">// archive included in active chunk for the start of a subchunk</span>
        <span class="c1">// with the specified type.</span>
        <span class="c1">// if true is returned, then the position is set so the next call to</span>
        <span class="o">//</span> <span class="n">BeginRead3dmChunk</span><span class="p">()</span> <span class="n">will</span> <span class="n">read</span> <span class="n">a</span> <span class="n">chunk</span> <span class="n">with</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">typecode</span>
        <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="c1">// typecode from opennurbs_3dm.h</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Seek3dmChunkFromCurrentPosition</span><span class="p">(</span>
        <span class="c1">// beginning at the current position, search portion of archive</span>
        <span class="c1">// included in active chunk for the start of a subchunk with the</span>
        <span class="c1">// specified type.</span>
        <span class="c1">// if true is returned, then the position is set so the next call to</span>
        <span class="o">//</span> <span class="n">BeginRead3dmChunk</span><span class="p">()</span> <span class="n">will</span> <span class="n">read</span> <span class="n">a</span> <span class="n">chunk</span> <span class="n">with</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">typecode</span>
        <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="c1">// typecode from opennurbs_3dm.h</span>
        <span class="p">);</span>

  <span class="c1">// A chunk version is a single byte that encodes a major.minor</span>
  <span class="c1">// version number.  Useful when creating I/O code for 3dm chunks</span>
  <span class="c1">// that may change in the future.  Increment the minor version</span>
  <span class="c1">// number if new information is added to the end of the chunk.</span>
  <span class="c1">// Increment the major version if the format of the chunk changes</span>
  <span class="c1">// in some other way.</span>
  <span class="kt">bool</span> <span class="nf">Write3dmChunkVersion</span><span class="p">(</span>
    <span class="kt">int</span><span class="p">,</span> <span class="c1">// major // 0 to 15</span>
    <span class="kt">int</span>  <span class="c1">// minor // 0 to 16</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Read3dmChunkVersion</span><span class="p">(</span>
    <span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="c1">// major // 0 to 15</span>
    <span class="kt">int</span><span class="o">*</span>  <span class="c1">// minor // 0 to 16</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Low level tool to writes user data attached to the</span>
<span class="cm">    object.  This function should never be called</span>
<span class="cm">    directly.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    object - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">WriteObjectUserData</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="n">object</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Low level tool to read user data and attach it to</span>
<span class="cm">    the object.  This function should never be called</span>
<span class="cm">    directly.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    object - [in/out]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReadObjectUserData</span><span class="p">(</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="n">object</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If a 3dm archive is being read or written, then this is the</span>
<span class="cm">    version of the 3dm archive format (1, 2, 3, 4 or 5).</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitle table</span>
<span class="cm">    0     a 3dm archive is not being read/written</span>
<span class="cm">    1     a version 1 3dm archive is being read/written</span>
<span class="cm">    2     a version 2 3dm archive is being read/written</span>
<span class="cm">    3     a version 3 3dm archive is being read/written</span>
<span class="cm">    4     a version 4 3dm archive is being read/written</span>
<span class="cm">    5     an old version 5 3dm archive is being read</span>
<span class="cm">    50    a version 5 3dm archive is being read/written</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_BinaryArchive::ArchiveOpenNURBSVersion</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Archive3dmVersion</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If a 3dm archive is being read, then this is the version</span>
<span class="cm">    of openNURBS that was used to write the archive.  This value</span>
<span class="cm">    is only available after ON_BinaryArchive::Read3dmProperties</span>
<span class="cm">    is called.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_BinaryArchive::Archive3dmVersion</span>
<span class="cm">    ON_BinaryArchive::Read3dmProperties</span>
<span class="cm">  Returns:</span>
<span class="cm">    Version of openNURBS used to write the archive.  The openNURBS</span>
<span class="cm">    version is the value returned by ON::Version.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON::Version</span>
<span class="cm">    ON_BinaryArchive::Read3dmProperties</span>
<span class="cm">    ON_BinaryArchive::Archive3dmVersion</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This value is rarely needed.  You probably want to</span>
<span class="cm">    use ON_BinaryArchive::Archive3dmVersion.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">ArchiveOpenNURBSVersion</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    When a 3dm archive is saved from an MFC application that</span>
<span class="cm">    supports Windows linking/embedding, the first 5kb to 1mb</span>
<span class="cm">    of the file contains information that is put there by MFC.</span>
<span class="cm">    ArchiveStartOffset() returns the offset into the file where</span>
<span class="cm">    the 3dm archive actually begins. The call to</span>
<span class="cm">    ON_BinaryArchive::Read3dmStartSection() calculates this</span>
<span class="cm">    offset and stores the value in m_3dm_start_section_offset.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Offset into the binary &quot;file&quot; where the actual 3dm archive</span>
<span class="cm">    begins.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Generally, this value can be ignored. This function is</span>
<span class="cm">    a diagnostice tool that is used to analyzed damaged files.</span>
<span class="cm">  */</span>
  <span class="kt">size_t</span> <span class="nf">ArchiveStartOffset</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">enum</span> <span class="n">table_type</span>
  <span class="p">{</span>
    <span class="n">no_active_table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">properties_table</span><span class="p">,</span>
    <span class="n">settings_table</span><span class="p">,</span>
    <span class="n">bitmap_table</span><span class="p">,</span>
    <span class="n">texture_mapping_table</span><span class="p">,</span>
    <span class="n">material_table</span><span class="p">,</span>
    <span class="n">linetype_table</span><span class="p">,</span>
    <span class="n">layer_table</span><span class="p">,</span>
    <span class="n">light_table</span><span class="p">,</span>
    <span class="n">object_table</span><span class="p">,</span>
    <span class="n">group_table</span><span class="p">,</span>
    <span class="n">font_table</span><span class="p">,</span>
    <span class="n">dimstyle_table</span><span class="p">,</span>
    <span class="n">hatchpattern_table</span><span class="p">,</span>
    <span class="n">instance_definition_table</span><span class="p">,</span>
    <span class="n">historyrecord_table</span><span class="p">,</span>
    <span class="n">user_table</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function for reading damaged files.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    chunk - [out] current chunk.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Level of the chunk or 0 if there is no current</span>
<span class="cm">    chunk.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetCurrentChunk</span><span class="p">(</span><span class="n">ON_3DM_CHUNK</span><span class="o">&amp;</span> <span class="n">chunk</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">GetCurrentChunk</span><span class="p">(</span><span class="n">ON_3DM_BIG_CHUNK</span><span class="o">&amp;</span> <span class="n">big_chunk</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function for reading damaged files.  The search starts</span>
<span class="cm">    at the beginning of the file.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    tcode_table - [in] typecode of the table</span>
<span class="cm">    tcode_record - [in] typecode of the record</span>
<span class="cm">    class_uuid - [in] id of the opennurbs class in the record</span>
<span class="cm">    min_length_data - [in] minimum size of the opennurbs class data</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the table start is found.  In this case the current</span>
<span class="cm">    position of the archive is at the start of the table and</span>
<span class="cm">    the standared BeginRead3dm...Table() function can be used.</span>
<span class="cm">    False if the table start is not found.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">FindTableInDamagedArchive</span><span class="p">(</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcode_table</span><span class="p">,</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcode_record</span><span class="p">,</span>
          <span class="n">ON_UUID</span> <span class="n">class_uuid</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">min_length_data</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function for studying contents of a file.</span>
<span class="cm">    The primary use is as an aid to help dig through files</span>
<span class="cm">    that have been damaged (bad disks, transmission errors, etc.)</span>
<span class="cm">    If an error is found, a line that begins with the word</span>
<span class="cm">    &quot;ERROR&quot; is printed.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] place to print informtion</span>
<span class="cm">    recursion_depth - [in] simply a counter</span>
<span class="cm">        to aid in debugging.</span>
<span class="cm">  Returns:</span>
<span class="cm">    0 if something went wrong, otherwise the typecode</span>
<span class="cm">    of the chunk that was just studied.</span>
<span class="cm">  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>
  <span class="nf">Dump3dmChunk</span><span class="p">(</span>
        <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="n">text_log</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">recursion_depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Works like the C runtrim fread().</span>
<span class="cm">  Returns:</span>
<span class="cm">    actual number of bytes read (like fread())</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">size_t</span> <span class="n">Read</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Works like the C runtrim fwrite().</span>
<span class="cm">  Returns:</span>
<span class="cm">    actual number of bytes written (like fwrite())</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">size_t</span> <span class="nf">Write</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Force Write() to flush any buffered data to physical archive.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful or if there is nothing to flush.  False if</span>
<span class="cm">    information could not be flushed.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">Flush</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    When ON_BinaryArchive::ReadObject() encounters userdata and</span>
<span class="cm">    the user data class id is not present,  LoadUserDataApplication</span>
<span class="cm">    is called to load the application that created user data.</span>
<span class="cm">  Returns:</span>
<span class="cm">    0 - could not load the application</span>
<span class="cm">    1 - successfully loaded the application</span>
<span class="cm">    2 - the application was already loaded</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">int</span> <span class="nf">LoadUserDataApplication</span><span class="p">(</span>
    <span class="n">ON_UUID</span> <span class="n">application_id</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">SetArchive3dmVersion</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// 16 bit integer IO</span>
  <span class="kt">bool</span> <span class="n">WriteInt8</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON__INT8</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInt8</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">ON__INT8</span><span class="o">*</span> <span class="p">);</span>

  <span class="c1">// 16 bit integer IO</span>
  <span class="kt">bool</span> <span class="nf">WriteInt16</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON__INT16</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInt16</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">ON__INT16</span><span class="o">*</span> <span class="p">);</span>

  <span class="c1">// 32 bit integer IO</span>
  <span class="kt">bool</span> <span class="nf">WriteInt32</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON__INT32</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInt32</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">ON__INT32</span><span class="o">*</span> <span class="p">);</span>

  <span class="c1">// 64 bit integer IO</span>
  <span class="kt">bool</span> <span class="nf">WriteInt64</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON__INT64</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInt64</span><span class="p">(</span>  <span class="kt">size_t</span><span class="p">,</span> <span class="n">ON__INT64</span><span class="o">*</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">BeginWrite3dmTable</span><span class="p">(</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="c1">// tcode</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndWrite3dmTable</span><span class="p">(</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="c1">// tcode</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">BeginRead3dmTable</span><span class="p">(</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="c1">// tcode</span>
    <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">EndRead3dmTable</span><span class="p">(</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="c1">// tcode</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Read3dmV1Layer</span><span class="p">(</span> <span class="n">ON_Layer</span><span class="o">*&amp;</span> <span class="p">);</span>
  <span class="kt">int</span>  <span class="nf">Read3dmV1Light</span><span class="p">(</span>  <span class="c1">// returns 0 at end of light table</span>
                      <span class="c1">//         1 light successfully read</span>
                      <span class="c1">//        -1 if file is corrupt</span>
            <span class="n">ON_Light</span><span class="o">**</span><span class="p">,</span> <span class="c1">// light returned here</span>
            <span class="n">ON_3dmObjectAttributes</span><span class="o">*</span> <span class="c1">// optional - if NOT NULL, object attributes are</span>
                                    <span class="c1">//            returned here</span>
            <span class="p">);</span>
  <span class="kt">int</span> <span class="nf">Read3dmV1Material</span><span class="p">(</span> <span class="n">ON_Material</span><span class="o">**</span> <span class="p">);</span>
  <span class="kt">int</span>  <span class="nf">Read3dmV1Object</span><span class="p">(</span> <span class="c1">// returns 0 at end of object table</span>
                      <span class="c1">//         1 if object is read</span>
                      <span class="c1">//         2 if object is skipped because it does not match filter</span>
                      <span class="c1">//        -1 if file is corrupt</span>
          <span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span> <span class="o">//</span> <span class="n">object</span> <span class="n">returned</span> <span class="n">here</span> <span class="p">(</span><span class="nb">NULL</span> <span class="k">if</span> <span class="n">skipped</span><span class="p">)</span>
          <span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">,</span> <span class="c1">// optional - if NOT NULL, object attributes are</span>
                                   <span class="c1">//            returned here</span>
          <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// optional filter made by setting ON::object_type bits</span>
          <span class="p">);</span>  <span class="c1">// returns NULL at end of object table</span>

  <span class="kt">bool</span> <span class="nf">Read3dmV1AttributesOrMaterial</span><span class="p">(</span>
            <span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// attributes,</span>
            <span class="n">ON_Material</span><span class="o">*</span><span class="p">,</span>      <span class="c1">// material,</span>
            <span class="n">ON_BOOL32</span><span class="o">&amp;</span><span class="p">,</span>             <span class="c1">// bHaveMat</span>
            <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>      <span class="c1">// end_mark_tcode</span>
            <span class="k">class</span> <span class="nc">ON__3dmV1_XDATA</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// v1 &quot;xdata&quot;</span>
            <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Read3dmV1String</span><span class="p">(</span> <span class="n">ON_String</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">int</span>  <span class="nf">Read3dmV1LayerIndex</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="c1">// helpers for reading V1 objects</span>
  <span class="kt">bool</span> <span class="n">ReadV1_TCODE_RH_POINT</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_MESH_OBJECT</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_LEGACY_CRV</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_LEGACY_FAC</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_LEGACY_SHL</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_RHINOIO_OBJECT_NURBS_CURVE</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_RHINOIO_OBJECT_NURBS_SURFACE</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_RHINOIO_OBJECT_BREP</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadV1_TCODE_ANNOTATION</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">,</span><span class="n">ON_3dmObjectAttributes</span><span class="o">*</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span> <span class="n">Mode</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// current read/write mode</span>
  <span class="kt">void</span> <span class="nf">UpdateCRC</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">int</span> <span class="nf">ReadObjectHelper</span><span class="p">(</span><span class="n">ON_Object</span><span class="o">**</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">m_3dm_version</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_3dm_v1_layer_index</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_3dm_v1_material_index</span><span class="p">;</span>

  <span class="c1">// The bits in m_error_message_mask are used to mask errors</span>
  <span class="c1">// when we know we are doing something that may generate an</span>
  <span class="c1">// error.</span>
  <span class="c1">//</span>
  <span class="c1">// bit 0x00000001</span>
  <span class="c1">//   V1 files do not have a table structure and are read using</span>
  <span class="c1">//   multiple passes and there are valid situations where a</span>
  <span class="c1">//   4 byte read is attempted at the end of a file.</span>
  <span class="c1">//</span>
  <span class="c1">// bit 0x00000002</span>
  <span class="c1">//   Some v1 files do not have an end mark.  When reading</span>
  <span class="c1">//   these v1 files bit 0x02 is set.</span>
  <span class="c1">//</span>
  <span class="c1">// bit 0x00000004</span>
  <span class="c1">//   Requested read may go beyond end of file.</span>
  <span class="c1">//   One situation where this happens is when a table is not at the</span>
  <span class="c1">//   expected location in a file,</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_error_message_mask</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ErrorMessageMask</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="cm">/*</span>
<span class="cm">  Paramters:</span>
<span class="cm">    sizeof_request - [in]</span>
<span class="cm">      value of count parameter passed to virtual Read() function.</span>
<span class="cm">    sizeof_read - [in]</span>
<span class="cm">      number of bytes actually read by the virtual Read() function.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a call to Read() is permitted to ask for more bytes</span>
<span class="cm">    than are left in the file.  This value varies as the file</span>
<span class="cm">    is read and must be checked at each failure.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">MaskReadError</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="n">sizeof_request</span><span class="p">,</span> <span class="n">ON__UINT64</span> <span class="n">sizeof_read</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>


  <span class="c1">// When a 3DM archive is read, m_3dm_opennurbs_version records the version of</span>
  <span class="c1">// OpenNURBS used to create the archive.  Otherwise, m_3dm_opennurbs_version</span>
  <span class="c1">// is zero.</span>
  <span class="c1">//</span>
  <span class="c1">// Read3dmProperties() sets this to the version of OpenNURBS that was</span>
  <span class="c1">// used to write file file.  If the file was created using a version</span>
  <span class="c1">// of OpenNURBS before 200012210, this number will be zero.</span>
  <span class="c1">//</span>
  <span class="c1">// Write3dmProperties() stores the value returned by ON::Version() in</span>
  <span class="c1">// the archive&#39;s properties table.</span>
  <span class="k">friend</span> <span class="kt">void</span> <span class="n">ON_SetBinaryArchiveOpenNURBSVersion</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">m_3dm_opennurbs_version</span><span class="p">;</span>

  <span class="c1">// When a 3dm archive is saved from an MFC application that supports</span>
  <span class="c1">// Windows linking/embedding, the first 5kb to 1mb of the file contains</span>
  <span class="c1">// information that is put there by MFC.  m_3dm_start_section_offset</span>
  <span class="c1">// records the offset into the file where the 3dm archive actually begins.</span>
  <span class="kt">size_t</span> <span class="n">m_3dm_start_section_offset</span><span class="p">;</span>

  <span class="n">table_type</span> <span class="n">m_active_table</span><span class="p">;</span>

  <span class="n">table_type</span> <span class="nf">TableTypeFromTypecode</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">);</span> <span class="c1">// table type from tcode</span>

  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3DM_BIG_CHUNK</span><span class="o">&gt;</span> <span class="n">m_chunk</span><span class="p">;</span>

  <span class="c1">// stack of chunks</span>
  <span class="kt">bool</span> <span class="nf">PushBigChunk</span><span class="p">(</span> <span class="n">ON__UINT32</span> <span class="n">typecode</span><span class="p">,</span> <span class="n">ON__INT64</span> <span class="n">value</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">WriteChunkTypecode</span><span class="p">(</span> <span class="n">ON__UINT32</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadChunkTypecode</span><span class="p">(</span> <span class="n">ON__UINT32</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteChunkValue</span><span class="p">(</span> <span class="n">ON__UINT32</span> <span class="n">typecode</span><span class="p">,</span> <span class="n">ON__INT64</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteChunkLength</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadChunkValue</span><span class="p">(</span> <span class="n">ON__UINT32</span> <span class="n">typecode</span><span class="p">,</span> <span class="n">ON__INT64</span><span class="o">*</span> <span class="n">value64</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">FindMisplacedTable</span><span class="p">(</span>
        <span class="n">ON__UINT64</span> <span class="n">filelength</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON__UINT32</span> <span class="n">table_tocde</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON__UINT32</span> <span class="n">table_record_record</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_UUID</span> <span class="n">class_uuid</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON__UINT64</span> <span class="n">min_length_data</span>
        <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ReadObjectUserDataAnonymousChunk</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON__UINT64</span> <span class="n">length_TCODE_ANONYMOUS_CHUNK</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">int</span> <span class="n">archive_3dm_version</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">int</span> <span class="n">archive_opennurbs_version</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">ON_UserData</span><span class="o">*</span> <span class="n">ud</span> <span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">size_t</span> <span class="n">SizeofChunkLength</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">WriteEOFSizeOfFile</span><span class="p">(</span> <span class="n">ON__UINT64</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadEOFSizeOfFile</span><span class="p">(</span> <span class="n">ON__UINT64</span><span class="o">*</span> <span class="p">);</span>

  <span class="kt">bool</span> <span class="n">m_bDoChunkCRC</span><span class="p">;</span> <span class="c1">// true if active chunk crc status should be checked</span>
                      <span class="c1">// and updated.</span>
  <span class="kt">int</span> <span class="n">m_bad_CRC_count</span><span class="p">;</span> <span class="c1">// number of chunks that have a bad crc</span>


<span class="k">private</span><span class="o">:</span>
  <span class="c1">// compressed buffer I/O uses zlib 1.1.3 inflate()/deflate()</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span> <span class="n">mode</span><span class="p">;</span> <span class="c1">// ON::read = read and inflate,  ON::write = deflate and write</span>
    <span class="k">enum</span>
    <span class="p">{</span>
      <span class="n">sizeof_x_buffer</span> <span class="o">=</span> <span class="mi">16384</span>
    <span class="p">};</span>
    <span class="kt">unsigned</span> <span class="kt">char</span>    <span class="n">buffer</span><span class="p">[</span><span class="n">sizeof_x_buffer</span><span class="p">];</span>
    <span class="n">z_stream</span>         <span class="n">strm</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">m_zlib</span><span class="p">;</span>

  <span class="c1">// returns number of bytes written</span>
  <span class="kt">size_t</span> <span class="nf">WriteDeflate</span><span class="p">(</span>
        <span class="kt">size_t</span><span class="p">,</span>         <span class="c1">// sizeof uncompressed input data</span>
        <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>  <span class="c1">// uncompressed input data</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReadInflate</span><span class="p">(</span>
        <span class="kt">size_t</span><span class="p">,</span>  <span class="c1">// sizeof uncompressed input data</span>
        <span class="kt">void</span><span class="o">*</span> <span class="c1">// buffer to hold uncompressed data</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">CompressionInit</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">CompressionEnd</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// endian-ness of the cpu reading this file.</span>
  <span class="c1">// 3dm files are alwasy saved with little endian byte order.</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">endian</span> <span class="n">m_endian</span><span class="p">;</span>

  <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span> <span class="n">m_mode</span><span class="p">;</span>

  <span class="c1">// 3dm write options</span>
  <span class="kt">bool</span> <span class="n">m_bSaveUserData</span><span class="p">;</span> <span class="c1">// true to save user data (increases file size)</span>
  <span class="kt">bool</span> <span class="n">m_bSavePreviewImage</span><span class="p">;</span>    <span class="c1">// true to save 200x200 preview bitmap (increases file size)</span>
  <span class="kt">bool</span> <span class="n">m_bEmbedTextureBitmaps</span><span class="p">;</span> <span class="c1">// true to embed texture, bump, trace, and wallpaper bitmaps (increases file size)</span>
  <span class="kt">bool</span> <span class="n">m_bSaveRenderMeshes</span><span class="p">;</span>    <span class="c1">// true to save meshes used to render B-rep objects (increases file size)</span>
  <span class="kt">bool</span> <span class="n">m_bSaveAnalysisMeshes</span><span class="p">;</span>  <span class="c1">// true to save meshes used in surface analysis (increases file size)</span>

  <span class="c1">// ids of plug-ins that support saving older (V3) versions</span>
  <span class="c1">// of user data.  This information is filled in from the</span>
  <span class="c1">// list of plug-ins passed in whenteh settings are saved.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span> <span class="n">ON_UUID</span> <span class="o">&gt;</span> <span class="n">m_V3_plugin_id_list</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">ON__3dmV1LayerIndex</span><span class="o">*</span> <span class="n">m_V1_layer_list</span><span class="p">;</span>

  <span class="c1">// prohibit default construction, copy construction, and operator=</span>
  <span class="n">ON_BinaryArchive</span><span class="p">();</span>
  <span class="n">ON_BinaryArchive</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>
  <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_3dmGoo</span>
<span class="p">{</span>
  <span class="c1">// used to store goo</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_3dmGoo</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_3dmGoo</span><span class="p">();</span>
  <span class="n">ON_3dmGoo</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dmGoo</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span><span class="n">ON_TextLog</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_typecode</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">m_goo</span><span class="p">;</span>
  <span class="n">ON_3dmGoo</span><span class="o">*</span> <span class="n">m_next_goo</span><span class="p">;</span>
  <span class="n">ON_3dmGoo</span><span class="o">*</span> <span class="n">m_prev_goo</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BinaryFile</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_BinaryArchive</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_BinaryFile</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create an ON_BinaryArchive that reads/writes from an ordinary file.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mode - [in]</span>
<span class="cm">    fp - [in]</span>
<span class="cm">      If a file is being read, fp is the pointer returned</span>
<span class="cm">      from ON_FileStream::Open(...,&quot;rb&quot;).</span>
<span class="cm">      If a file is being written, fp is the pointer returned</span>
<span class="cm">      from ON_FileStream::Open(...,&quot;wb&quot;).</span>
<span class="cm">  */</span>
  <span class="n">ON_BinaryFile</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span><span class="p">,</span> <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="p">);</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">ON_BinaryFile</span><span class="p">();</span>

  <span class="c1">// ON_BinaryArchive overrides</span>
  <span class="kt">size_t</span> <span class="nf">CurrentPosition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">SeekFromCurrentPosition</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SeekFromStart</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">AtEnd</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// fseek from end (since the file has an end)</span>
  <span class="kt">bool</span> <span class="nf">SeekFromEnd</span><span class="p">(</span> <span class="kt">int</span> <span class="p">);</span>

  <span class="c1">//////////</span>
  <span class="c1">// To use custom memory buffering instead of relying</span>
  <span class="c1">// on fread()/fwrite()&#39;s build in buffering, call</span>
  <span class="c1">// EnableMemoryBuffer() with the buffer size immediately</span>
  <span class="c1">// after constructing the ON_BinaryFile.  There appear</span>
  <span class="c1">// to be enough bugs in existing Windows NT/2000 NETWORK</span>
  <span class="c1">// I/O that using this hack will speed up I/O by factors</span>
  <span class="c1">// of 10 to 100.</span>
  <span class="kt">void</span> <span class="nf">EnableMemoryBuffer</span><span class="p">(</span>
         <span class="kt">int</span><span class="o">=</span><span class="mi">16384</span> <span class="c1">// capacity of memory buffer</span>
         <span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="kt">size_t</span> <span class="n">Read</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">size_t</span> <span class="nf">Write</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Flush</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Implementation</span>
  <span class="kt">FILE</span><span class="o">*</span> <span class="n">m_fp</span><span class="p">;</span>

  <span class="c1">// if m_memory_buffer_capacity is zero, then Write() uses</span>
  <span class="c1">// fwrite() directly.  If m_memory_buffer_capacity is</span>
  <span class="c1">// greater than zero, then Write() buffers its results</span>
  <span class="c1">// into m_memory_buffer.  This is provided to work around</span>
  <span class="c1">// bugs in some networks that result in extremely slow</span>
  <span class="c1">// performance when seeking is used.</span>
  <span class="kt">size_t</span> <span class="n">m_memory_buffer_capacity</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_memory_buffer_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_memory_buffer_ptr</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">m_memory_buffer</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// prohibit default construction, copy construction, and operator=</span>
  <span class="n">ON_BinaryFile</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// no implementation</span>
  <span class="n">ON_BinaryFile</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BinaryFile</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>
  <span class="n">ON_BinaryFile</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BinaryFile</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_BinaryArchiveBuffer</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_BinaryArchive</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create an ON_BinaryArchive that reads/writes from an ON_Buffer.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mode - [in]</span>
<span class="cm">    buffer - [in]</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If a non-null buffer is specifed, then do not call SetBuffer()</span>
<span class="cm">  */</span>
  <span class="n">ON_BinaryArchiveBuffer</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span><span class="p">,</span> <span class="n">ON_Buffer</span><span class="o">*</span> <span class="n">buffer</span> <span class="p">);</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">ON_BinaryArchiveBuffer</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If the ON_BinaryArchiveBuffer class is created with the constructor</span>
<span class="cm">    that has a single &quot;mode&quot; parameter, then use SetBuffer()</span>
<span class="cm">    to specify the buffer to read/write from before using</span>
<span class="cm">    the ON_BinaryArchiveBuffer.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    buffer - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the buffer is set.  Once the buffer is set it</span>
<span class="cm">    cannot be changed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetBuffer</span><span class="p">(</span> <span class="n">ON_Buffer</span><span class="o">*</span> <span class="n">buffer</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Buffer being read/written.</span>
<span class="cm">  */</span>
  <span class="n">ON_Buffer</span><span class="o">*</span> <span class="nf">Buffer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_BinaryArchive overrides</span>
  <span class="kt">size_t</span> <span class="nf">CurrentPosition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">SeekFromCurrentPosition</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SeekFromStart</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">AtEnd</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">SeekFromEnd</span><span class="p">(</span> <span class="n">ON__INT64</span> <span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="kt">size_t</span> <span class="n">Read</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">size_t</span> <span class="nf">Write</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Flush</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Buffer being read/written.</span>
  <span class="n">ON_Buffer</span><span class="o">*</span> <span class="n">m_buffer</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// prohibit use - you should specify a buffer.</span>
  <span class="n">ON_BinaryArchiveBuffer</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">archive_mode</span> <span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
  <span class="c1">// prohibit default construction, copy construction, and operator=</span>
  <span class="n">ON_BinaryArchiveBuffer</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// no implementation</span>
  <span class="n">ON_BinaryArchiveBuffer</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BinaryArchiveBuffer</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>
  <span class="n">ON_BinaryArchiveBuffer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BinaryArchiveBuffer</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// no implementation</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_Read3dmBufferArchive</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_BinaryArchive</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Construct an ON_BinaryArchive for reading information from a memory buffer.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sizeof_buffer - [in] size of buffer in bytes (&gt;0)</span>
<span class="cm">    buffer - [in] memory buffer containing binary archive</span>
<span class="cm">    bCopyBuffer - [in]</span>
<span class="cm">      true - copy the input buffer.</span>
<span class="cm">          Useful when the buffer may be destroyed while this class is still in use.</span>
<span class="cm">      false - Do not copy the input buffer.</span>
<span class="cm">          In this case you are responsible for making certain the input buffer</span>
<span class="cm">          is valid while this class is in use.</span>
<span class="cm">    archive_3dm_version  - [in] (1,2,3,4 or 5)</span>
<span class="cm">    archive_opennurbs_version - [in] YYYYMMDDn</span>
<span class="cm">  */</span>
  <span class="n">ON_Read3dmBufferArchive</span><span class="p">(</span>
    <span class="kt">size_t</span> <span class="n">sizeof_buffer</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bCopyBuffer</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">archive_3dm_version</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">archive_opennurbs_version</span>
    <span class="p">);</span>

  <span class="o">~</span><span class="n">ON_Read3dmBufferArchive</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">     value of m_sizeof_buffer</span>
<span class="cm">  */</span>
  <span class="kt">size_t</span> <span class="nf">SizeOfBuffer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">     value of m_buffer</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">Buffer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// ON_BinaryArchive overrides</span>
  <span class="kt">size_t</span> <span class="nf">CurrentPosition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">SeekFromCurrentPosition</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SeekFromStart</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">AtEnd</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="c1">// ON_BinaryArchive overrides</span>
  <span class="kt">size_t</span> <span class="n">Read</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// return actual number of bytes read (like fread())</span>
  <span class="kt">size_t</span> <span class="nf">Write</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Flush</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_p</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">m_buffer</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_sizeof_buffer</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_buffer_position</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved1</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved2</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved3</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved4</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// prohibit use - no implementation</span>
  <span class="n">ON_Read3dmBufferArchive</span><span class="p">();</span>
  <span class="n">ON_Read3dmBufferArchive</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Read3dmBufferArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_Read3dmBufferArchive</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Read3dmBufferArchive</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_Write3dmBufferArchive</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_BinaryArchive</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Construct an ON_BinaryArchive for writing information to a memory buffer.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    initial_sizeof_buffer - [in]</span>
<span class="cm">      initial size of buffer in bytes (&gt;=0)</span>
<span class="cm">      If you are unable to estimate the size you will need, pass in zero.</span>
<span class="cm">    max_sizeof_buffer - [in]</span>
<span class="cm">      maximum size of buffer in bytes (&gt;=0)</span>
<span class="cm">      If max_sizeof_buffer &gt; 0 and the amount of information saved</span>
<span class="cm">      requires a buffer larger than this size, then writing fails.</span>
<span class="cm">      If max_sizeof_buffer &lt;= 0, then no buffer size limits are enforced.</span>
<span class="cm">    archive_3dm_version  - [in] (0, ,2,3,4 or 50)</span>
<span class="cm">      Pass 0 or ON_BinaryArchive::CurrentArchiveVersion() to write the</span>
<span class="cm">      version of opennurbs archives used by lastest version of Rhino.</span>
<span class="cm">    archive_opennurbs_version - [in] YYYYMMDDn</span>
<span class="cm">  */</span>
  <span class="n">ON_Write3dmBufferArchive</span><span class="p">(</span>
    <span class="kt">size_t</span> <span class="n">initial_sizeof_buffer</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">max_sizeof_buffer</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">archive_3dm_version</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">archive_opennurbs_version</span>
    <span class="p">);</span>

  <span class="o">~</span><span class="n">ON_Write3dmBufferArchive</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">     Size of the archive in bytes.</span>
<span class="cm">  */</span>
  <span class="kt">size_t</span> <span class="nf">SizeOfArchive</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">     value of m_sizeof_buffer</span>
<span class="cm">  */</span>
  <span class="kt">size_t</span> <span class="nf">SizeOfBuffer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">     value of m_buffer.</span>
<span class="cm">     SizeOfArchive() reports the number of bytes</span>
<span class="cm">     written to this buffer.</span>
<span class="cm">     SizeOfBuffer() reports the number of bytes</span>
<span class="cm">     allocated in this buffer.</span>

<span class="cm">  */</span>
  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">Buffer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The pointer to the buffer and sets all</span>
<span class="cm">    members on this archive back to zero.</span>
<span class="cm">    The caller is responsible for calling onfree() on</span>
<span class="cm">    the pointer when finished with the buffer.</span>
<span class="cm">  */</span>
  <span class="kt">void</span><span class="o">*</span> <span class="nf">HarvestBuffer</span><span class="p">();</span>

  <span class="c1">// ON_BinaryArchive overrides</span>
  <span class="kt">size_t</span> <span class="nf">CurrentPosition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">SeekFromCurrentPosition</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SeekFromStart</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">AtEnd</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="c1">// ON_BinaryArchive overrides</span>
  <span class="kt">size_t</span> <span class="n">Read</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span>
  <span class="kt">size_t</span> <span class="nf">Write</span><span class="p">(</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// return actual number of bytes written (like fwrite())</span>
  <span class="kt">bool</span> <span class="nf">Flush</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">AllocBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_p</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">m_buffer</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_sizeof_buffer</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">m_max_sizeof_buffer</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_sizeof_archive</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_buffer_position</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved1</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved2</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved3</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_reserved4</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// prohibit use - no implementation</span>
  <span class="n">ON_Write3dmBufferArchive</span><span class="p">();</span>
  <span class="n">ON_Write3dmBufferArchive</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Write3dmBufferArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_Write3dmBufferArchive</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Write3dmBufferArchive</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Create a simple archive that contains a single geometric object.</span>
<span class="cm">Parameters:</span>
<span class="cm">  archive - [in] destination archive.</span>
<span class="cm">  version - [in] (0, 2, 3, 4, or 50) format version.archive version number.</span>
<span class="cm">      Version 2 format can be read by Rhino 2 and Rhino 3.  Version</span>
<span class="cm">      3 format can be read by Rhino 3.</span>
<span class="cm">      Pass 0 or ON_BinaryArchive::CurrentArchiveVersion() to write</span>
<span class="cm">      the latest version of archives supported by Rhino.</span>
<span class="cm">  object - [in] object to be saved in the archive&#39;s object table.</span>
<span class="cm">      This is typically some type of ON_Curve, ON_Surface, ON_Mesh,</span>
<span class="cm">      or ON_Brep.</span>
<span class="cm">Returns:</span>
<span class="cm">  @untitled table</span>
<span class="cm">  true     archive successfully written.</span>
<span class="cm">  false    archive not successfully written.</span>
<span class="cm">Example:</span>

<span class="cm">          const char* filename = &quot;myfile.3dm&quot;;</span>
<span class="cm">          FILE* fp = ON::OpenFile( filename, &quot;wb&quot; );</span>
<span class="cm">          ON_BinaryFile file( fp, ON::write3dm );</span>
<span class="cm">          ON_BOOL32 ok = ON_WriteArchive( archive, geometry );</span>
<span class="cm">          ON::CloseFile( fp );</span>

<span class="cm">Remarks:</span>
<span class="cm">  The object table in the archive will contain a single</span>
<span class="cm">  object.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_WriteOneObjectArchive</span><span class="p">(</span>
          <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">archive</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="n">object</span>
          <span class="p">);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_array.h.html" class="btn btn-neutral float-right" title="File opennurbs_array.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_archive.h.html" class="btn btn-neutral float-left" title="File opennurbs_archive.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>