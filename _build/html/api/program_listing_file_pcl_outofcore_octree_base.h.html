

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File octree_base.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File octree_base.hpp" href="file_pcl_octree_impl_octree_base.hpp.html" />
    <link rel="prev" title="File octree_base.h" href="file_pcl_outofcore_octree_base.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_outofcore_octree_base.h.html">File octree_base.h</a> &raquo;</li>
        
      <li>Program Listing for File octree_base.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_outofcore_octree_base.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-octree-base-h">
<span id="program-listing-file-pcl-outofcore-octree-base-h"></span><h1>Program Listing for File octree_base.h<a class="headerlink" href="#program-listing-for-file-octree-base-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_outofcore_octree_base.h.html#file-pcl-outofcore-octree-base-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\outofcore\octree_base.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Software License Agreement (BSD License)</span>
<span class="cm"> *</span>
<span class="cm"> *  Point Cloud Library (PCL) - www.pointclouds.org</span>
<span class="cm"> *  Copyright (c) 2010-2012, Willow Garage, Inc.</span>
<span class="cm"> *  Copyright (c) 2012, Urban Robotics, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above</span>
<span class="cm"> *     copyright notice, this list of conditions and the following</span>
<span class="cm"> *     disclaimer in the documentation and/or other materials provided</span>
<span class="cm"> *     with the distribution.</span>
<span class="cm"> *   * Neither the name of Willow Garage, Inc. nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="cm"> *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span>
<span class="cm"> *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="cm"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="cm"> *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<span class="cm"> *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> *  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *  $Id$</span>
<span class="cm"> */</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/boost.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/common/io.h&gt;</span><span class="cp"></span>

<span class="c1">//outofcore classes</span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/octree_base_node.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/octree_disk_container.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/octree_ram_container.h&gt;</span><span class="cp"></span>

<span class="c1">//outofcore iterators</span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/outofcore_iterator_base.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/outofcore_breadth_first_iterator.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/outofcore_depth_first_iterator.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/impl/outofcore_breadth_first_iterator.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/impl/outofcore_depth_first_iterator.hpp&gt;</span><span class="cp"></span>

<span class="c1">//outofcore metadata</span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/metadata.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/outofcore/outofcore_base_data.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/filter.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/random_sample.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/PCLPointCloud2.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;shared_mutex&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">pcl</span>
<span class="p">{</span>
  <span class="k">namespace</span> <span class="n">outofcore</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">OutofcoreParams</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">node_index_basename_</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">node_container_basename_</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">node_index_extension_</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">node_container_extension_</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">sample_percent</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="cm">/** \class OutofcoreOctreeBase</span>
<span class="cm">     *  \brief This code defines the octree used for point storage at Urban Robotics.</span>
<span class="cm">     *</span>
<span class="cm">     *  \note Code was adapted from the Urban Robotics out of core octree implementation.</span>
<span class="cm">     *  Contact Jacob Schloss &lt;jacob.schloss@urbanrobotics.net&gt; with any questions.</span>
<span class="cm">     *  http://www.urbanrobotics.net/. This code was integrated for the Urban Robotics</span>
<span class="cm">     *  Code Sprint (URCS) by Stephen Fox (foxstephend@gmail.com). Additional development notes can be found at</span>
<span class="cm">     *  http://www.pointclouds.org/blog/urcs/.</span>
<span class="cm">     *</span>
<span class="cm">     *  The primary purpose of this class is an interface to the</span>
<span class="cm">     *  recursive traversal (recursion handled by \ref pcl::outofcore::OutofcoreOctreeBaseNode) of the</span>
<span class="cm">     *  in-memory/top-level octree structure. The metadata in each node</span>
<span class="cm">     *  can be loaded entirely into main memory, from which the tree can be traversed</span>
<span class="cm">     *  recursively in this state. This class provides an the interface</span>
<span class="cm">     *  for:</span>
<span class="cm">     *               -# Point/Region insertion methods</span>
<span class="cm">     *               -# Frustrum/box/region queries</span>
<span class="cm">     *               -# Parameterization of resolution, container type, etc...</span>
<span class="cm">     *</span>
<span class="cm">     *  For lower-level node access, there is a Depth-First iterator</span>
<span class="cm">     *  for traversing the trees with direct access to the nodes. This</span>
<span class="cm">     *  can be used for implementing other algorithms, and other</span>
<span class="cm">     *  iterators can be written in a similar fashion.</span>
<span class="cm">     *</span>
<span class="cm">     *  The format of the octree is stored on disk in a hierarchical</span>
<span class="cm">     *  octree structure, where .oct_idx are the JSON-based node</span>
<span class="cm">     *  metadata files managed by \ref pcl::outofcore::OutofcoreOctreeNodeMetadata,</span>
<span class="cm">     *  and .octree is the JSON-based octree metadata file managed by</span>
<span class="cm">     *  \ref pcl::outofcore::OutofcoreOctreeBaseMetadata. Children of each node live</span>
<span class="cm">     *  in up to eight subdirectories named from 0 to 7, where a</span>
<span class="cm">     *  metadata and optionally a pcd file will exist. The PCD files</span>
<span class="cm">     *  are stored in compressed binary PCD format, containing all of</span>
<span class="cm">     *  the fields existing in the PCLPointCloud2 objects originally</span>
<span class="cm">     *  inserted into the out of core object.</span>
<span class="cm">     *</span>
<span class="cm">     *  A brief outline of the out of core octree can be seen</span>
<span class="cm">     *  below. The files in [brackets] exist only when the LOD are</span>
<span class="cm">     *  built.</span>
<span class="cm">     *</span>
<span class="cm">     *  At this point in time, there is not support for multiple trees</span>
<span class="cm">     *  existing in a single directory hierarchy.</span>
<span class="cm">     *</span>
<span class="cm">     *  \verbatim</span>
<span class="cm">     tree_name/</span>
<span class="cm">          tree_name.oct_idx</span>
<span class="cm">          tree_name.octree</span>
<span class="cm">          [tree_name-uuid.pcd]</span>
<span class="cm">          0/</span>
<span class="cm">               tree_name.oct_idx</span>
<span class="cm">               [tree_name-uuid.pcd]</span>
<span class="cm">               0/</span>
<span class="cm">                  ...</span>
<span class="cm">               1/</span>
<span class="cm">                   ...</span>
<span class="cm">                     ...</span>
<span class="cm">                         0/</span>
<span class="cm">                             tree_name.oct_idx</span>
<span class="cm">                             tree_name.pcd</span>
<span class="cm">          1/</span>
<span class="cm">          ...</span>
<span class="cm">          7/</span>
<span class="cm">     \endverbatim</span>
<span class="cm">     *</span>
<span class="cm">     *  \ingroup outofcore</span>
<span class="cm">     *  \author Jacob Schloss (jacob.schloss@urbanrobotics.net)</span>
<span class="cm">     *  \author Stephen Fox, Urban Robotics Code Sprint (foxstephend@gmail.com)</span>
<span class="cm">     *</span>
<span class="cm">     */</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ContainerT</span> <span class="o">=</span> <span class="n">OutofcoreOctreeDiskContainer</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PointT</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">OutofcoreOctreeBase</span>
    <span class="p">{</span>
      <span class="k">friend</span> <span class="k">class</span> <span class="nc">OutofcoreOctreeBaseNode</span><span class="o">&lt;</span><span class="n">ContainerT</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="k">friend</span> <span class="k">class</span> <span class="nc">pcl</span><span class="o">::</span><span class="n">outofcore</span><span class="o">::</span><span class="n">OutofcoreIteratorBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">ContainerT</span><span class="o">&gt;</span><span class="p">;</span>

      <span class="k">public</span><span class="o">:</span>

        <span class="c1">// public typedefs</span>
        <span class="k">typedef</span> <span class="n">OutofcoreOctreeBase</span><span class="o">&lt;</span><span class="n">OutofcoreOctreeDiskContainer</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">PointT</span> <span class="o">&gt;</span> <span class="n">octree_disk</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">OutofcoreOctreeBaseNode</span><span class="o">&lt;</span><span class="n">OutofcoreOctreeDiskContainer</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">PointT</span> <span class="o">&gt;</span> <span class="n">octree_disk_node</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">OutofcoreOctreeBase</span><span class="o">&lt;</span><span class="n">OutofcoreOctreeRamContainer</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span> <span class="n">octree_ram</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">OutofcoreOctreeBaseNode</span><span class="o">&lt;</span><span class="n">OutofcoreOctreeRamContainer</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span> <span class="n">octree_ram_node</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">OutofcoreOctreeBaseNode</span><span class="o">&lt;</span><span class="n">ContainerT</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span> <span class="n">OutofcoreNodeType</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">OutofcoreOctreeBaseNode</span><span class="o">&lt;</span><span class="n">ContainerT</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span> <span class="n">BranchNode</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">OutofcoreOctreeBaseNode</span><span class="o">&lt;</span><span class="n">ContainerT</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span> <span class="n">LeafNode</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">OutofcoreDepthFirstIterator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">ContainerT</span><span class="o">&gt;</span> <span class="n">Iterator</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="k">const</span> <span class="n">OutofcoreDepthFirstIterator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">ContainerT</span><span class="o">&gt;</span> <span class="n">ConstIterator</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">OutofcoreBreadthFirstIterator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">ContainerT</span><span class="o">&gt;</span> <span class="n">BreadthFirstIterator</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="k">const</span> <span class="n">OutofcoreBreadthFirstIterator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">ContainerT</span><span class="o">&gt;</span> <span class="n">BreadthFirstConstIterator</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">OutofcoreDepthFirstIterator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">ContainerT</span><span class="o">&gt;</span> <span class="n">DepthFirstIterator</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="k">const</span> <span class="n">OutofcoreDepthFirstIterator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">ContainerT</span><span class="o">&gt;</span> <span class="n">DepthFirstConstIterator</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">OutofcoreOctreeBase</span><span class="o">&lt;</span><span class="n">ContainerT</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">OutofcoreOctreeBase</span><span class="o">&lt;</span><span class="n">ContainerT</span><span class="p">,</span> <span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="n">PointCloud</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">IndicesPtr</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">IndicesConstPtr</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PointCloud</span><span class="o">&gt;</span> <span class="n">PointCloudPtr</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">PointCloud</span><span class="o">&gt;</span> <span class="n">PointCloudConstPtr</span><span class="p">;</span>

        <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">AlignedPointTVector</span><span class="p">;</span>

        <span class="c1">// Constructors</span>
        <span class="c1">// -----------------------------------------------------------------------</span>

        <span class="cm">/** \brief Load an existing tree</span>
<span class="cm">         *</span>
<span class="cm">         * If load_all is set, the BB and point count for every node is loaded,</span>
<span class="cm">         * otherwise only the root node is actually created, and the rest will be</span>
<span class="cm">         * generated on insertion or query.</span>
<span class="cm">         *</span>
<span class="cm">         * \param root_node_name Path to the top-level tree/tree.oct_idx metadata file</span>
<span class="cm">         * \param load_all Load entire tree metadata (does not load any points from disk)</span>
<span class="cm">         * \throws PCLException for bad extension (root node metadata must be .oct_idx extension)</span>
<span class="cm">         */</span>
        <span class="n">OutofcoreOctreeBase</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="o">&amp;</span><span class="n">root_node_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">load_all</span><span class="p">);</span>

        <span class="cm">/** \brief Create a new tree</span>
<span class="cm">         *</span>
<span class="cm">         * Create a new tree rootname with specified bounding box; will remove and overwrite existing tree with the same name</span>
<span class="cm">         *</span>
<span class="cm">         * Computes the depth of the tree based on desired leaf , then calls the other constructor.</span>
<span class="cm">         *</span>
<span class="cm">         * \param min Bounding box min</span>
<span class="cm">         * \param max Bounding box max</span>
<span class="cm">         * \param resolution_arg Node dimension in meters (assuming your point data is in meters)</span>
<span class="cm">         * \param root_node_name must end in &quot;.oct_idx&quot;</span>
<span class="cm">         * \param coord_sys Coordinate system which is stored in the JSON metadata</span>
<span class="cm">         * \throws PCLException if root file extension does not match \ref pcl::outofcore::OutofcoreOctreeBaseNode::node_index_extension</span>
<span class="cm">         */</span>
        <span class="n">OutofcoreOctreeBase</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">resolution_arg</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="o">&amp;</span><span class="n">root_node_name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">coord_sys</span><span class="p">);</span>

        <span class="cm">/** \brief Create a new tree; will not overwrite existing tree of same name</span>
<span class="cm">         *</span>
<span class="cm">         * Create a new tree rootname with specified bounding box; will not overwrite an existing tree</span>
<span class="cm">         *</span>
<span class="cm">         * \param max_depth Specifies a fixed number of LODs to generate, which is the depth of the tree</span>
<span class="cm">         * \param min Bounding box min</span>
<span class="cm">         * \param max Bounding box max</span>
<span class="cm">         * \note Bounding box of the tree must be set before inserting any points. The tree \b cannot be resized at this time.</span>
<span class="cm">         * \param root_node_name must end in &quot;.oct_idx&quot;</span>
<span class="cm">         * \param coord_sys Coordinate system which is stored in the JSON metadata</span>
<span class="cm">         * \throws PCLException if the parent directory has existing children (detects an existing tree)</span>
<span class="cm">         * \throws PCLException if file extension is not &quot;.oct_idx&quot;</span>
<span class="cm">         */</span>
        <span class="n">OutofcoreOctreeBase</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">max_depth</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="o">&amp;</span><span class="n">root_node_name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">coord_sys</span><span class="p">);</span>

        <span class="k">virtual</span>
        <span class="o">~</span><span class="n">OutofcoreOctreeBase</span> <span class="p">();</span>

        <span class="c1">// Point/Region INSERTION methods</span>
        <span class="c1">// --------------------------------------------------------------------------------</span>
        <span class="cm">/** \brief Recursively add points to the tree</span>
<span class="cm">         *  \note shared read_write_mutex lock occurs</span>
<span class="cm">         */</span>
        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">addDataToLeaf</span> <span class="p">(</span><span class="k">const</span> <span class="n">AlignedPointTVector</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

        <span class="cm">/** \brief Copies the points from the point_cloud falling within the bounding box of the octree to the</span>
<span class="cm">         *   out-of-core octree; this is an interface to addDataToLeaf and can be used multiple times.</span>
<span class="cm">         *  \param point_cloud Pointer to the point cloud data to copy to the outofcore octree; Assumes templated</span>
<span class="cm">         *   PointT matches for each.</span>
<span class="cm">         *  \return Number of points successfully copied from the point cloud to the octree.</span>
<span class="cm">         */</span>
        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">addPointCloud</span> <span class="p">(</span><span class="n">PointCloudConstPtr</span> <span class="n">point_cloud</span><span class="p">);</span>

        <span class="cm">/** \brief Recursively copies points from input_cloud into the leaf nodes of the out-of-core octree, and stores them to disk.</span>
<span class="cm">         *</span>
<span class="cm">         * \param[in] input_cloud The cloud of points to be inserted into the out-of-core octree. Note if multiple PCLPointCloud2 objects are added to the tree, this assumes that they all have exactly the same fields.</span>
<span class="cm">         * \param[in] skip_bb_check (default=false) whether to skip the bounding box check on insertion. Note the bounding box check is never skipped in the current implementation.</span>
<span class="cm">         * \return Number of poitns successfully copied from the point cloud to the octree</span>
<span class="cm">         */</span>
        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">addPointCloud</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">::</span><span class="n">Ptr</span> <span class="o">&amp;</span><span class="n">input_cloud</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">skip_bb_check</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>

        <span class="cm">/** \brief Recursively add points to the tree.</span>
<span class="cm">         *</span>
<span class="cm">         * Recursively add points to the tree. 1/8 of the remaining</span>
<span class="cm">         * points at each LOD are stored at each internal node of the</span>
<span class="cm">         * octree until either (a) runs out of points, in which case</span>
<span class="cm">         * the leaf is not at the maximum depth of the tree, or (b)</span>
<span class="cm">         * a larger set of points falls in the leaf at the maximum depth.</span>
<span class="cm">         * Note unlike the old implementation, multiple</span>
<span class="cm">         * copies of the same point will \b not be added at multiple</span>
<span class="cm">         * LODs as it walks the tree. Once the point is added to the</span>
<span class="cm">         * octree, it is no longer propagated further down the tree.</span>
<span class="cm">         *</span>
<span class="cm">         *\param[in] input_cloud The input cloud of points which will</span>
<span class="cm">         * be copied into the sorted nodes of the out-of-core octree</span>
<span class="cm">         * \return The total number of points added to the out-of-core</span>
<span class="cm">         * octree.</span>
<span class="cm">         */</span>
        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">addPointCloud_and_genLOD</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">::</span><span class="n">Ptr</span> <span class="o">&amp;</span><span class="n">input_cloud</span><span class="p">);</span>

        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">addPointCloud</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">::</span><span class="n">Ptr</span> <span class="o">&amp;</span><span class="n">input_cloud</span><span class="p">);</span>

        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">addPointCloud_and_genLOD</span> <span class="p">(</span><span class="n">PointCloudConstPtr</span> <span class="n">point_cloud</span><span class="p">);</span>

        <span class="cm">/** \brief Recursively add points to the tree subsampling LODs on the way.</span>
<span class="cm">         *</span>
<span class="cm">         * shared read_write_mutex lock occurs</span>
<span class="cm">         */</span>
        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">addDataToLeaf_and_genLOD</span> <span class="p">(</span><span class="n">AlignedPointTVector</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

        <span class="c1">// Frustrum/Box/Region REQUESTS/QUERIES: DB Accessors</span>
        <span class="c1">// -----------------------------------------------------------------------</span>
        <span class="kt">void</span>
        <span class="nf">queryFrustum</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">planes</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">file_names</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">void</span>
        <span class="nf">queryFrustum</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">planes</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">file_names</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">query_depth</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">void</span>
        <span class="nf">queryFrustum</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">planes</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">eye</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4d</span> <span class="o">&amp;</span><span class="n">view_projection_matrix</span><span class="p">,</span>
                      <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">file_names</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">query_depth</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="c1">//--------------------------------------------------------------------------------</span>
        <span class="c1">//templated PointT methods</span>
        <span class="c1">//--------------------------------------------------------------------------------</span>

        <span class="cm">/** \brief Get a list of file paths at query_depth that intersect with your bounding box specified by \c min and \c max.</span>
<span class="cm">         *  When querying with this method, you may be stuck with extra data (some outside of your query bounds) that reside in the files.</span>
<span class="cm">         *</span>
<span class="cm">         * \param[in] min The minimum corner of the bounding box</span>
<span class="cm">         * \param[in] max The maximum corner of the bounding box</span>
<span class="cm">         * \param[in] query_depth 0 is root, (this-&gt;depth) is full</span>
<span class="cm">         * \param[out] bin_name List of paths to point data files (PCD currently) which satisfy the query</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">queryBBIntersects</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">query_depth</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">bin_name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Get Points in BB, only points inside BB. The query</span>
<span class="cm">         * processes the data at each node, filtering points that fall</span>
<span class="cm">         * out of the query bounds, and returns a single, concatenated</span>
<span class="cm">         * point cloud.</span>
<span class="cm">         *</span>
<span class="cm">         * \param[in] min The minimum corner of the bounding box for querying</span>
<span class="cm">         * \param[in] max The maximum corner of the bounding box for querying</span>
<span class="cm">         * \param[in] query_depth The depth from which point data will be taken</span>
<span class="cm">         *   \note If the LODs of the tree have not been built, you must specify the maximum depth in order to retrieve any data</span>
<span class="cm">         * \param[out] dst The destination vector of points</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">queryBBIncludes</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">query_depth</span><span class="p">,</span> <span class="n">AlignedPointTVector</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Query all points falling within the input bounding box at \c query_depth and return a PCLPointCloud2 object in \c dst_blob.</span>
<span class="cm">         *</span>
<span class="cm">         * \param[in] min The minimum corner of the input bounding box.</span>
<span class="cm">         * \param[in] max The maximum corner of the input bounding box.</span>
<span class="cm">         * \param[in] query_depth The query depth at which to search for points; only points at this depth are returned</span>
<span class="cm">         * \param[out] dst_blob Storage location for the points satisfying the query.</span>
<span class="cm">         **/</span>
        <span class="kt">void</span>
        <span class="nf">queryBBIncludes</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">query_depth</span><span class="p">,</span> <span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">::</span><span class="n">Ptr</span> <span class="o">&amp;</span><span class="n">dst_blob</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Returns a random subsample of points within the given bounding box at \c query_depth.</span>
<span class="cm">         *</span>
<span class="cm">         * \param[in] min The minimum corner of the boudning box to query.</span>
<span class="cm">         * \param[out] max The maximum corner of the bounding box to query.</span>
<span class="cm">         * \param[in] query_depth The depth in the tree at which to look for the points. Only returns points within the given bounding box at the specified \c query_depth.</span>
<span class="cm">         * \param percent</span>
<span class="cm">         * \param[out] dst The destination in which to return the points.</span>
<span class="cm">         *</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">queryBBIncludes_subsample</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">query_depth</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">percent</span><span class="p">,</span> <span class="n">AlignedPointTVector</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="c1">//--------------------------------------------------------------------------------</span>
        <span class="c1">//PCLPointCloud2 methods</span>
        <span class="c1">//--------------------------------------------------------------------------------</span>

        <span class="cm">/** \brief Query all points falling within the input bounding box at \c query_depth and return a PCLPointCloud2 object in \c dst_blob.</span>
<span class="cm">         *   If the optional argument for filter is given, points are processed by that filter before returning.</span>
<span class="cm">         *  \param[in] min The minimum corner of the input bounding box.</span>
<span class="cm">         *  \param[in] max The maximum corner of the input bounding box.</span>
<span class="cm">         *  \param[in] query_depth The depth of tree at which to query; only points at this depth are returned</span>
<span class="cm">         *  \param[out] dst_blob The destination in which points within the bounding box are stored.</span>
<span class="cm">         *  \param[in] percent optional sampling percentage which is applied after each time data are read from disk</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span>
        <span class="nf">queryBoundingBox</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">query_depth</span><span class="p">,</span> <span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">::</span><span class="n">Ptr</span> <span class="o">&amp;</span><span class="n">dst_blob</span><span class="p">,</span> <span class="kt">double</span> <span class="n">percent</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">);</span>

        <span class="cm">/** \brief Returns list of pcd files from nodes whose bounding boxes intersect with the input bounding box.</span>
<span class="cm">         * \param[in] min The minimum corner of the input bounding box.</span>
<span class="cm">         * \param[in] max The maximum corner of the input bounding box.</span>
<span class="cm">         * \param query_depth</span>
<span class="cm">         * \param[out] filenames The list of paths to the PCD files which can be loaded and processed.</span>
<span class="cm">         */</span>
        <span class="kr">inline</span> <span class="k">virtual</span> <span class="kt">void</span>
        <span class="nf">queryBoundingBox</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">query_depth</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">filenames</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_timed_mutex</span> <span class="o">&gt;</span> <span class="n">lock</span> <span class="p">(</span><span class="n">read_write_mutex_</span><span class="p">);</span>
          <span class="n">filenames</span><span class="p">.</span><span class="n">clear</span> <span class="p">();</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">root_node_</span><span class="o">-&gt;</span><span class="n">queryBBIntersects</span> <span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">query_depth</span><span class="p">,</span> <span class="n">filenames</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Parameterization: getters and setters</span>
        <span class="c1">// --------------------------------------------------------------------------------</span>

        <span class="cm">/** \brief Get the overall bounding box of the outofcore</span>
<span class="cm">         *  octree; this is the same as the bounding box of the \c root_node_ node</span>
<span class="cm">         *  \param min</span>
<span class="cm">         *  \param max</span>
<span class="cm">         */</span>
        <span class="kt">bool</span>
        <span class="nf">getBoundingBox</span> <span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">max</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Get number of points at specified LOD</span>
<span class="cm">         * \param[in] depth_index the level of detail at which we want the number of points (0 is root, 1, 2,...)</span>
<span class="cm">         * \return number of points in the tree at \b depth</span>
<span class="cm">         */</span>
        <span class="kr">inline</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">getNumPointsAtDepth</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&amp;</span> <span class="n">depth_index</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getLODPoints</span> <span class="p">(</span><span class="n">depth_index</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="cm">/** \brief Queries the number of points in a bounding box</span>
<span class="cm">         *</span>
<span class="cm">         *  \param[in] min The minimum corner of the input bounding box</span>
<span class="cm">         *  \param[out] max The maximum corner of the input bounding box</span>
<span class="cm">         *  \param[in] query_depth The depth of the nodes to restrict the search to (only this depth is searched)</span>
<span class="cm">         *  \param[in] load_from_disk (default true) Whether to load PCD files to count exactly the number of points within the bounding box; setting this to false will return an upper bound by just reading the number of points from the PCD header, even if there may be some points in that node do not fall within the query bounding box.</span>
<span class="cm">         *  \return Number of points in the bounding box at depth \b query_depth</span>
<span class="cm">         **/</span>
        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">queryBoundingBoxNumPoints</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">query_depth</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_from_disk</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>


        <span class="cm">/** \brief Get number of points at each LOD</span>
<span class="cm">         * \return vector of number of points in each LOD indexed by each level of depth, 0 to the depth of the tree.</span>
<span class="cm">         */</span>
        <span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;&amp;</span>
        <span class="n">getNumPointsVector</span> <span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getLODPoints</span> <span class="p">());</span>
        <span class="p">}</span>

        <span class="cm">/** \brief Get number of LODs, which is the height of the tree</span>
<span class="cm">         */</span>
        <span class="kr">inline</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">getDepth</span> <span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getDepth</span> <span class="p">());</span>
        <span class="p">}</span>

        <span class="kr">inline</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">getTreeDepth</span> <span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getDepth</span> <span class="p">());</span>
        <span class="p">}</span>

        <span class="cm">/** \brief Computes the expected voxel dimensions at the leaves</span>
<span class="cm">         */</span>
        <span class="kt">bool</span>
        <span class="n">getBinDimension</span> <span class="p">(</span><span class="kt">double</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief gets the side length of an (assumed) perfect cubic voxel.</span>
<span class="cm">         *  \note If the initial bounding box specified in constructing the octree is not square, then this method does not return a sensible value</span>
<span class="cm">         *  \return the side length of the cubic voxel size at the specified depth</span>
<span class="cm">         */</span>
        <span class="kt">double</span>
        <span class="nf">getVoxelSideLength</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&amp;</span> <span class="n">depth</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Gets the smallest (assumed) cubic voxel side lengths. The smallest voxels are located at the max depth of the tree.</span>
<span class="cm">         * \return The side length of a the cubic voxel located at the leaves</span>
<span class="cm">         */</span>
        <span class="kt">double</span>
        <span class="nf">getVoxelSideLength</span> <span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getVoxelSideLength</span> <span class="p">(</span><span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getDepth</span> <span class="p">()));</span>
        <span class="p">}</span>

        <span class="cm">/** \brief Get coordinate system tag from the JSON metadata file</span>
<span class="cm">         */</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>
        <span class="n">getCoordSystem</span> <span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getCoordinateSystem</span> <span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// Mutators</span>
        <span class="c1">// -----------------------------------------------------------------------</span>

        <span class="cm">/** \brief Generate multi-resolution LODs for the tree, which are a uniform random sampling all child leafs below the node.</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="n">buildLOD</span> <span class="p">();</span>

        <span class="cm">/** \brief Prints size of BBox to stdout</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">printBoundingBox</span> <span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">query_depth</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Prints the coordinates of the bounding box of the node to stdout */</span>
        <span class="kt">void</span>
        <span class="nf">printBoundingBox</span> <span class="p">(</span><span class="n">OutofcoreNodeType</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Prints size of the bounding boxes to stdou</span>
<span class="cm">         */</span>
        <span class="kr">inline</span> <span class="kt">void</span>
        <span class="nf">printBoundingBox</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">printBoundingBox</span> <span class="p">(</span><span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getDepth</span> <span class="p">());</span>
        <span class="p">}</span>

        <span class="cm">/** \brief Returns the voxel centers of all existing voxels at \c query_depth</span>
<span class="cm">            \param[out] voxel_centers Vector of PointXYZ voxel centers for nodes that exist at that depth</span>
<span class="cm">            \param[in] query_depth the depth of the tree at which to retrieve occupied/existing voxels</span>
<span class="cm">        */</span>
        <span class="kt">void</span>
        <span class="nf">getOccupiedVoxelCenters</span><span class="p">(</span><span class="n">AlignedPointTVector</span> <span class="o">&amp;</span><span class="n">voxel_centers</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">query_depth</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Returns the voxel centers of all existing voxels at \c query_depth</span>
<span class="cm">            \param[out] voxel_centers Vector of PointXYZ voxel centers for nodes that exist at that depth</span>
<span class="cm">            \param[in] query_depth the depth of the tree at which to retrieve occupied/existing voxels</span>
<span class="cm">        */</span>
        <span class="kt">void</span>
        <span class="nf">getOccupiedVoxelCenters</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">voxel_centers</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">query_depth</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Gets the voxel centers of all occupied/existing leaves of the tree */</span>
        <span class="kt">void</span>
        <span class="nf">getOccupiedVoxelCenters</span><span class="p">(</span><span class="n">AlignedPointTVector</span> <span class="o">&amp;</span><span class="n">voxel_centers</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="n">getOccupiedVoxelCenters</span><span class="p">(</span><span class="n">voxel_centers</span><span class="p">,</span> <span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getDepth</span> <span class="p">());</span>
        <span class="p">}</span>

        <span class="cm">/** \brief Returns the voxel centers of all occupied/existing leaves of the tree</span>
<span class="cm">         *  \param[out] voxel_centers std::vector of the centers of all occupied leaves of the octree</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">getOccupiedVoxelCenters</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">voxel_centers</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="n">getOccupiedVoxelCenters</span><span class="p">(</span><span class="n">voxel_centers</span><span class="p">,</span> <span class="n">metadata_</span><span class="o">-&gt;</span><span class="n">getDepth</span> <span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// Serializers</span>
        <span class="c1">// -----------------------------------------------------------------------</span>

        <span class="cm">/** \brief Save each .bin file as an XYZ file */</span>
        <span class="kt">void</span>
        <span class="nf">convertToXYZ</span> <span class="p">();</span>

        <span class="cm">/** \brief Write a python script using the vpython module containing all</span>
<span class="cm">         * the bounding boxes */</span>
        <span class="kt">void</span>
        <span class="nf">writeVPythonVisual</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">filename</span><span class="p">);</span>

        <span class="n">OutofcoreNodeType</span><span class="o">*</span>
        <span class="nf">getBranchChildPtr</span> <span class="p">(</span><span class="k">const</span> <span class="n">BranchNode</span><span class="o">&amp;</span> <span class="n">branch_arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">childIdx_arg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">pcl</span><span class="o">::</span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">&gt;::</span><span class="n">Ptr</span>
        <span class="n">getLODFilter</span> <span class="p">();</span>

        <span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">&gt;::</span><span class="n">ConstPtr</span>
        <span class="n">getLODFilter</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="cm">/** \brief Sets the filter to use when building the levels of depth. Recommended filters are pcl::RandomSample&lt;pcl::PCLPointCloud2&gt; or pcl::VoxelGrid */</span>
        <span class="kt">void</span>
        <span class="nf">setLODFilter</span> <span class="p">(</span><span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Filter</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">filter_arg</span><span class="p">);</span>

        <span class="cm">/** \brief Returns the sample_percent_ used when constructing the LOD. */</span>
        <span class="kt">double</span>
        <span class="nf">getSamplePercent</span> <span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">sample_percent_</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** \brief Sets the sampling percent for constructing LODs. Each LOD gets sample_percent^d points.</span>
<span class="cm">         * \param[in] sample_percent_arg Percentage between 0 and 1. */</span>
        <span class="kr">inline</span> <span class="kt">void</span>
        <span class="nf">setSamplePercent</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">sample_percent_arg</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">sample_percent_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span> <span class="p">(</span><span class="n">sample_percent_arg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span> <span class="p">(</span><span class="n">sample_percent_arg</span><span class="p">);</span>
        <span class="p">}</span>

      <span class="k">protected</span><span class="o">:</span>
        <span class="kt">void</span>
        <span class="n">init</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&amp;</span> <span class="n">depth</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">min</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">max</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">root_name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">coord_sys</span><span class="p">);</span>

        <span class="n">OutofcoreOctreeBase</span> <span class="p">(</span><span class="n">OutofcoreOctreeBase</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>

        <span class="n">OutofcoreOctreeBase</span> <span class="p">(</span><span class="k">const</span> <span class="n">OutofcoreOctreeBase</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>

        <span class="n">OutofcoreOctreeBase</span><span class="o">&amp;</span>
        <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">OutofcoreOctreeBase</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>

        <span class="n">OutofcoreOctreeBase</span><span class="o">&amp;</span>
        <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">OutofcoreOctreeBase</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>

        <span class="kr">inline</span> <span class="n">OutofcoreNodeType</span><span class="o">*</span>
        <span class="nf">getRootNode</span> <span class="p">()</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">root_node_</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** \brief flush empty nodes only */</span>
        <span class="kt">void</span>
        <span class="nf">DeAllocEmptyNodeCache</span> <span class="p">(</span><span class="n">OutofcoreNodeType</span><span class="o">*</span> <span class="n">current</span><span class="p">);</span>

        <span class="cm">/** \brief Write octree definition &quot;.octree&quot; (defined by octree_extension_) to disk */</span>
        <span class="kt">void</span>
        <span class="nf">saveToFile</span> <span class="p">();</span>

        <span class="cm">/** \brief recursive portion of lod builder */</span>
        <span class="kt">void</span>
        <span class="nf">buildLODRecursive</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BranchNode</span><span class="o">*&gt;&amp;</span> <span class="n">current_branch</span><span class="p">);</span>

        <span class="cm">/** \brief Increment current depths (LOD for branch nodes) point count; called by addDataAtMaxDepth in OutofcoreOctreeBaseNode</span>
<span class="cm">         */</span>
        <span class="kr">inline</span> <span class="kt">void</span>
        <span class="nf">incrementPointsInLOD</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">depth</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">inc</span><span class="p">);</span>

        <span class="cm">/** \brief Auxiliary function to validate path_name extension is .octree</span>
<span class="cm">         *</span>
<span class="cm">         *  \return 0 if bad; 1 if extension is .oct_idx</span>
<span class="cm">         */</span>
        <span class="kt">bool</span>
        <span class="nf">checkExtension</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">path_name</span><span class="p">);</span>


        <span class="cm">/** \brief DEPRECATED - Flush all nodes&#39; cache</span>
<span class="cm">         *  \deprecated this was moved to the octree_node class</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">flushToDisk</span> <span class="p">();</span>

        <span class="cm">/** \brief DEPRECATED - Flush all non leaf nodes&#39; cache</span>
<span class="cm">         *  \deprecated</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">flushToDiskLazy</span> <span class="p">();</span>

        <span class="cm">/** \brief DEPRECATED - Flush empty nodes only</span>
<span class="cm">         *  \deprecated</span>
<span class="cm">         */</span>
        <span class="kt">void</span>
        <span class="nf">DeAllocEmptyNodeCache</span> <span class="p">();</span>

        <span class="cm">/** \brief Pointer to the root node of the octree data structure */</span>
        <span class="n">OutofcoreNodeType</span><span class="o">*</span> <span class="n">root_node_</span><span class="p">;</span>

        <span class="cm">/** \brief shared mutex for controlling read/write access to disk */</span>
        <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_timed_mutex</span> <span class="n">read_write_mutex_</span><span class="p">;</span>

        <span class="n">OutofcoreOctreeBaseMetadata</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">metadata_</span><span class="p">;</span>

        <span class="cm">/** \brief defined as &quot;.octree&quot; to append to treepath files</span>
<span class="cm">         *  \note this might change</span>
<span class="cm">         */</span>
        <span class="k">const</span> <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TREE_EXTENSION_</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">OUTOFCORE_VERSION_</span><span class="p">;</span>

        <span class="k">const</span> <span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">LOAD_COUNT_</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">2e9</span><span class="p">);</span>

      <span class="k">private</span><span class="o">:</span>

        <span class="cm">/** \brief Auxiliary function to enlarge a bounding box to a cube. */</span>
        <span class="kt">void</span>
        <span class="n">enlargeToCube</span> <span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">bb_min</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="o">&amp;</span><span class="n">bb_max</span><span class="p">);</span>

        <span class="cm">/** \brief Auxiliary function to compute the depth of the tree given the bounding box and the desired size of the leaf voxels */</span>
        <span class="n">boost</span><span class="o">::</span><span class="kt">uint64_t</span>
        <span class="n">calculateDepth</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">min_bb</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&amp;</span> <span class="n">max_bb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">leaf_resolution</span><span class="p">);</span>

        <span class="kt">double</span> <span class="n">sample_percent_</span><span class="p">;</span>

        <span class="n">pcl</span><span class="o">::</span><span class="n">RandomSample</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">lod_filter_ptr_</span><span class="p">;</span>

    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_octree_impl_octree_base.hpp.html" class="btn btn-neutral float-right" title="File octree_base.hpp" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_outofcore_octree_base.h.html" class="btn btn-neutral float-left" title="File octree_base.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>