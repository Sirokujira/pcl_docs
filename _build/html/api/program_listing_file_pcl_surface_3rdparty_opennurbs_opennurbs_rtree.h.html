

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_rtree.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_sphere.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_sphere.h.html" />
    <link rel="prev" title="File opennurbs_rtree.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_rtree.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_rtree.h.html">File opennurbs_rtree.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_rtree.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_rtree.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-rtree-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-rtree-h"></span><h1>Program Listing for File opennurbs_rtree.h<a class="headerlink" href="#program-listing-for-file-opennurbs-rtree-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_rtree.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-rtree-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_rtree.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="cp">#if !defined(OPENNURBS_RTREE_INC_)</span>
<span class="cp">#define OPENNURBS_RTREE_INC_</span>

<span class="cm">/*</span>
<span class="cm">The opennurbs rtree code is a modifed version of the</span>
<span class="cm">free and unrestricted R-tree implementation obtianed from</span>
<span class="cm">http://www.superliminal.com/sources/sources.htm</span>

<span class="cm">The first lines on the website indicate the code is free and unrestricted:</span>

<span class="cm">  Free Source Code</span>
<span class="cm">  Here are a few useful bits of free source code.</span>
<span class="cm">  You&#39;re completely free to use them for any purpose whatsoever.</span>
<span class="cm">  All I ask is that if you find one to be particularly valuable,</span>
<span class="cm">  then consider sending feedback. Please send bugs and suggestions too.</span>
<span class="cm">  Enjoy</span>

<span class="cm">The readme.txt file included with the R-tree source says</span>

<span class="cm">  LICENSE:</span>
<span class="cm">    Entirely free for all uses. Enjoy!</span>

<span class="cm">The original authors are</span>

<span class="cm">AUTHORS</span>
<span class="cm"> * 1983 Original algorithm and test code by Antonin Guttman and Michael Stonebraker, UC Berkely</span>
<span class="cm"> * 1994 ANCI C ported from original test code by Melinda Green - melinda@superliminal.com</span>
<span class="cm"> * 1995 Sphere volume fix for degeneracy problem submitted by Paul Brook</span>
<span class="cm"> * 2004 Templated C++ port by Greg Douglas</span>

<span class="cm">The opennurbs version adds some custom memory allocation and replaces</span>
<span class="cm">the leaf iterator.  The rest of the changes are cosmetic.</span>

<span class="cm">*/</span>



<span class="c1">// Minimum and maximum number of elements</span>
<span class="c1">// in ON_RTreeNode::m_branch[].</span>
<span class="c1">// must have ON_RTree_MAX_NODE_COUNT &gt; ON_RTree_MIN_NODE_COUNT</span>
<span class="cp">#define ON_RTree_MIN_NODE_COUNT 2</span>
<span class="cp">#define ON_RTree_MAX_NODE_COUNT 6</span>

<span class="cm">/*</span>
<span class="cm">In a test of a sphere mesh with mesh: 8385 vertices, 8192 polygons</span>
<span class="cm">and ON_RTree_MAX_NODE_COUNT = 3, 4, 5, and 6, the memory use was</span>
<span class="cm">most efficient with ON_RTree_MAX_NODE_COUNT=6</span>

<span class="cm">Memory Usage MAX_NODE_COUNT = 3</span>
<span class="cm">  ON_RTree: 1212 KB (1241136) (352 wasted)</span>
<span class="cm">  ON_RTree: 7036 nodes, 5881 unused branches (321 KB) 0.835844 per node</span>

<span class="cm">Memory Usage MAX_NODE_COUNT = 4</span>
<span class="cm">  ON_RTree: 1152 KB (1179720) (5568 wasted)</span>
<span class="cm">  ON_RTree: 5051 nodes, 6962 unused branches (380 KB) 1.37834 per node</span>

<span class="cm">Memory Usage MAX_NODE_COUNT = 5</span>
<span class="cm">  ON_RTree: 1040 KB (1065504) (11808 wasted)</span>
<span class="cm">  ON_RTree: 3655 nodes, 6429 unused branches (351 KB) 1.75896 per node</span>

<span class="cm">Memory Usage MAX_NODE_COUNT = 6</span>
<span class="cm">  ON_RTree:  995 KB (1019592) (3440 wasted)</span>
<span class="cm">  ON_RTree: 2951 nodes, 6564 unused branches (358 KB) 2.22433 per node</span>
<span class="cm">*/</span>

<span class="c1">// This struct is used instead of ON_BoundingBox to avoid calling</span>
<span class="c1">// constructors.</span>
<span class="k">struct</span> <span class="n">ON_RTreeBBox</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">m_min</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">m_max</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_RTreeSphere</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">m_point</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">m_radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_RTreeCapsule</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">m_point</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">m_radius</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">m_domain</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_RTreeBranch</span>
<span class="p">{</span>
  <span class="n">ON_RTreeBBox</span> <span class="n">m_rect</span><span class="p">;</span>

  <span class="c1">// If ON_RTreeNode.m_level &gt; 0, then m_child points to a child node.</span>
  <span class="c1">// If ON_RTreeNode.m_level == 0, then m_id identifies the leaf element.</span>
  <span class="k">union</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="n">m_child</span><span class="p">;</span>
    <span class="n">ON__INT_PTR</span> <span class="n">m_id</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_RTreeLeaf</span>
<span class="p">{</span>
  <span class="n">ON_RTreeBBox</span> <span class="n">m_rect</span><span class="p">;</span>
  <span class="n">ON__INT_PTR</span> <span class="n">m_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The ON_RTreeNode is used at root, branch and leaf nodes.</span>
<span class="c1">// When m_level &gt; 0, the node is a branch.</span>
<span class="c1">// When m_level = 0, the node is a leaf.</span>
<span class="k">struct</span> <span class="n">ON_RTreeNode</span>
<span class="p">{</span>
  <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">IsInternalNode</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">m_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// internal nodes have m_level &gt; 0</span>
  <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">IsLeaf</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">m_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span> <span class="c1">// branch nodes have m_level = 0</span>

  <span class="c1">// m_level must be a signed int to insure signed compares work correctly</span>
  <span class="kt">int</span> <span class="n">m_level</span><span class="p">;</span>  <span class="c1">// =0 at leaf nodes, &gt; 0 at branch nodes</span>

  <span class="c1">// The m_branch[] array contains m_count elements</span>
  <span class="c1">// 0 &lt;= m_count &lt;= ON_RTree_MAX_NODE_COUNT</span>
  <span class="c1">// m_count must be a signed int to insure signed compares work correctly</span>
  <span class="kt">int</span> <span class="n">m_count</span><span class="p">;</span>
  <span class="n">ON_RTreeBranch</span> <span class="n">m_branch</span><span class="p">[</span><span class="n">ON_RTree_MAX_NODE_COUNT</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_RTreeSearchResult</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">m_capacity</span><span class="p">;</span>   <span class="c1">// m_id[] array capacity (search terminates when m_count == m_capacity)</span>
  <span class="kt">int</span> <span class="n">m_count</span><span class="p">;</span>      <span class="c1">// number of elements in m_id[]</span>
  <span class="n">ON__INT_PTR</span><span class="o">*</span> <span class="n">m_id</span><span class="p">;</span> <span class="c1">// m_id[] = array of search results.</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_RTreeMemPool</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_RTreeMemPool</span><span class="p">(</span> <span class="n">ON_MEMORY_POOL</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">leaf_count</span> <span class="p">);</span>
  <span class="o">~</span><span class="n">ON_RTreeMemPool</span><span class="p">();</span>

  <span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="nf">AllocNode</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">FreeNode</span><span class="p">(</span><span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">ON_RTreeListNode</span><span class="o">*</span> <span class="nf">AllocListNode</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">FreeListNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ON_RTreeListNode</span><span class="o">*</span> <span class="n">list_node</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">DeallocateAll</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Total number of bytes of heap memory allocated.</span>
<span class="cm">  */</span>
  <span class="kt">size_t</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of bytes of heap memory not currently in use.</span>
<span class="cm">  */</span>
  <span class="kt">size_t</span> <span class="nf">SizeOfUnusedBuffer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">GrowBuffer</span><span class="p">();</span>

  <span class="k">struct</span> <span class="n">Blk</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Blk</span><span class="o">*</span> <span class="n">m_next</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// linked list of unused ON_RTreeNode</span>
  <span class="k">struct</span> <span class="n">Blk</span><span class="o">*</span> <span class="n">m_nodes</span><span class="p">;</span>
  <span class="c1">// linked list of unused ON_RTreeListNode</span>
  <span class="k">struct</span> <span class="n">Blk</span><span class="o">*</span> <span class="n">m_list_nodes</span><span class="p">;</span>

  <span class="c1">// buffer for new allocations</span>
  <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">m_buffer</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_buffer_capacity</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">Blk</span><span class="o">*</span> <span class="n">m_blk_list</span><span class="p">;</span>   <span class="c1">// linked list used to free all allocated memory</span>
  <span class="kt">size_t</span> <span class="n">m_sizeof_blk</span><span class="p">;</span>      <span class="c1">// total amount of memory in each block.</span>

  <span class="n">ON_MEMORY_POOL</span><span class="o">*</span> <span class="n">m_heap</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_sizeof_heap</span><span class="p">;</span> <span class="c1">// total amount of heap memory in this rtree</span>
<span class="p">};</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// ON_RTreeIterator</span>
<span class="c1">//</span>
<span class="c1">//   The ON_RTreeIterator class can be used to iterate each leaf</span>
<span class="c1">//   in an ON_RTree.</span>
<span class="c1">//</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_RTreeIterator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Construct an empty iterator.  Call Initialize() to attach</span>
<span class="cm">    the iterator to an R-tree.</span>
<span class="cm">  Remark:</span>
<span class="cm">    Any calls to ON_RTree::Insert() or ON_RTree::Remove() that modify</span>
<span class="cm">    an R-tree being iterated invalidate the iterator.  The iterator</span>
<span class="cm">    must be re-initialized before being used again.</span>

<span class="cm">    There is no connection between the order elements are inserted</span>
<span class="cm">    in an R-tree and the order the elements are iterated by an</span>
<span class="cm">    iterator.</span>
<span class="cm">  */</span>
  <span class="n">ON_RTreeIterator</span><span class="p">();</span>
  <span class="n">ON_RTreeIterator</span><span class="p">(</span><span class="k">const</span> <span class="k">class</span> <span class="nc">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtree</span><span class="p">);</span>

  <span class="o">~</span><span class="n">ON_RTreeIterator</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Initialize an iterator to iterate every leaf in the rtree.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_rtree - [in]</span>
<span class="cm">      R-tree to iterate</span>
<span class="cm">  Example:</span>
<span class="cm">    See the comment for ON_RTreeIterator::First().</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a_rtree has at least one element.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Any calls to ON_RTree::Insert() or ON_RTree::Remove() that modify</span>
<span class="cm">    this node or its children will invalidate this iterator and it</span>
<span class="cm">    must be re-initialized.</span>

<span class="cm">    There is no connection between the order elements are inserted</span>
<span class="cm">    in an R-tree and the order the elements are iterated by an</span>
<span class="cm">    iterator.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Initialize</span><span class="p">(</span><span class="k">const</span> <span class="k">class</span> <span class="nc">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtree</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Initialize an iterator to iterate every leaf on or below a_node.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_node - [in]</span>
<span class="cm">      R-tree node to iterate</span>
<span class="cm">  Example:</span>
<span class="cm">    See the comment for ON_RTreeIterator::First().</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a_node has at least one element.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Any calls to ON_RTree::Insert() or ON_RTree::Remove() that modify</span>
<span class="cm">    this node or its children will invalidate this iterator and it</span>
<span class="cm">    must be re-initialized.</span>

<span class="cm">    There is no connection between the order elements are inserted</span>
<span class="cm">    in an R-tree and the order the elements are iterated by an</span>
<span class="cm">    iterator.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Initialize</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="n">a_node</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the value of the current leaf element. Calling Value()</span>
<span class="cm">    does not increment or decrement the iterator.</span>
<span class="cm">  Example:</span>
<span class="cm">    See the comment for ON_RTreeIterator::First().</span>
<span class="cm">  Return:</span>
<span class="cm">    Null pointer if there are no more leaves to iterate</span>
<span class="cm">    A pointer to the current R-tree leaf.  When there are no more leaves,</span>
<span class="cm">    the returned pointer is null.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_RTreeBranch</span><span class="o">*</span> <span class="nf">Value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Reset the iterator so the current leaf is the first leaf in</span>
<span class="cm">    the R-tree.  The Initialize() functions automatically do</span>
<span class="cm">    this, but First() can be called if an iterator needs to be</span>
<span class="cm">    used more than once or to make code easy to read and understand.</span>
<span class="cm">  Example:</span>
<span class="cm">    Iterate every leaf in an R-tree.</span>

<span class="cm">          ON_RTree rtree;</span>
<span class="cm">          ...</span>
<span class="cm">          ON_RtreeIterator rit(rtree);</span>
<span class="cm">          const ON_RTreeBranch* rtree_leaf;</span>
<span class="cm">          for ( rit.First(); 0 != (rtree_leaf = rit.Value()); rit.Next() )</span>
<span class="cm">          {</span>
<span class="cm">            // leaf id           = rtree_leaf-&gt;m_id</span>
<span class="cm">            // leaf bounding box = rtree-&gt;m_rect</span>
<span class="cm">          }</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if a call to Value() will return a non-null pointer.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_RTreeIterator::Last();</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">First</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Increment the iterator to the next leaf in the R-tree.</span>
<span class="cm">  Example:</span>
<span class="cm">    See the comment for ON_RTreeIterator::First()</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a call to Value() will return a non-null pointer.</span>
<span class="cm">    False if there is not a next leaf and all susequent calls to</span>
<span class="cm">    Value() will return null.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_RTreeIterator::Prev();</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Next</span><span class="p">();</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the iterator so the current leaf is the last leaf in the R-tree.</span>

<span class="cm">  Example:</span>
<span class="cm">    Iterate an R-tree in reverse order.</span>

<span class="cm">          ON_RTree rtree;</span>
<span class="cm">          ...</span>
<span class="cm">          ON_RTreeIterator rit(rtree);</span>
<span class="cm">          const ON_RTreeBranch* rtree_leaf;</span>
<span class="cm">          for ( rit.Last(); 0 != (rtree_leaf = rit.Value()); rit.Prev() )</span>
<span class="cm">          {</span>
<span class="cm">            // leaf id           = rtree_leaf-&gt;m_id</span>
<span class="cm">            // leaf bounding box = rtree-&gt;m_rect</span>
<span class="cm">          }</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if a call to Value() will return a non-null pointer.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_RTreeIterator::First();</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Last</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Decrement the iterator to the previous leaf in the R-tree.</span>
<span class="cm">  Example:</span>
<span class="cm">    See the comment for ON_RTreeIterator::Last()</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a call to Value() will return a non-null pointer.</span>
<span class="cm">    False if there is not a previous leaf and all susequent calls to</span>
<span class="cm">    Value() will return null.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_RTreeIterator::Next();</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Prev</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">MAX_STACK</span> <span class="o">=</span> <span class="mi">32</span> <span class="p">};</span> <span class="c1">//  Max stack size. Allows almost n^32 where n is number of branches in node</span>

  <span class="k">struct</span> <span class="n">StackElement</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="n">m_node</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_branchIndex</span><span class="p">;</span> <span class="c1">// must be a signed int to insure signed compares work correctly</span>
  <span class="p">};</span>

  <span class="kt">bool</span> <span class="nf">PushChildren</span><span class="p">(</span><span class="k">struct</span> <span class="n">StackElement</span><span class="o">*</span> <span class="n">sp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bFirstChild</span><span class="p">);</span>

  <span class="n">StackElement</span>  <span class="n">m_stack</span><span class="p">[</span><span class="n">MAX_STACK</span><span class="p">];</span> <span class="c1">// stack</span>
  <span class="n">StackElement</span><span class="o">*</span> <span class="n">m_sp</span><span class="p">;</span>               <span class="c1">// stack pointer (null or points into m_stack[])</span>
  <span class="k">const</span> <span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="n">m_root</span><span class="p">;</span>       <span class="c1">// root of tree being iterated</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_RTree</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_RTree</span><span class="p">(</span> <span class="n">ON_MEMORY_POOL</span><span class="o">*</span> <span class="n">heap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">leaf_count</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
  <span class="o">~</span><span class="n">ON_RTree</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create an R-tree with an element for each face in the mesh.</span>
<span class="cm">    The element id is set to the index of the face.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CreateMeshFaceTree</span><span class="p">(</span> <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_Mesh</span><span class="o">*</span> <span class="n">mesh</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Insert an element into the RTree.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_min - [in]</span>
<span class="cm">    a_max - [in]</span>
<span class="cm">      3d bounding box of the element.  The values in a_min[3] and a_max[3]</span>
<span class="cm">      must satisfy</span>
<span class="cm">      a_min[0] &lt;= a_max[0],</span>
<span class="cm">      a_min[1] &lt;= a_max[1], and</span>
<span class="cm">      a_min[1] &lt;= a_max[1].</span>
<span class="cm">    a_dataId - [in]</span>
<span class="cm">      id of the element.  This can be either a pointer or an integer id.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if element was successfully inserted.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Calling Insert() or Remove() invalidates any ON_RTreeIterator</span>
<span class="cm">    used to iterate this rtree.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a_element_id</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="kt">int</span> <span class="n">a_element_id</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Insert2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a_element_id</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Insert2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="kt">int</span> <span class="n">a_element_id</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Remove an element from the RTree.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_min - [in]</span>
<span class="cm">    a_max - [in]</span>
<span class="cm">      3d bounding box of the element.  The values in a_min[3] and a_max[3]</span>
<span class="cm">      must satisfy</span>
<span class="cm">      a_min[0] &lt;= a_max[0],</span>
<span class="cm">      a_min[1] &lt;= a_max[1], and</span>
<span class="cm">      a_min[2] &lt;= a_max[2].</span>
<span class="cm">    a_dataId - [in]</span>
<span class="cm">      id of the element.  This can be either a pointer or an integer id.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if element was successfully removed.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Calling Insert() or Remove() invalidates any ON_RTreeIterator</span>
<span class="cm">    used to iterate this rtree.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Remove</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a_elementId</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Remove</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="kt">int</span> <span class="n">a_elementId</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Remove2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a_elementId</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Remove2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="kt">int</span> <span class="n">a_elementId</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Remove all elements from the R-tree.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">RemoveAll</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Search the R-tree for all elements whose bounding boxes overlap</span>
<span class="cm">    a_rect.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_rect - [in/out]</span>
<span class="cm">      The version of search that has ON_RTreeBBox* a_rect as the first</span>
<span class="cm">      argument, allows you to shrink the a_rect as the search progresses.</span>
<span class="cm">      This is useful for doing things like searching for closest points.</span>
<span class="cm">      If you want to shrink a_rect, you must use a_context to pass it</span>
<span class="cm">      to the resultCallback function and shrink it in the resultCallback</span>
<span class="cm">      function. In the callback, the modified rect must be contained</span>
<span class="cm">      in the previous rect.</span>
<span class="cm">    a_sphere - [in/out]</span>
<span class="cm">      The version of search that has ON_RTreeSphere* a_sphere as the first</span>
<span class="cm">      argument, allows you to shrink the a_sphere as the search progresses.</span>
<span class="cm">      This is useful for doing things like searching for closest points.</span>
<span class="cm">      If you want to shrink a_sphere, you must use a_context to pass it</span>
<span class="cm">      to the resultCallback function and shrink it in the resultCallback</span>
<span class="cm">      function. In the callback, the modified sphere must be contained</span>
<span class="cm">      in the previous sphere.</span>
<span class="cm">    a_capsule - [in/out]</span>
<span class="cm">      The version of search that has ON_RTreeSphere* a_capsule as the first</span>
<span class="cm">      argument, allows you to shrink the a_capsule as the search progresses.</span>
<span class="cm">      This is useful for doing things like searching for closest points.</span>
<span class="cm">      If you want to shrink a_capsule, you must use a_context to pass it</span>
<span class="cm">      to the resultCallback function and shrink it in the resultCallback</span>
<span class="cm">      function. In the callback, the modified capsule must be contained</span>
<span class="cm">      in the previous capsule.</span>
<span class="cm">    a_min - [in]</span>
<span class="cm">    a_max - [in]</span>
<span class="cm">      (a_min,a_max) is the bounding box of the search region.</span>
<span class="cm">    a_results - [out]</span>
<span class="cm">      The ids of elements that overlaps the search region.</span>
<span class="cm">    resultCallback - [in]</span>
<span class="cm">      A function to call when leaf nodes overlap.</span>
<span class="cm">    a_context - [in]</span>
<span class="cm">      pointer passed to the resultCallback() function.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if entire tree was searched.  It is possible no results were found.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If you are using a Search() that uses a resultCallback() function,</span>
<span class="cm">    then return true to keep searching and false to terminate the search.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span>
    <span class="n">ON_RTreeSphere</span><span class="o">*</span> <span class="n">a_sphere</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_id</span><span class="p">),</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span>
    <span class="n">ON_RTreeCapsule</span><span class="o">*</span> <span class="n">a_capsule</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_id</span><span class="p">),</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span>
    <span class="n">ON_RTreeBBox</span><span class="o">*</span> <span class="n">a_rect</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_id</span><span class="p">),</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Search the R-tree for all elements whose bounding boxes overlap</span>
<span class="cm">    the set of points between to parallel planes.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_plane_eqn - [in]</span>
<span class="cm">    a_min - [in]</span>
<span class="cm">    a_max - [in]</span>
<span class="cm">      The region between the parallel planes is the set point points</span>
<span class="cm">      where the value of the plane equation is &gt;= a_min and &lt;= a_max.</span>
<span class="cm">    resultCallback - [in]</span>
<span class="cm">      A function to call when leaf nodes overlap the region between</span>
<span class="cm">      the parallel planes.</span>
<span class="cm">    a_context - [in]</span>
<span class="cm">      pointer passed to the resultCallback() function.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if entire tree was searched.  It is possible no results were found.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If you are using a Search() that uses a resultCallback() function,</span>
<span class="cm">    then return true to keep searching and false to terminate the search.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">a_plane_eqn</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">a_min</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">a_max</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_id</span><span class="p">),</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="kt">bool</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_id</span><span class="p">),</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="n">ON_RTreeSearchResult</span><span class="o">&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_RTreeLeaf</span><span class="o">&gt;&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="kt">bool</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_id</span><span class="p">),</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">ON_RTreeSearchResult</span><span class="o">&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_RTreeLeaf</span><span class="o">&gt;&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Search2d</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">a_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a_result</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Search two R-trees for all pairs elements whose bounding boxes overlap.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_rtreeA - [in]</span>
<span class="cm">    a_rtreeB - [in]</span>
<span class="cm">    tolerance - [in]</span>
<span class="cm">      If the distance between a pair of bounding boxes is &lt;= tolerance,</span>
<span class="cm">      then the pair is added to a_result[].</span>
<span class="cm">    a_result - [out]</span>
<span class="cm">      Pairs of ids of elements who bounding boxes overlap.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if entire tree was searched.  It is possible no results were found.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtreeA</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtreeB</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">tolerance</span><span class="p">,</span>
          <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dex</span><span class="o">&gt;&amp;</span> <span class="n">a_result</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Search two R-trees for all pairs elements whose bounding boxes overlap.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_rtreeA - [in]</span>
<span class="cm">    a_rtreeB - [in]</span>
<span class="cm">    tolerance - [in]</span>
<span class="cm">      If the distance between a pair of bounding boxes is &lt;= tolerance,</span>
<span class="cm">      then resultCallback() is called.</span>
<span class="cm">    resultCallback - [out]</span>
<span class="cm">      callback function</span>
<span class="cm">    a_context - [in] argument passed through to resultCallback().</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if entire tree was searched.  It is possible no results were found.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtreeA</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtreeB</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">tolerance</span><span class="p">,</span>
          <span class="kt">void</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_idA</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_idB</span><span class="p">),</span>
          <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Search two R-trees for all pairs elements whose bounding boxes overlap.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    a_rtreeA - [in]</span>
<span class="cm">    a_rtreeB - [in]</span>
<span class="cm">    tolerance - [in]</span>
<span class="cm">      If the distance between a pair of bounding boxes is &lt;= tolerance,</span>
<span class="cm">      then resultCallback() is called.</span>
<span class="cm">    resultCallback - [out]</span>
<span class="cm">      callback function</span>
<span class="cm">      Return true for the search to continue and false to terminate the search.</span>
<span class="cm">    a_context - [in] argument passed through to resultCallback().</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if entire tree was searched.  It is possible no results were found.</span>
<span class="cm">  */</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Search</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtreeA</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">ON_RTree</span><span class="o">&amp;</span> <span class="n">a_rtreeB</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">tolerance</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">ON_MSC_CDECL</span> <span class="n">resultCallback</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_idA</span><span class="p">,</span> <span class="n">ON__INT_PTR</span> <span class="n">a_idB</span><span class="p">),</span>
          <span class="kt">void</span><span class="o">*</span> <span class="n">a_context</span>
          <span class="p">);</span>
  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of elements (leaves).</span>
<span class="cm">  Remark:</span>
<span class="cm">    No internal count is maintained, so this function traverses the</span>
<span class="cm">    tree to count the leaves.  If efficiency is important, save the</span>
<span class="cm">    result.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">ElementCount</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Pointer to the root node.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="nf">Root</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Bounding box of the entire R-tree;</span>
<span class="cm">  */</span>
  <span class="n">ON_BoundingBox</span> <span class="nf">BoundingBox</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of bytes of heap memory used by this R-tree.</span>
<span class="cm">  */</span>
  <span class="kt">size_t</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">SplitNode</span><span class="p">(</span><span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_RTreeBranch</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">**</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">AddBranch</span><span class="p">(</span><span class="n">ON_RTreeBranch</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">**</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">InsertRectRec</span><span class="p">(</span><span class="n">ON_RTreeBBox</span><span class="o">*</span><span class="p">,</span> <span class="n">ON__INT_PTR</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">InsertRect</span><span class="p">(</span><span class="n">ON_RTreeBBox</span><span class="o">*</span><span class="p">,</span> <span class="n">ON__INT_PTR</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">**</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">LoadNodes</span><span class="p">(</span><span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ON_RTreePartitionVars</span><span class="o">*</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">RemoveRect</span><span class="p">(</span><span class="n">ON_RTreeBBox</span><span class="o">*</span><span class="p">,</span> <span class="n">ON__INT_PTR</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">**</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">RemoveRectRec</span><span class="p">(</span><span class="n">ON_RTreeBBox</span><span class="o">*</span><span class="p">,</span> <span class="n">ON__INT_PTR</span><span class="p">,</span> <span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ON_RTreeListNode</span><span class="o">**</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">ReInsert</span><span class="p">(</span><span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ON_RTreeListNode</span><span class="o">**</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">RemoveAllRec</span><span class="p">(</span><span class="n">ON_RTreeNode</span><span class="o">*</span><span class="p">);</span>
  <span class="n">ON_RTreeNode</span><span class="o">*</span> <span class="n">m_root</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">m_reserved</span><span class="p">;</span>
  <span class="n">ON_RTreeMemPool</span> <span class="n">m_mem_pool</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_sphere.h.html" class="btn btn-neutral float-right" title="File opennurbs_sphere.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_rtree.h.html" class="btn btn-neutral float-left" title="File opennurbs_rtree.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>