

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File conditional_removal.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File conditional_removal.hpp" href="file_pcl_filters_impl_conditional_removal.hpp.html" />
    <link rel="prev" title="File conditional_removal.h" href="file_pcl_filters_conditional_removal.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_filters_conditional_removal.h.html">File conditional_removal.h</a> &raquo;</li>
        
      <li>Program Listing for File conditional_removal.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_filters_conditional_removal.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-conditional-removal-h">
<span id="program-listing-file-pcl-filters-conditional-removal-h"></span><h1>Program Listing for File conditional_removal.h<a class="headerlink" href="#program-listing-for-file-conditional-removal-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_filters_conditional_removal.h.html#file-pcl-filters-conditional-removal-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\filters\conditional_removal.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Software License Agreement (BSD License)</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2010, Willow Garage, Inc.</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above</span>
<span class="cm"> *     copyright notice, this list of conditions and the following</span>
<span class="cm"> *     disclaimer in the documentation and/or other materials provided</span>
<span class="cm"> *     with the distribution.</span>
<span class="cm"> *   * Neither the name of the copyright holder(s) nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="cm"> *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span>
<span class="cm"> *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="cm"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="cm"> *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<span class="cm"> *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> *  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> * $Id$</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/common/eigen.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/filter.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">pcl</span>
<span class="p">{</span>
  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="k">namespace</span> <span class="n">ComparisonOps</span>
  <span class="p">{</span>
    <span class="cm">/** \brief The kind of comparison operations that are possible within a</span>
<span class="cm">      * comparison object</span>
<span class="cm">      */</span>
    <span class="k">typedef</span> <span class="k">enum</span>
    <span class="p">{</span>
      <span class="n">GT</span><span class="p">,</span> <span class="n">GE</span><span class="p">,</span> <span class="n">LT</span><span class="p">,</span> <span class="n">LE</span><span class="p">,</span> <span class="n">EQ</span>
    <span class="p">}</span> <span class="n">CompareOp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief A datatype that enables type-correct comparisons. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">PointDataAtOffset</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="cm">/** \brief Constructor. */</span>
      <span class="n">PointDataAtOffset</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">datatype</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">datatype_</span> <span class="p">(</span><span class="n">datatype</span><span class="p">),</span> <span class="n">offset_</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span>
      <span class="p">{</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Compare function.</span>
<span class="cm">        * \param p the point to compare</span>
<span class="cm">        * \param val the value to compare the point to</span>
<span class="cm">        */</span>
      <span class="kt">int</span>
      <span class="n">compare</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief The type of data. */</span>
      <span class="kt">uint8_t</span> <span class="n">datatype_</span><span class="p">;</span>

      <span class="cm">/** \brief The data offset. */</span>
      <span class="kt">uint32_t</span> <span class="n">offset_</span><span class="p">;</span>
    <span class="k">private</span><span class="o">:</span>
      <span class="n">PointDataAtOffset</span> <span class="p">()</span> <span class="o">:</span> <span class="n">datatype_</span> <span class="p">(),</span> <span class="n">offset_</span> <span class="p">()</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief The (abstract) base class for the comparison object. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">ComparisonBase</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="k">const</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Constructor. */</span>
      <span class="n">ComparisonBase</span> <span class="p">()</span> <span class="o">:</span> <span class="n">capable_</span> <span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">offset_</span> <span class="p">(),</span> <span class="n">op_</span> <span class="p">()</span> <span class="p">{}</span>

      <span class="cm">/** \brief Destructor. */</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">ComparisonBase</span> <span class="p">()</span> <span class="p">{}</span>

      <span class="cm">/** \brief Return if the comparison is capable. */</span>
      <span class="kr">inline</span> <span class="kt">bool</span>
      <span class="n">isCapable</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">capable_</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Evaluate function. */</span>
      <span class="k">virtual</span> <span class="kt">bool</span>
      <span class="n">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief True if capable. */</span>
      <span class="kt">bool</span> <span class="n">capable_</span><span class="p">;</span>

      <span class="cm">/** \brief Field name to compare data on. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">field_name_</span><span class="p">;</span>

      <span class="cm">/** \brief The data offset. */</span>
      <span class="kt">uint32_t</span> <span class="n">offset_</span><span class="p">;</span>

      <span class="cm">/** \brief The comparison operator type. */</span>
      <span class="n">ComparisonOps</span><span class="o">::</span><span class="n">CompareOp</span> <span class="n">op_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief The field-based specialization of the comparison object. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">FieldComparison</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">field_name_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">op_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">capable_</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">FieldComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="k">const</span> <span class="n">FieldComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>


      <span class="cm">/** \brief Construct a FieldComparison</span>
<span class="cm">        * \param field_name the name of the field that contains the data we want to compare</span>
<span class="cm">        * \param op the operator to use when making the comparison</span>
<span class="cm">        * \param compare_val the constant value to compare the field value too</span>
<span class="cm">        */</span>
      <span class="n">FieldComparison</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">field_name</span><span class="p">,</span> <span class="n">ComparisonOps</span><span class="o">::</span><span class="n">CompareOp</span> <span class="n">op</span><span class="p">,</span> <span class="kt">double</span> <span class="n">compare_val</span><span class="p">);</span>

      <span class="cm">/** \brief Copy constructor.</span>
<span class="cm">        * \param[in] src the field comparison object to copy into this</span>
<span class="cm">        */</span>
      <span class="n">FieldComparison</span> <span class="p">(</span><span class="k">const</span> <span class="n">FieldComparison</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="p">()</span>
        <span class="p">,</span> <span class="n">compare_val_</span> <span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">compare_val_</span><span class="p">),</span> <span class="n">point_data_</span> <span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">point_data_</span><span class="p">)</span>
      <span class="p">{</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Copy operator.</span>
<span class="cm">        * \param[in] src the field comparison object to copy into this</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="n">FieldComparison</span><span class="o">&amp;</span>
      <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">FieldComparison</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">compare_val_</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">compare_val_</span><span class="p">;</span>
        <span class="n">point_data_</span>  <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">point_data_</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Destructor. */</span>
      <span class="o">~</span><span class="n">FieldComparison</span> <span class="p">();</span>

      <span class="cm">/** \brief Determine the result of this comparison.</span>
<span class="cm">        * \param point the point to evaluate</span>
<span class="cm">        * \return the result of this comparison.</span>
<span class="cm">        */</span>
      <span class="kt">bool</span>
      <span class="nf">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief All types (that we care about) can be represented as a double. */</span>
      <span class="kt">double</span> <span class="n">compare_val_</span><span class="p">;</span>

      <span class="cm">/** \brief The point data to compare. */</span>
      <span class="n">PointDataAtOffset</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;*</span> <span class="n">point_data_</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
      <span class="n">FieldComparison</span> <span class="p">()</span> <span class="o">:</span>
        <span class="n">compare_val_</span> <span class="p">(),</span> <span class="n">point_data_</span> <span class="p">()</span>
      <span class="p">{</span>
      <span class="p">}</span> <span class="c1">// not allowed</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief A packed rgb specialization of the comparison object. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">PackedRGBComparison</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">capable_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">op_</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">PackedRGBComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="k">const</span> <span class="n">PackedRGBComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Construct a PackedRGBComparison</span>
<span class="cm">        * \param component_name either &quot;r&quot;, &quot;g&quot; or &quot;b&quot;</span>
<span class="cm">        * \param op the operator to use when making the comparison</span>
<span class="cm">        * \param compare_val the constant value to compare the component value too</span>
<span class="cm">        */</span>
      <span class="n">PackedRGBComparison</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">component_name</span><span class="p">,</span> <span class="n">ComparisonOps</span><span class="o">::</span><span class="n">CompareOp</span> <span class="n">op</span><span class="p">,</span> <span class="kt">double</span> <span class="n">compare_val</span><span class="p">);</span>

      <span class="cm">/** \brief Destructor. */</span>
      <span class="o">~</span><span class="n">PackedRGBComparison</span> <span class="p">()</span> <span class="p">{}</span>

      <span class="cm">/** \brief Determine the result of this comparison.</span>
<span class="cm">        * \param point the point to evaluate</span>
<span class="cm">        * \return the result of this comparison.</span>
<span class="cm">        */</span>
      <span class="kt">bool</span>
      <span class="n">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief The name of the component. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">component_name_</span><span class="p">;</span>

      <span class="cm">/** \brief The offset of the component */</span>
      <span class="kt">uint32_t</span> <span class="n">component_offset_</span><span class="p">;</span>

      <span class="cm">/** \brief All types (that we care about) can be represented as a double. */</span>
      <span class="kt">double</span> <span class="n">compare_val_</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
      <span class="n">PackedRGBComparison</span> <span class="p">()</span> <span class="o">:</span>
        <span class="n">component_offset_</span> <span class="p">(),</span> <span class="n">compare_val_</span> <span class="p">()</span>
      <span class="p">{</span>
      <span class="p">}</span> <span class="c1">// not allowed</span>

  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief A packed HSI specialization of the comparison object. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">PackedHSIComparison</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">capable_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">op_</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="n">PackedHSIComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span> <span class="k">const</span> <span class="n">PackedHSIComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Construct a PackedHSIComparison</span>
<span class="cm">        * \param component_name either &quot;h&quot;, &quot;s&quot; or &quot;i&quot;</span>
<span class="cm">        * \param op the operator to use when making the comparison</span>
<span class="cm">        * \param compare_val the constant value to compare the component value too</span>
<span class="cm">        */</span>
      <span class="n">PackedHSIComparison</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">component_name</span><span class="p">,</span> <span class="n">ComparisonOps</span><span class="o">::</span><span class="n">CompareOp</span> <span class="n">op</span><span class="p">,</span> <span class="kt">double</span> <span class="n">compare_val</span><span class="p">);</span>

      <span class="cm">/** \brief Destructor. */</span>
      <span class="o">~</span><span class="n">PackedHSIComparison</span> <span class="p">()</span> <span class="p">{}</span>

      <span class="cm">/** \brief Determine the result of this comparison.</span>
<span class="cm">        * \param point the point to evaluate</span>
<span class="cm">        * \return the result of this comparison.</span>
<span class="cm">        */</span>
      <span class="kt">bool</span>
      <span class="n">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

      <span class="k">typedef</span> <span class="k">enum</span>
      <span class="p">{</span>
        <span class="n">H</span><span class="p">,</span> <span class="c1">// -128 to 127 corresponds to -pi to pi</span>
        <span class="n">S</span><span class="p">,</span> <span class="c1">// 0 to 255</span>
        <span class="n">I</span>  <span class="c1">// 0 to 255</span>
      <span class="p">}</span> <span class="n">ComponentId</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief The name of the component. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">component_name_</span><span class="p">;</span>

      <span class="cm">/** \brief The ID of the component. */</span>
      <span class="n">ComponentId</span> <span class="n">component_id_</span><span class="p">;</span>

      <span class="cm">/** \brief All types (that we care about) can be represented as a double. */</span>
      <span class="kt">double</span> <span class="n">compare_val_</span><span class="p">;</span>

      <span class="cm">/** \brief The offset of the component */</span>
      <span class="kt">uint32_t</span> <span class="n">rgb_offset_</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
      <span class="n">PackedHSIComparison</span> <span class="p">()</span> <span class="o">:</span>
        <span class="n">component_id_</span> <span class="p">(),</span> <span class="n">compare_val_</span> <span class="p">(),</span> <span class="n">rgb_offset_</span> <span class="p">()</span>
      <span class="p">{</span>
      <span class="p">}</span> <span class="c1">// not allowed</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/**\brief A comparison whether the (x,y,z) components of a given point satisfy (p&#39;Ap + 2v&#39;p + c [OP] 0).</span>
<span class="cm">   * Here [OP] stands for the defined pcl::ComparisonOps, i.e. for GT, GE, LT, LE or EQ;</span>
<span class="cm">   * p = (x,y,z) is a point of the point cloud; A is 3x3 matrix; v is the 3x1 vector; c is a scalar.</span>
<span class="cm">   *</span>
<span class="cm">   * One can also use TfQuadraticXYZComparison for simpler geometric shapes by defining the</span>
<span class="cm">   * quadratic parts (i.e. the matrix A) to be zero. By combining different instances of</span>
<span class="cm">   * TfQuadraticXYZComparison one can get more complex shapes. For example, to have a simple</span>
<span class="cm">   * cylinder (along the x-axis) of specific length one needs three comparisons combined as AND condition:</span>
<span class="cm">   *   1. The cylinder: A = [0 0 0, 0 1 0, 0 0 1]; v = [0, 0, 0]; c = radius²; OP = LT (meaning &quot;&lt;&quot;)</span>
<span class="cm">   *   2. X-min limit: A = 0; v = [1, 0, 0]; c = x_min; OP = GT</span>
<span class="cm">   *   3. X-max ...</span>
<span class="cm">   *</span>
<span class="cm">   * \author Julian Löchner</span>
<span class="cm">   */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">TfQuadraticXYZComparison</span> <span class="o">:</span> <span class="k">public</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>     <span class="c1">//needed whenever there is a fixed size Eigen:: vector or matrix in a class</span>

      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TfQuadraticXYZComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TfQuadraticXYZComparison</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Constructor.</span>
<span class="cm">       */</span>
      <span class="n">TfQuadraticXYZComparison</span> <span class="p">();</span>

      <span class="cm">/** \brief Empty destructor */</span>
      <span class="o">~</span><span class="n">TfQuadraticXYZComparison</span> <span class="p">()</span> <span class="p">{}</span>

      <span class="cm">/** \brief Constructor.</span>
<span class="cm">       * \param op the operator &quot;[OP]&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       * \param comparison_matrix the matrix &quot;A&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       * \param comparison_vector the vector &quot;v&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       * \param comparison_scalar the scalar &quot;c&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       * \param comparison_transform the transformation of the comparison.</span>
<span class="cm">       */</span>
      <span class="n">TfQuadraticXYZComparison</span> <span class="p">(</span><span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonOps</span><span class="o">::</span><span class="n">CompareOp</span> <span class="n">op</span><span class="p">,</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3f</span> <span class="o">&amp;</span><span class="n">comparison_matrix</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="o">&amp;</span><span class="n">comparison_vector</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">comparison_scalar</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3f</span> <span class="o">&amp;</span><span class="n">comparison_transform</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3f</span><span class="o">::</span><span class="n">Identity</span> <span class="p">());</span>

      <span class="cm">/** \brief set the operator &quot;[OP]&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setComparisonOperator</span> <span class="p">(</span><span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonOps</span><span class="o">::</span><span class="n">CompareOp</span> <span class="n">op</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">op_</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief set the matrix &quot;A&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setComparisonMatrix</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3f</span> <span class="o">&amp;</span><span class="n">matrix</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">//define comp_matr_ as an homogeneous matrix of the given matrix</span>
        <span class="n">comp_matr_</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">;</span>
        <span class="n">comp_matr_</span><span class="p">.</span><span class="n">col</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">comp_matr_</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">tf_comp_matr_</span> <span class="o">=</span> <span class="n">comp_matr_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief set the matrix &quot;A&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setComparisonMatrix</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span> <span class="o">&amp;</span><span class="n">homogeneousMatrix</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">comp_matr_</span> <span class="o">=</span> <span class="n">homogeneousMatrix</span><span class="p">;</span>
        <span class="n">tf_comp_matr_</span> <span class="o">=</span> <span class="n">comp_matr_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief set the vector &quot;v&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setComparisonVector</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="o">&amp;</span><span class="n">vector</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">comp_vect_</span> <span class="o">=</span> <span class="n">vector</span><span class="p">.</span><span class="n">homogeneous</span> <span class="p">();</span>
        <span class="n">tf_comp_vect_</span> <span class="o">=</span> <span class="n">comp_vect_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief set the vector &quot;v&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setComparisonVector</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span> <span class="o">&amp;</span><span class="n">homogeneousVector</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">comp_vect_</span> <span class="o">=</span> <span class="n">homogeneousVector</span><span class="p">;</span>
        <span class="n">tf_comp_vect_</span> <span class="o">=</span> <span class="n">comp_vect_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief set the scalar &quot;c&quot; of the comparison &quot;p&#39;Ap + 2v&#39;p + c [OP] 0&quot;.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setComparisonScalar</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">scalar</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">comp_scalar_</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief transform the coordinate system of the comparison. If you think of</span>
<span class="cm">       * the transformation to be a translation and rotation of the comparison in the</span>
<span class="cm">       * same coordinate system, you have to provide the inverse transformation.</span>
<span class="cm">       * This function does not change the original definition of the comparison. Thus,</span>
<span class="cm">       * each call of this function will assume the original definition of the comparison</span>
<span class="cm">       * as starting point for the transformation.</span>
<span class="cm">       *</span>
<span class="cm">       * @param transform the transformation (rotation and translation) as an affine matrix.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">transformComparison</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span> <span class="o">&amp;</span><span class="n">transform</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">tf_comp_matr_</span> <span class="o">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">transpose</span> <span class="p">()</span> <span class="o">*</span> <span class="n">comp_matr_</span> <span class="o">*</span> <span class="n">transform</span><span class="p">;</span>
        <span class="n">tf_comp_vect_</span> <span class="o">=</span> <span class="n">comp_vect_</span><span class="p">.</span><span class="n">transpose</span> <span class="p">()</span> <span class="o">*</span> <span class="n">transform</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief transform the coordinate system of the comparison. If you think of</span>
<span class="cm">       * the transformation to be a translation and rotation of the comparison in the</span>
<span class="cm">       * same coordinate system, you have to provide the inverse transformation.</span>
<span class="cm">       * This function does not change the original definition of the comparison. Thus,</span>
<span class="cm">       * each call of this function will assume the original definition of the comparison</span>
<span class="cm">       * as starting point for the transformation.</span>
<span class="cm">       *</span>
<span class="cm">       * @param transform the transformation (rotation and translation) as an affine matrix.</span>
<span class="cm">       */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">transformComparison</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Affine3f</span> <span class="o">&amp;</span><span class="n">transform</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">transformComparison</span> <span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">matrix</span> <span class="p">());</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Determine the result of this comparison.</span>
<span class="cm">       * \param point the point to evaluate</span>
<span class="cm">       * \return the result of this comparison.</span>
<span class="cm">       */</span>
      <span class="kt">bool</span>
      <span class="nf">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="k">using</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">capable_</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">op_</span><span class="p">;</span>

      <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span> <span class="n">comp_matr_</span><span class="p">;</span>
      <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span> <span class="n">comp_vect_</span><span class="p">;</span>

      <span class="kt">float</span> <span class="n">comp_scalar_</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
      <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span> <span class="n">tf_comp_matr_</span><span class="p">;</span>
      <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span> <span class="n">tf_comp_vect_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief Base condition class. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">ConditionBase</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="n">ComparisonBase</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ComparisonBase</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">ComparisonBasePtr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ComparisonBase</span><span class="o">::</span><span class="n">ConstPtr</span> <span class="n">ComparisonBaseConstPtr</span><span class="p">;</span>

      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Constructor. */</span>
      <span class="n">ConditionBase</span> <span class="p">()</span> <span class="o">:</span> <span class="n">capable_</span> <span class="p">(</span><span class="nb">true</span><span class="p">),</span> <span class="n">comparisons_</span> <span class="p">(),</span> <span class="n">conditions_</span> <span class="p">()</span>
      <span class="p">{</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Destructor. */</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">ConditionBase</span> <span class="p">()</span>
      <span class="p">{</span>
        <span class="c1">// comparisons are boost::shared_ptr.will take care of themselves</span>
        <span class="n">comparisons_</span><span class="p">.</span><span class="n">clear</span> <span class="p">();</span>

        <span class="c1">// conditions are boost::shared_ptr. will take care of themselves</span>
        <span class="n">conditions_</span><span class="p">.</span><span class="n">clear</span> <span class="p">();</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Add a new comparison</span>
<span class="cm">        * \param comparison the comparison operator to add</span>
<span class="cm">        */</span>
      <span class="kt">void</span>
      <span class="n">addComparison</span> <span class="p">(</span><span class="n">ComparisonBaseConstPtr</span> <span class="n">comparison</span><span class="p">);</span>

      <span class="cm">/** \brief Add a nested condition to this condition.</span>
<span class="cm">        * \param condition the nested condition to be added</span>
<span class="cm">        */</span>
      <span class="kt">void</span>
      <span class="nf">addCondition</span> <span class="p">(</span><span class="n">Ptr</span> <span class="n">condition</span><span class="p">);</span>

      <span class="cm">/** \brief Check if evaluation requirements are met. */</span>
      <span class="kr">inline</span> <span class="kt">bool</span>
      <span class="nf">isCapable</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">capable_</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Determine if a point meets this condition.</span>
<span class="cm">        * \return whether the point meets this condition.</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">bool</span>
      <span class="nf">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief True if capable. */</span>
      <span class="kt">bool</span> <span class="n">capable_</span><span class="p">;</span>

      <span class="cm">/** \brief The collection of all comparisons that need to be verified. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ComparisonBaseConstPtr</span><span class="o">&gt;</span> <span class="n">comparisons_</span><span class="p">;</span>

      <span class="cm">/** \brief The collection of all conditions that need to be verified. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&gt;</span> <span class="n">conditions_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief AND condition. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">ConditionAnd</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">conditions_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">comparisons_</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ConditionAnd</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ConditionAnd</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Constructor. */</span>
      <span class="n">ConditionAnd</span> <span class="p">()</span> <span class="o">:</span>
        <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="p">()</span>
      <span class="p">{</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Determine if a point meets this condition.</span>
<span class="cm">        * \return whether the point meets this condition.</span>
<span class="cm">        *</span>
<span class="cm">        * The ConditionAnd evaluates to true when ALL</span>
<span class="cm">        * comparisons and nested conditions evaluate to true</span>
<span class="cm">        */</span>
      <span class="kt">bool</span>
      <span class="n">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief OR condition. */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">ConditionOr</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">conditions_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">comparisons_</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ConditionOr</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">ConditionOr</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Constructor. */</span>
      <span class="n">ConditionOr</span> <span class="p">()</span> <span class="o">:</span>
        <span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="p">()</span>
      <span class="p">{</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Determine if a point meets this condition.</span>
<span class="cm">        * \return whether the point meets this condition.</span>
<span class="cm">        *</span>
<span class="cm">        * The ConditionOr evaluates to true when ANY</span>
<span class="cm">        * comparisons or nested conditions evaluate to true</span>
<span class="cm">        */</span>
      <span class="kt">bool</span>
      <span class="n">evaluate</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////////////////////////////////////////////////////</span>
  <span class="cm">/** \brief @b ConditionalRemoval filters data that satisfies certain conditions.</span>
<span class="cm">    *</span>
<span class="cm">    * A ConditionalRemoval must be provided a condition. There are two types of</span>
<span class="cm">    * conditions: ConditionAnd and ConditionOr. Conditions require one or more</span>
<span class="cm">    * comparisons and/or other conditions. A comparison has a name, a</span>
<span class="cm">    * comparison operator, and a value.</span>
<span class="cm">    *</span>
<span class="cm">    * An ConditionAnd will evaluate to true when ALL of its encapsulated</span>
<span class="cm">    * comparisons and conditions are true.</span>
<span class="cm">    *</span>
<span class="cm">    * An ConditionOr will evaluate to true when ANY of its encapsulated</span>
<span class="cm">    * comparisons and conditions are true.</span>
<span class="cm">    *</span>
<span class="cm">    * Depending on the derived type of the comparison, the name can correspond</span>
<span class="cm">    * to a PointCloud field name, or a color component in rgb color space or</span>
<span class="cm">    * hsi color space.</span>
<span class="cm">    *</span>
<span class="cm">    * Here is an example usage:</span>
<span class="cm">    *  // Build the condition</span>
<span class="cm">    *  pcl::ConditionAnd&lt;PointT&gt;::Ptr range_cond (new pcl::ConditionAnd&lt;PointT&gt; ());</span>
<span class="cm">    *  range_cond-&gt;addComparison (pcl::FieldComparison&lt;PointT&gt;::Ptr (new pcl::FieldComparison&lt;PointT&gt;(&quot;z&quot;, pcl::ComparisonOps::LT, 2.0)));</span>
<span class="cm">    *  range_cond-&gt;addComparison (pcl::FieldComparison&lt;PointT&gt;::Ptr (new pcl::FieldComparison&lt;PointT&gt;(&quot;z&quot;, pcl::ComparisonOps::GT, 0.0)));</span>
<span class="cm">    *  // Build the filter</span>
<span class="cm">    *  pcl::ConditionalRemoval&lt;PointT&gt; range_filt;</span>
<span class="cm">    *  range_filt.setCondition (range_cond);</span>
<span class="cm">    *  range_filt.setKeepOrganized (false);</span>
<span class="cm">    *</span>
<span class="cm">    * \author Louis LeGrand, Intel Labs Seattle</span>
<span class="cm">    * \ingroup filters</span>
<span class="cm">    */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">ConditionalRemoval</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">using</span> <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">filter_name_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">getClassName</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">removed_indices_</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">extract_removed_indices_</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">PointCloud</span> <span class="n">PointCloud</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">PointCloud</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">PointCloudPtr</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">PointCloud</span><span class="o">::</span><span class="n">ConstPtr</span> <span class="n">PointCloudConstPtr</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ConditionBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="n">ConditionBase</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ConditionBase</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">ConditionBasePtr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ConditionBase</span><span class="o">::</span><span class="n">ConstPtr</span> <span class="n">ConditionBaseConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief the default constructor.</span>
<span class="cm">        *</span>
<span class="cm">        * All ConditionalRemovals require a condition which can be set</span>
<span class="cm">        * using the setCondition method</span>
<span class="cm">        * \param extract_removed_indices extract filtered indices from indices vector</span>
<span class="cm">        */</span>
      <span class="n">ConditionalRemoval</span> <span class="p">(</span><span class="kt">int</span> <span class="n">extract_removed_indices</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">Filter</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Filter</span> <span class="p">(</span><span class="n">extract_removed_indices</span><span class="p">),</span> <span class="n">capable_</span> <span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">keep_organized_</span> <span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">condition_</span> <span class="p">(),</span>
        <span class="n">user_filter_value_</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">quiet_NaN</span> <span class="p">())</span>
      <span class="p">{</span>
        <span class="n">filter_name_</span> <span class="o">=</span> <span class="s">&quot;ConditionalRemoval&quot;</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Set whether the filtered points should be kept and set to the</span>
<span class="cm">        * value given through \a setUserFilterValue (default: NaN), or removed</span>
<span class="cm">        * from the PointCloud, thus potentially breaking its organized</span>
<span class="cm">        * structure. By default, points are removed.</span>
<span class="cm">        *</span>
<span class="cm">        * \param val set to true whether the filtered points should be kept and</span>
<span class="cm">        * set to a given user value (default: NaN)</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">setKeepOrganized</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">val</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">keep_organized_</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kr">inline</span> <span class="kt">bool</span>
      <span class="n">getKeepOrganized</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">keep_organized_</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Provide a value that the filtered points should be set to</span>
<span class="cm">        * instead of removing them.  Used in conjunction with \a</span>
<span class="cm">        * setKeepOrganized ().</span>
<span class="cm">        * \param val the user given value that the filtered point dimensions should be set to</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">setUserFilterValue</span> <span class="p">(</span><span class="kt">float</span> <span class="n">val</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">user_filter_value_</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Set the condition that the filter will use.</span>
<span class="cm">        * \param condition each point must satisfy this condition to avoid</span>
<span class="cm">        * being removed by the filter</span>
<span class="cm">        *</span>
<span class="cm">        * All ConditionalRemovals require a condition</span>
<span class="cm">        */</span>
      <span class="kt">void</span>
      <span class="n">setCondition</span> <span class="p">(</span><span class="n">ConditionBasePtr</span> <span class="n">condition</span><span class="p">);</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief Filter a Point Cloud.</span>
<span class="cm">        * \param output the resultant point cloud message</span>
<span class="cm">        */</span>
      <span class="kt">void</span>
      <span class="n">applyFilter</span> <span class="p">(</span><span class="n">PointCloud</span> <span class="o">&amp;</span><span class="n">output</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

      <span class="cm">/** \brief True if capable. */</span>
      <span class="kt">bool</span> <span class="n">capable_</span><span class="p">;</span>

      <span class="cm">/** \brief Keep the structure of the data organized, by setting the</span>
<span class="cm">        * filtered points to the a user given value (NaN by default).</span>
<span class="cm">        */</span>
      <span class="kt">bool</span> <span class="n">keep_organized_</span><span class="p">;</span>

      <span class="cm">/** \brief The condition to use for filtering */</span>
      <span class="n">ConditionBasePtr</span> <span class="n">condition_</span><span class="p">;</span>

      <span class="cm">/** \brief User given value to be set to any filtered point. Casted to</span>
<span class="cm">        * the correct field type.</span>
<span class="cm">        */</span>
      <span class="kt">float</span> <span class="n">user_filter_value_</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#ifdef PCL_NO_PRECOMPILE</span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/impl/conditional_removal.hpp&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_filters_impl_conditional_removal.hpp.html" class="btn btn-neutral float-right" title="File conditional_removal.hpp" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_filters_conditional_removal.h.html" class="btn btn-neutral float-left" title="File conditional_removal.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>