

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_xform.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_zlib.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_zlib.h.html" />
    <link rel="prev" title="File opennurbs_xform.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_xform.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_xform.h.html">File opennurbs_xform.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_xform.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_xform.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-xform-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-xform-h"></span><h1>Program Listing for File opennurbs_xform.h<a class="headerlink" href="#program-listing-for-file-opennurbs-xform-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_xform.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-xform-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_xform.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">//   defines ON_Xform (4 x 4 transformation matrix)</span>
<span class="c1">//</span>
<span class="c1">////////////////////////////////////////////////////////////////</span>

<span class="cp">#if !defined(ON_XFORM_INC_)</span>
<span class="cp">#define ON_XFORM_INC_</span>

<span class="k">class</span> <span class="nc">ON_Matrix</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_Xform</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">m_xform</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// [i][j] = row i, column j.  I.e.,</span>
                        <span class="c1">//</span>
                        <span class="c1">//           [0][0] [0][1] [0][2] [0][3]</span>
                        <span class="c1">//           [1][0] [1][1] [1][2] [1][3]</span>
                        <span class="c1">//           [2][0] [2][1] [2][2] [2][3]</span>
                        <span class="c1">//           [3][0] [3][1] [3][2] [3][3]</span>

  <span class="c1">// use implicit destructor, copy constructor</span>
  <span class="n">ON_Xform</span><span class="p">();</span>                     <span class="c1">// zero matrix</span>

  <span class="n">ON_Xform</span><span class="p">(</span> <span class="kt">int</span> <span class="p">);</span>                <span class="c1">// diagonal matrix (d,d,d,1)</span>
  <span class="n">ON_Xform</span><span class="p">(</span> <span class="kt">double</span> <span class="p">);</span>             <span class="c1">// diagonal matrix (d,d,d,1)</span>

<span class="cp">#if defined(ON_COMPILER_MSC)</span>
  <span class="c1">// Microsoft&#39;s compiler won&#39;t pass double m[4][4] as a const double[4][4] arg.</span>
  <span class="c1">// Gnu&#39;s compiler handles this.</span>
  <span class="n">ON_Xform</span><span class="p">(</span> <span class="kt">double</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">);</span>       <span class="c1">// from standard double m[4][4]</span>
  <span class="n">ON_Xform</span><span class="p">(</span> <span class="kt">float</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">);</span>        <span class="c1">// from standard float m[4][4]</span>
<span class="cp">#endif</span>

  <span class="n">ON_Xform</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">);</span> <span class="c1">// from standard double m[4][4]</span>
  <span class="n">ON_Xform</span><span class="p">(</span> <span class="k">const</span> <span class="kt">float</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="p">);</span>  <span class="c1">// from standard float m[4][4]</span>

  <span class="n">ON_Xform</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="p">);</span>      <span class="c1">// from array of 16 doubles (row0,row1,row2,row3)</span>
  <span class="n">ON_Xform</span><span class="p">(</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="p">);</span>       <span class="c1">// from array of 16 floats (row0,row1,row2,row3)</span>

  <span class="n">ON_Xform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// from upper left 4x4 of an</span>
                                    <span class="c1">// arbitrary matrix.  Any missing</span>
                                    <span class="c1">// rows/columns are set to identity.</span>
  <span class="n">ON_Xform</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span> <span class="c1">// as a frame.</span>
            <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z</span><span class="p">);</span>

  <span class="c1">// use implicit operator=(const ON_3dVector&amp;), operator==</span>

  <span class="kt">double</span><span class="o">*</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// xform = scalar results in a diagonal 3x3 with bottom row = 0,0,0,1</span>
  <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="kt">int</span> <span class="p">);</span>
  <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="kt">float</span> <span class="p">);</span>
  <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="kt">double</span> <span class="p">);</span>
  <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// from upper left 4x4 of an</span>
                                               <span class="c1">// arbitrary matrix.  Any missing</span>
                                               <span class="c1">// rows/columns are set to identity.</span>

  <span class="c1">// All non-commutative operations have &quot;this&quot; as left hand side and</span>
  <span class="c1">// argument as right hand side.</span>
  <span class="n">ON_2dPoint</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_2dPoint</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_3dPoint</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_4dPoint</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_4dPoint</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_2dVector</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_2dVector</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_3dVector</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_Xform</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="cm">/*rhs*/</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_Xform</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_Xform</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="cm">/*rhs*/</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Test the entries of the transformation matrix</span>
<span class="cm">    to see if they are valid number.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if ON_IsValid() is true for every number</span>
<span class="cm">    in the transformation matrix.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if matrix is the identity transformation</span>

<span class="cm">          1 0 0 0</span>
<span class="cm">          0 1 0 0</span>
<span class="cm">          0 0 1 0</span>
<span class="cm">          0 0 0 1</span>
<span class="cm">  Remarks:</span>
<span class="cm">    An element of the matrix is &quot;zero&quot; if fabs(x) &lt;= zero_tolerance.</span>
<span class="cm">    An element of the matrix is &quot;one&quot; if fabs(1.0-x) &lt;= zero_tolerance.</span>
<span class="cm">    If the matrix contains a nan, false is returned.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsIdentity</span><span class="p">(</span> <span class="kt">double</span> <span class="n">zero_tolerance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if the matrix is valid and is not the identity transformation</span>
<span class="cm">  Remarks:</span>
<span class="cm">    An element of the matrix is &quot;zero&quot; if fabs(x) &lt;= zero_tolerance.</span>
<span class="cm">    An element of the matrix is &quot;one&quot; if fabs(1.0-x) &lt;= zero_tolerance.</span>
<span class="cm">    If the matrix contains a nan, false is returned.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsNotIdentity</span><span class="p">(</span> <span class="kt">double</span> <span class="n">zero_tolerance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if matrix is a pure translation</span>

<span class="cm">          1 0 0 dx</span>
<span class="cm">          0 1 0 dy</span>
<span class="cm">          0 0 1 dz</span>
<span class="cm">          0 0 0 1</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The test for zero is fabs(x) &lt;= zero_tolerance.</span>
<span class="cm">    The test for one is fabs(x-1) &lt;= zero_tolerance.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsTranslation</span><span class="p">(</span> <span class="kt">double</span> <span class="n">zero_tolerance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if matrix is the zero transformation</span>

<span class="cm">          0 0 0 0</span>
<span class="cm">          0 0 0 0</span>
<span class="cm">          0 0 0 0</span>
<span class="cm">          0 0 0 *</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsZero</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    A similarity transformation can be broken into a sequence</span>
<span class="cm">    of dialations, translations, rotations, and reflections.</span>
<span class="cm">  Returns:</span>
<span class="cm">    +1: This transformation is an orientation preserving similarity.</span>
<span class="cm">    -1: This transformation is an orientation reversing similarity.</span>
<span class="cm">     0: This transformation is not a similarity.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">IsSimilarity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>


  <span class="kt">int</span> <span class="nf">Compare</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">// matrix operations</span>
  <span class="kt">void</span> <span class="nf">Transpose</span><span class="p">();</span> <span class="c1">// transposes 4x4 matrix</span>

  <span class="kt">int</span>
  <span class="nf">Rank</span><span class="p">(</span> <span class="c1">// returns 0 to 4</span>
    <span class="kt">double</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="c1">// If not NULL, returns minimum pivot</span>
  <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">double</span>
  <span class="nf">Determinant</span><span class="p">(</span> <span class="c1">// returns determinant of 4x4 matrix</span>
    <span class="kt">double</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="c1">// If not NULL, returns minimum pivot</span>
  <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span>
  <span class="nf">Invert</span><span class="p">(</span> <span class="c1">// If matrix is non-singular, returns true,</span>
          <span class="c1">// otherwise returns false and sets matrix to</span>
          <span class="c1">// pseudo inverse.</span>
    <span class="kt">double</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="c1">// If not NULL, returns minimum pivot</span>
  <span class="p">);</span>

  <span class="n">ON_Xform</span>
  <span class="nf">Inverse</span><span class="p">(</span>  <span class="c1">// If matrix is non-singular, returns inverse,</span>
            <span class="c1">// otherwise returns pseudo inverse.</span>
    <span class="kt">double</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="c1">// If not NULL, returns minimum pivot</span>
  <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    When transforming 3d point and surface or mesh normals</span>
<span class="cm">    two different transforms must be used.</span>
<span class="cm">    If P_xform transforms the point, then the inverse</span>
<span class="cm">    transpose of P_xform must be used to tranform normal</span>
<span class="cm">    vectors.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    N_xform - [out]</span>
<span class="cm">  Returns:</span>
<span class="cm">    The determinant of the transformation.</span>
<span class="cm">    If non-zero, &quot;this&quot; is invertable and N_xform can be calculated.</span>
<span class="cm">    False if &quot;this&quot; is not invertable, in which case</span>
<span class="cm">    the returned N_xform = this with the right hand column</span>
<span class="cm">    and bottom row zeroed out.</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">GetSurfaceNormalXform</span><span class="p">(</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">N_xform</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If a texture mapping is applied to an object, the object</span>
<span class="cm">    is subsequently transformed by T, and the texture mapping</span>
<span class="cm">    needs to be recalculated, then two transforms are required</span>
<span class="cm">    to recalcalculate the texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P_xform - [out]</span>
<span class="cm">      Transform to apply to points before applying the</span>
<span class="cm">      texture mapping transformation.</span>
<span class="cm">    N_xform - [out]</span>
<span class="cm">      Transform to apply to surface normals before applying</span>
<span class="cm">      the texture mapping transformation.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The determinant of the &quot;this&quot; transformation.</span>
<span class="cm">    If non-zero, &quot;this&quot; is invertable and P_xform and N_xform</span>
<span class="cm">    were calculated.</span>
<span class="cm">    False if &quot;this&quot; is not invertable, in which case</span>
<span class="cm">    the returned P_xform and N_xform are the identity.</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">GetMappingXforms</span><span class="p">(</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">P_xform</span><span class="p">,</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">N_xform</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Computes matrix * transpose([x,y,z,w]).</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   x - [in]</span>
  <span class="c1">//   y - [in]</span>
  <span class="c1">//   z - [in]</span>
  <span class="c1">//   z - [in]</span>
  <span class="c1">//   ans - [out] = matrix * transpose([x,y,z,w])</span>
  <span class="kt">void</span> <span class="nf">ActOnLeft</span><span class="p">(</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// x</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// y</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// z</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// w</span>
         <span class="kt">double</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="c1">// ans</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Computes [x,y,z,w] * matrix.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   x - [in]</span>
  <span class="c1">//   y - [in]</span>
  <span class="c1">//   z - [in]</span>
  <span class="c1">//   z - [in]</span>
  <span class="c1">//   ans - [out] = [x,y,z,w] * matrix</span>
  <span class="kt">void</span> <span class="nf">ActOnRight</span><span class="p">(</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// x</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// y</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// z</span>
         <span class="kt">double</span><span class="p">,</span> <span class="c1">// w</span>
         <span class="kt">double</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="c1">// ans</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">////////////////////////////////////////////////////////////////</span>
  <span class="c1">// standard transformations</span>

  <span class="c1">// All zeros including the bottom row.</span>
  <span class="kt">void</span> <span class="nf">Zero</span><span class="p">();</span>

  <span class="c1">// diagonal is (1,1,1,1)</span>
  <span class="kt">void</span> <span class="nf">Identity</span><span class="p">();</span>

  <span class="c1">// diagonal 3x3 with bottom row = 0,0,0,1</span>
  <span class="kt">void</span> <span class="nf">Diagonal</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create non-uniform scale transformation with the origin as</span>
<span class="cm">    a fixed point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fixed_point - [in]</span>
<span class="cm">    x_scale_factor - [in]</span>
<span class="cm">    y_scale_factor - [in]</span>
<span class="cm">    z_scale_factor - [in]</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The diagonal is (x_scale_factor, y_scale_factor, z_scale_factor, 1)</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Scale</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">x_scale_factor</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">y_scale_factor</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">z_scale_factor</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create non-uniform scale transformation with the origin as</span>
<span class="cm">    a fixed point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fixed_point - [in]</span>
<span class="cm">    scale_vector - [in]</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The diagonal is (scale_vector.x, scale_vector.y, scale_vector.z, 1)</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Scale</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">scale_vector</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create uniform scale transformation with a specified</span>
<span class="cm">    fixed point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    fixed_point - [in]</span>
<span class="cm">    scale_factor - [in]</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Scale</span>
    <span class="p">(</span>
    <span class="n">ON_3dPoint</span> <span class="n">fixed_point</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">scale_factor</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create non-uniform scale transformation with a specified</span>
<span class="cm">    fixed point.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plane - [in] plane.origin is the fixed point</span>
<span class="cm">    x_scale_factor - [in] plane.xaxis scale factor</span>
<span class="cm">    y_scale_factor - [in] plane.yaxis scale factor</span>
<span class="cm">    z_scale_factor - [in] plane.zaxis scale factor</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Scale</span>
    <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">x_scale_factor</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">y_scale_factor</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">z_scale_factor</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create shear transformation.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plane - [in] plane.origin is the fixed point</span>
<span class="cm">    x1 - [in] plane.xaxis scale factor</span>
<span class="cm">    y1 - [in] plane.yaxis scale factor</span>
<span class="cm">    z1 - [in] plane.zaxis scale factor</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Shear</span>
    <span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">y1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">z1</span>
    <span class="p">);</span>

  <span class="c1">// Right column is (d.x, d.y,d.z, 1).</span>
  <span class="kt">void</span> <span class="nf">Translation</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="c1">// d</span>
    <span class="p">);</span>

  <span class="c1">// Right column is (dx, dy, dz, 1).</span>
  <span class="kt">void</span> <span class="nf">Translation</span><span class="p">(</span>
    <span class="kt">double</span><span class="p">,</span> <span class="c1">// dx</span>
    <span class="kt">double</span><span class="p">,</span> <span class="c1">// dy</span>
    <span class="kt">double</span>  <span class="c1">// dz</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Get transformation that projects to a plane</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   plane - [in] plane to project to</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   This transformaton maps a 3d point P to the</span>
  <span class="c1">//   point plane.ClosestPointTo(Q).</span>
  <span class="kt">void</span> <span class="nf">PlanarProjection</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   The Rotation() function is overloaded and provides several</span>
  <span class="c1">//   ways to compute a rotation transformation.  A positive</span>
  <span class="c1">//   rotation angle indicates a counter-clockwise (right hand rule)</span>
  <span class="c1">//   rotation about the axis of rotation.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   sin_angle - sin(rotation angle)</span>
  <span class="c1">//   cos_angle - cos(rotation angle)</span>
  <span class="c1">//   rotation_axis - 3d unit axis of rotation</span>
  <span class="c1">//   rotation_center - 3d center of rotation</span>
  <span class="c1">//</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   In the overloads that take frames, the frames should</span>
  <span class="c1">//   be right hand orthonormal frames</span>
  <span class="c1">//   (unit vectors with Z = X x Y).</span>
  <span class="c1">//   The resulting rotation fixes</span>
  <span class="c1">//   the origin (0,0,0), maps initial X to</span>
  <span class="c1">//   final X, initial Y to final Y, and initial Z to final Z.</span>
  <span class="c1">//</span>
  <span class="c1">//   In the overload that takes frames with center points,</span>
  <span class="c1">//   if the initial and final center are equal, then that</span>
  <span class="c1">//   center point is the fixed point of the rotation.  If</span>
  <span class="c1">//   the initial and final point differ, then the resulting</span>
  <span class="c1">//   transform is the composition of a rotation fixing P0</span>
  <span class="c1">//   and translation from P0 to P1.  The resulting</span>
  <span class="c1">//   transformation maps P0 to P1, P0+X0 to P1+X1, ...</span>
  <span class="c1">//</span>
  <span class="c1">//   The rotation transformations that map frames to frames</span>
  <span class="c1">//   are not the same as the change of basis transformations</span>
  <span class="c1">//   for those frames.  See ON_Xform::ChangeBasis().</span>
  <span class="c1">//</span>
  <span class="kt">void</span> <span class="nf">Rotation</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">sin_angle</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">cos_angle</span><span class="p">,</span>
    <span class="n">ON_3dVector</span> <span class="n">rotation_axis</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span> <span class="n">rotation_center</span>
    <span class="p">);</span>

  <span class="c1">// Parameters:</span>
  <span class="c1">//   angle - rotation angle in radians</span>
  <span class="c1">//   rotation_axis - 3d unit axis of rotation</span>
  <span class="c1">//   rotation_center - 3d center of rotation</span>
  <span class="kt">void</span> <span class="nf">Rotation</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">angle_radians</span><span class="p">,</span>
    <span class="n">ON_3dVector</span> <span class="n">rotation_axis</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span> <span class="n">rotation_center</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calculate the minimal transformation that rotates</span>
<span class="cm">    start_dir to end_dir while fixing rotation_center.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Rotation</span><span class="p">(</span>
    <span class="n">ON_3dVector</span> <span class="n">start_dir</span><span class="p">,</span>
    <span class="n">ON_3dVector</span> <span class="n">end_dir</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span> <span class="n">rotation_center</span>
    <span class="p">);</span>

  <span class="c1">// Parameters:</span>
  <span class="c1">//   X0 - initial frame X</span>
  <span class="c1">//   Y0 - initial frame Y</span>
  <span class="c1">//   Z0 - initial frame Z</span>
  <span class="c1">//   X1 - final frame X</span>
  <span class="c1">//   Y1 - final frame Y</span>
  <span class="c1">//   Z1 - final frame Z</span>
  <span class="c1">//</span>
  <span class="kt">void</span> <span class="nf">Rotation</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z1</span>
    <span class="p">);</span>

  <span class="c1">// Parameters:</span>
  <span class="c1">//   P0 - initial frame center</span>
  <span class="c1">//   X0 - initial frame X</span>
  <span class="c1">//   Y0 - initial frame Y</span>
  <span class="c1">//   Z0 - initial frame Z</span>
  <span class="c1">//   P1 - initial frame center</span>
  <span class="c1">//   X1 - final frame X</span>
  <span class="c1">//   Y1 - final frame Y</span>
  <span class="c1">//   Z1 - final frame Z</span>
  <span class="kt">void</span> <span class="nf">Rotation</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z1</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create rotation transformation that maps plane0 to plane1.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plane0 - [in]</span>
<span class="cm">    plane1 - [in]</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Rotation</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane1</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create mirror transformation matrix.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    point_on_mirror_plane - [in] point on mirror plane</span>
<span class="cm">    normal_to_mirror_plane - [in] normal to mirror plane</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The mirror transform maps a point Q to</span>
<span class="cm">    Q - (2*(Q-P)oN)*N, where</span>
<span class="cm">    P = point_on_mirror_plane and N = normal_to_mirror_plane.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Mirror</span><span class="p">(</span>
    <span class="n">ON_3dPoint</span> <span class="n">point_on_mirror_plane</span><span class="p">,</span>
    <span class="n">ON_3dVector</span> <span class="n">normal_to_mirror_plane</span>
    <span class="p">);</span>

  <span class="c1">// Description: The ChangeBasis() function is overloaded</span>
  <span class="c1">//   and provides several</span>
  <span class="c1">//   ways to compute a change of basis transformation.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   plane0 - inital plane</span>
  <span class="c1">//   plane1 - final plane</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   @untitled table</span>
  <span class="c1">//   true    success</span>
  <span class="c1">//   false   vectors for initial frame are not a basis</span>
  <span class="c1">//</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   If you have points defined with respect to planes, the</span>
  <span class="c1">//   version of ChangeBasis() that takes two planes computes</span>
  <span class="c1">//   the transformation to change coordinates from one plane to</span>
  <span class="c1">//   another.  The predefined world plane ON_world_plane can</span>
  <span class="c1">//   be used as an argument.</span>
  <span class="c1">//</span>
  <span class="c1">//   If P = plane0.Evaluate( a0,b0,c0 ) and</span>
  <span class="c1">//</span>
  <span class="c1">//   (a1,b1,c1) = ChangeBasis(plane0,plane1)*ON_3dPoint(a0,b0,c0),</span>
  <span class="c1">//</span>
  <span class="c1">//   then P = plane1.Evaluate( a1, b1, c1 )</span>
  <span class="c1">//</span>
  <span class="c1">//   The version of ChangeBasis() that takes six vectors</span>
  <span class="c1">//   maps (a0,b0,c0) to (a1,b1,c1) where</span>
  <span class="c1">//   a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1</span>
  <span class="c1">//</span>
  <span class="c1">//   The version of ChangeBasis() that takes six vectors</span>
  <span class="c1">//   with center points</span>
  <span class="c1">//   maps (a0,b0,c0) to (a1,b1,c1) where</span>
  <span class="c1">//   P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1</span>
  <span class="c1">//</span>
  <span class="c1">//   The change of basis transformation is not the same as</span>
  <span class="c1">//   the rotation transformation that rotates one orthonormal</span>
  <span class="c1">//   frame to another.  See ON_Xform::Rotation().</span>
  <span class="kt">bool</span> <span class="nf">ChangeBasis</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane1</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Get a change of basis transformation.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   X0 - initial basis X (X0,Y0,Z0 can be any 3d basis)</span>
  <span class="c1">//   Y0 - initial basis Y</span>
  <span class="c1">//   Z0 - initial basis Z</span>
  <span class="c1">//   X1 - final basis X (X1,Y1,Z1 can be any 3d basis)</span>
  <span class="c1">//   Y1 - final basis Y</span>
  <span class="c1">//   Z1 - final basis Z</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   Change of basis transformations and rotation transformations</span>
  <span class="c1">//   are often confused.  This is a change of basis transformation.</span>
  <span class="c1">//   If Q = a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1</span>
  <span class="c1">//   then this transform will map the point (a0,b0,c0) to (a1,b1,c1)</span>
  <span class="kt">bool</span> <span class="nf">ChangeBasis</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z1</span>
    <span class="p">);</span>

  <span class="c1">// Parameters:</span>
  <span class="c1">//   P0 - initial center</span>
  <span class="c1">//   X0 - initial basis X (X0,Y0,Z0 can be any 3d basis)</span>
  <span class="c1">//   Y0 - initial basis Y</span>
  <span class="c1">//   Z0 - initial basis Z</span>
  <span class="c1">//   P1 - final center</span>
  <span class="c1">//   X1 - final basis X (X1,Y1,Z1 can be any 3d basis)</span>
  <span class="c1">//   Y1 - final basis Y</span>
  <span class="c1">//   Z1 - final basis Z</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   Change of basis transformations and rotation transformations</span>
  <span class="c1">//   are often confused.  This is a change of basis transformation.</span>
  <span class="c1">//   If Q = P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1</span>
  <span class="c1">//   then this transform will map the point (a0,b0,c0) to (a1,b1,c1)</span>
  <span class="kt">bool</span> <span class="nf">ChangeBasis</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">X1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Y1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">Z1</span>
    <span class="p">);</span>

  <span class="c1">// standard viewing transformations</span>
  <span class="kt">void</span> <span class="nf">WorldToCamera</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span><span class="p">,</span>  <span class="c1">// CameraLocation</span>
         <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="o">//</span> <span class="n">unit</span> <span class="n">CameraX</span> <span class="n">vector</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span>
         <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// unit CameraY vector (up)</span>
         <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span>  <span class="c1">// unit CameraZ vector (from screen to camera)</span>
         <span class="p">);</span>
  <span class="kt">void</span> <span class="nf">CameraToWorld</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span><span class="p">,</span>  <span class="c1">// CameraLocation</span>
         <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="o">//</span> <span class="n">unit</span> <span class="n">CameraX</span> <span class="n">vector</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span>
         <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// unit CameraY vector (up)</span>
         <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span>  <span class="c1">// unit CameraZ vector (from screen to camera)</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">CameraToClip</span><span class="p">(</span> <span class="c1">// maps viewport frustum to -1 &lt;= x,y,z &lt;= 1 box</span>
      <span class="n">ON_BOOL32</span><span class="p">,</span> <span class="c1">// true for perspective, false for orthographic</span>
      <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="o">//</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">right</span> <span class="p">(</span><span class="n">usually</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">)</span>
      <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="c1">// bottom != top (usually bottom &lt; top )</span>
      <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span>  <span class="c1">// near != far (usually 0 &lt; near &lt; far )</span>
      <span class="p">);</span>

  <span class="c1">// maps -1 &lt;= x,y,z &lt;= 1 box to viewport frustum</span>
  <span class="kt">bool</span> <span class="nf">ClipToCamera</span><span class="p">(</span>
      <span class="kt">int</span><span class="p">,</span> <span class="c1">// true for perspective, false for orthographic</span>
      <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="o">//</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">right</span> <span class="p">(</span><span class="n">usually</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="p">)</span>
      <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="c1">// bottom != top (usually bottom &lt; top )</span>
      <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span>  <span class="c1">// near != far an bot are non-zero (usually 0 &lt; near &lt; far )</span>
      <span class="p">);</span>

  <span class="c1">// Computes transform that maps the clipping box</span>
  <span class="c1">//</span>
  <span class="c1">//           -1&lt;x&lt;1,-1&lt;y&lt;1,-1&lt;z&lt;1</span>
  <span class="c1">//</span>
  <span class="c1">// to the screen box</span>
  <span class="c1">//</span>
  <span class="c1">//          (left,right) X (bottom,top) X (near,far)</span>
  <span class="kt">bool</span> <span class="nf">ClipToScreen</span><span class="p">(</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// left</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// right</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// bottom</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// top</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// near_z</span>
      <span class="kt">double</span>  <span class="c1">// far_z</span>
      <span class="p">);</span>

  <span class="c1">// Computes transform that maps the screen box</span>
  <span class="c1">//</span>
  <span class="c1">//          (left,right) X (bottom,top) X (near,far)</span>
  <span class="c1">//</span>
  <span class="c1">// to the clipping box</span>
  <span class="c1">//</span>
  <span class="c1">//           -1&lt;x&lt;1,-1&lt;y&lt;1,-1&lt;z&lt;1</span>
  <span class="kt">bool</span> <span class="nf">ScreenToClip</span><span class="p">(</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// left</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// right</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// bottom</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// top</span>
      <span class="kt">double</span><span class="p">,</span> <span class="c1">// near_z</span>
      <span class="kt">double</span>  <span class="c1">// far_z</span>
      <span class="p">);</span>

  <span class="c1">// Description: Computes homogeneous point clipping flags and</span>
  <span class="c1">//   returns an int with bits set to indicate if the point</span>
  <span class="c1">//   is outside of the clipping box.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   point - [in] 4d homogeneous clipping coordinate point</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//  @table</span>
  <span class="c1">//   bit      point location</span>
  <span class="c1">//   1        x/w &lt; -1</span>
  <span class="c1">//   2        x/w &gt; +1</span>
  <span class="c1">//   4        y/w &lt; -1</span>
  <span class="c1">//   8        y/w &gt; +1</span>
  <span class="c1">//   16       z/w &lt; -1</span>
  <span class="c1">//   32       z/w &gt; +1</span>
  <span class="c1">//</span>
  <span class="kt">int</span> <span class="nf">ClipFlag4d</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="c1">// point</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Parameters:</span>
  <span class="c1">//   count - [in] number of 4d points</span>
  <span class="c1">//   stride - [in] (&gt;=4)</span>
  <span class="c1">//   points - [in] 4d clipping coordinate points</span>
  <span class="c1">//            (array of stride*count doubles)</span>
  <span class="c1">//   bTestZ - [in] (default=true) if false, do not test &quot;z&quot; coordinate</span>
  <span class="c1">//</span>
  <span class="kt">int</span> <span class="nf">ClipFlag4d</span><span class="p">(</span>
    <span class="kt">int</span><span class="p">,</span> <span class="c1">// count</span>
    <span class="kt">int</span><span class="p">,</span> <span class="c1">// stride</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// points</span>
    <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">true</span> <span class="c1">// bTeztZ</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Computes 3d point clipping flags and</span>
  <span class="c1">//   returns an int with bits set to indicate if the point</span>
  <span class="c1">//   is outside of the clipping box.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   point - [in] 3d clipping coordinate point</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//  @table</span>
  <span class="c1">//   bit      point location</span>
  <span class="c1">//   1        x &lt; -1</span>
  <span class="c1">//   2        x &gt; +1</span>
  <span class="c1">//   4        y &lt; -1</span>
  <span class="c1">//   8        y &gt; +1</span>
  <span class="c1">//   16       z &lt; -1</span>
  <span class="c1">//   32       z &gt; +1</span>
  <span class="kt">int</span> <span class="nf">ClipFlag3d</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="c1">// point</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Parameters:</span>
  <span class="c1">//   count - [in] number of 3d points</span>
  <span class="c1">//   stride - [in] (&gt;=3)</span>
  <span class="c1">//   points - [in] 3d clipping coordinate points (array of stride*count doubles)</span>
  <span class="c1">//   bTestZ - [in] (default=true) if false, do not test &quot;z&quot; coordinate</span>
  <span class="c1">//</span>
  <span class="kt">int</span> <span class="nf">ClipFlag3d</span><span class="p">(</span>
    <span class="kt">int</span><span class="p">,</span> <span class="c1">// count</span>
    <span class="kt">int</span><span class="p">,</span> <span class="c1">// stride</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// points</span>
    <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">true</span> <span class="c1">// bTestZ</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description: Computes 3d clipping flags for a 3d bounding</span>
  <span class="c1">//   box and returns an int with bits set to indicate if</span>
  <span class="c1">//   the bounding box is outside of the clipping box.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   boxmin - [in] 3d boxmin corner</span>
  <span class="c1">//   boxmax - [in] 3d boxmax corner</span>
  <span class="c1">//</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//  @table</span>
  <span class="c1">//   bit      box location</span>
  <span class="c1">//   1        boxmax x &lt; -1</span>
  <span class="c1">//   2        boxmin x &gt; +1</span>
  <span class="c1">//   4        boxmax y &lt; -1</span>
  <span class="c1">//   8        boxmin y &gt; +1</span>
  <span class="c1">//   16       boxmax z &lt; -1</span>
  <span class="c1">//   32       boxmin z &gt; +1</span>
  <span class="kt">int</span> <span class="nf">ClipFlag3dBox</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// boxmin</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span>  <span class="c1">// boxmax</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calculates the transformation that linearly maps</span>
<span class="cm">    old_interval to new_interval.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dir - [in] 0 = x, 1 = y, 2= z;</span>
<span class="cm">    old_interval - [in]</span>
<span class="cm">    new_interval - [in]</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IntervalChange</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span>
    <span class="n">ON_Interval</span> <span class="n">old_interval</span><span class="p">,</span>
    <span class="n">ON_Interval</span> <span class="n">new_interval</span>
    <span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClippingRegion</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_ClippingRegion</span><span class="p">();</span>

  <span class="c1">// The transformation m_xform transforms the view frustum,</span>
  <span class="c1">// in object coordinates to the (-1,+1)^3 clipping</span>
  <span class="c1">// coordinate box.</span>
  <span class="n">ON_Xform</span> <span class="n">m_xform</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    clip_plane_tolerance - [in]</span>
<span class="cm">      3d world coordinates tolerance to use when testing</span>
<span class="cm">      objects to see if the planes in m_clip_plane[] hide</span>
<span class="cm">      the objects.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The constructor sets this value to zero.  Rhino uses</span>
<span class="cm">    values around 1e-5.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetClipPlaneTolerance</span><span class="p">(</span> <span class="kt">double</span> <span class="n">clip_plane_tolerance</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    3d world coordinates tolerance to use when testing</span>
<span class="cm">    objects to see if the planes in m_clip_plane[] hide</span>
<span class="cm">    the objects.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The constructor sets this value to zero.  Rhino uses</span>
<span class="cm">    values around 1e-5.</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">ClipPlaneTolerance</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">enum</span>
  <span class="p">{</span>
    <span class="n">max_clip_plane_count</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="c1">// must be &lt;= 25</span>
    <span class="n">frustum_bitmask</span>      <span class="o">=</span> <span class="mh">0x0000003F</span><span class="p">,</span>
    <span class="n">near_plane_bitmask</span>   <span class="o">=</span> <span class="mh">0x00000020</span><span class="p">,</span>
    <span class="n">far_plane_bitmask</span>    <span class="o">=</span> <span class="mh">0x00000010</span><span class="p">,</span>
    <span class="n">clip_plane_bitmask</span>   <span class="o">=</span> <span class="mh">0x7FFFFFC0</span><span class="p">,</span>
    <span class="n">negw_bitmask</span>         <span class="o">=</span> <span class="mh">0x80000000</span>
  <span class="p">};</span>

  <span class="c1">// Up to 25 additional clipping planes in object coordinates.</span>
  <span class="c1">// The convex region that is the intersection of the positive</span>
  <span class="c1">// side of these planes is the active region.</span>
  <span class="kt">int</span> <span class="n">m_clip_plane_count</span><span class="p">;</span> <span class="c1">// (0 &lt;= m_clip_plane_count &lt;= max_clip_plane_count)</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// The &quot;float&quot; should be a double, but that can&#39;t happen</span>
  <span class="c1">// until V6 because it will brake the SDK.  Use the</span>
  <span class="c1">// SetClipPlaneTolerance() and ClipPlaneTolerance()</span>
  <span class="c1">// functions to set and get this value.</span>
  <span class="kt">float</span> <span class="n">m_clip_plane_tolerance</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_PlaneEquation</span> <span class="n">m_clip_plane</span><span class="p">[</span><span class="n">max_clip_plane_count</span><span class="p">];</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    The &quot;view frustum&quot; is the frustum the m_xform transformation</span>
<span class="cm">    maps to clipping coordinate box (-1,+1)^3.  These functions</span>
<span class="cm">    determine if some portion of the convex hull of the test points</span>
<span class="cm">    is inside the view frustum.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] point</span>
<span class="cm">    box - [in] bounding box</span>
<span class="cm">    count - [in] number of points</span>
<span class="cm">    p - [in] array of points</span>
<span class="cm">    bEnableClippingPlanes - [in]</span>
<span class="cm">      If true, then the additional clipping planes are tested.</span>
<span class="cm">      If false, then the additional clipping planes are ignored.</span>
<span class="cm">  Returns:</span>
<span class="cm">    0 = No part of the of the convex hull of the tested points</span>
<span class="cm">        is in the view frustum.</span>
<span class="cm">    1 = A portion of the convex hull of the otested points may</span>
<span class="cm">        be in the view frustum.</span>
<span class="cm">    2 = The entire convex hull of the tested points is in the</span>
<span class="cm">        view frustum.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">InViewFrustum</span><span class="p">(</span>
    <span class="n">ON_3dPoint</span> <span class="n">P</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InViewFrustum</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">bbox</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InViewFrustum</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InViewFrustum</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InViewFrustum</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_4dPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    The &quot;clip plane region&quot; is the convex hull of the planes in</span>
<span class="cm">    the m_clip_plane[] array.  These functions determine if</span>
<span class="cm">    some portion of the convex hull of the test points is inside</span>
<span class="cm">    the clip plane region.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] point</span>
<span class="cm">    box - [in] bounding box</span>
<span class="cm">    count - [in] number of points</span>
<span class="cm">    p - [in] array of points</span>
<span class="cm">    bEnableClippingPlanes - [in]</span>
<span class="cm">      If true, then the additional clipping planes are tested.</span>
<span class="cm">      If false, then the additional clipping planes are ignored.</span>
<span class="cm">  Returns:</span>
<span class="cm">    0 = No part of the of the convex hull of the tested points</span>
<span class="cm">        is in the clip plane region.</span>
<span class="cm">    1 = A portion of the convex hull of the tested points may</span>
<span class="cm">        be in the clip plane region.</span>
<span class="cm">    2 = The entire convex hull of the tested points is in the</span>
<span class="cm">        clip plane region.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">InClipPlaneRegion</span><span class="p">(</span>
    <span class="n">ON_3dPoint</span> <span class="n">P</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InClipPlaneRegion</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">bbox</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InClipPlaneRegion</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InClipPlaneRegion</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">InClipPlaneRegion</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_4dPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    The &quot;visible area&quot; is the intersection of the view frustum,</span>
<span class="cm">    defined by m_xform, and the clipping region, defined by the</span>
<span class="cm">    m_clip_plane[] array.  These functions determing if some</span>
<span class="cm">    portion of the convex hull of the test points is visible.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] point</span>
<span class="cm">    box - [in] bounding box</span>
<span class="cm">    count - [in] number of points</span>
<span class="cm">    p - [in] array of points</span>
<span class="cm">  Returns:</span>
<span class="cm">    0 = no part of the object is in the region.</span>
<span class="cm">    1 = a portion of the object is in the region</span>
<span class="cm">    2 = entire object is in clipping region</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">IsVisible</span><span class="p">(</span>
    <span class="n">ON_3dPoint</span> <span class="n">P</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">IsVisible</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">bbox</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">IsVisible</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">IsVisible</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">IsVisible</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_4dPoint</span><span class="o">*</span> <span class="n">p</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Transform a list of 4d homogenous points while testing</span>
<span class="cm">    for visibility.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    count - [in] number of points</span>
<span class="cm">    p - [in/out] array of points to test and transform</span>
<span class="cm">          If 0 is returned, some of the points may not</span>
<span class="cm">          be transformed.  In all other cases, the output</span>
<span class="cm">          points are transformed by m_xform.</span>
<span class="cm">    pflags - [out]</span>
<span class="cm">          0 when the point is in the visible region.</span>
<span class="cm">          Otherwise the bits are set to indicate which planes clip the</span>
<span class="cm">          intput point.</span>
<span class="cm">          0x01 left of the view frusturm</span>
<span class="cm">          0x02 right of the view frustum</span>
<span class="cm">          0x04 below the view frustum</span>
<span class="cm">          0x08 above the view frustum</span>
<span class="cm">          0x10 behind the view frustum (too far)</span>
<span class="cm">          0x20 in front of the view frustum (too near)</span>

<span class="cm">          0x10 below m_clip_plane[0]</span>
<span class="cm">          0x20 below m_clip_plane[1]</span>
<span class="cm">          ...</span>
<span class="cm">          0x40000000 below m_clip_plane[24]</span>

<span class="cm">          0x80000000 transformation created a non-positive weight</span>
<span class="cm">  Returns:</span>
<span class="cm">    0 = convex hull of the points is not in the region.</span>
<span class="cm">        The m_cull_bits field reports which plane or planes</span>
<span class="cm">        culled the point set.</span>
<span class="cm">    1 = a portion of the convex hull is in the region.</span>
<span class="cm">        The m_cull_bits field reports which plane or planes</span>
<span class="cm">        culled the point set.</span>
<span class="cm">    2 = all points are in the region.</span>
<span class="cm">        The m_cull_bits field will be zero.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">TransformPoints</span><span class="p">(</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">ON_4dPoint</span><span class="o">*</span> <span class="n">p</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">TransformPoints</span><span class="p">(</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">ON_4dPoint</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pflags</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Transform a pont and return the clipping information.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] point ot transform</span>
<span class="cm">    Q - [out] transformed point</span>
<span class="cm">  Returns:</span>
<span class="cm">    0 when the point is in the visible region.</span>
<span class="cm">    Otherwise the bits are set to indicate which planes clip the</span>
<span class="cm">    intput point.</span>
<span class="cm">    0x01 left of the view frusturm</span>
<span class="cm">    0x02 right of the view frustum</span>
<span class="cm">    0x04 below the view frustum</span>
<span class="cm">    0x08 above the view frustum</span>
<span class="cm">    0x10 behind the view frustum (too far)</span>
<span class="cm">    0x20 in front of the view frustum (too near)</span>

<span class="cm">    0x10 below m_clip_plane[0]</span>
<span class="cm">    0x20 below m_clip_plane[1]</span>
<span class="cm">    ...</span>
<span class="cm">    0x40000000 below m_clip_plane[24]</span>

<span class="cm">    0x80000000 transformation created a non-positive weight</span>
<span class="cm">  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">TransformPoint</span><span class="p">(</span>
                     <span class="k">const</span> <span class="n">ON_4dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
                     <span class="n">ON_4dPoint</span><span class="o">&amp;</span> <span class="n">Q</span>
                     <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">TransformPoint</span><span class="p">(</span>
                     <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
                     <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">Q</span>
                     <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">TransformPoint</span><span class="p">(</span>
                     <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
                     <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">Q</span>
                     <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Calculate the interval for the segment of a line that</span>
<span class="cm">    is in the clip plane region.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P0 - [in] start point</span>
<span class="cm">    P1 - [in] end point</span>
<span class="cm">    t0 - [out] start parameter</span>
<span class="cm">    t1 - [out] end parameter</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if some portion of the line is visible and</span>
<span class="cm">    0.0 &lt;= *t0 &lt;= *t1 &lt;= 1.0.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetLineClipPlaneParamters</span><span class="p">(</span>
         <span class="n">ON_4dPoint</span> <span class="n">P0</span><span class="p">,</span>
         <span class="n">ON_4dPoint</span> <span class="n">P1</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">t0</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">t1</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">};</span>


<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_Localizer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_Localizer</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_Localizer</span><span class="p">();</span>

  <span class="n">ON_Localizer</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Localizer</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_Localizer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Localizer</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Descrption:</span>
<span class="cm">    Creates a cylindrical localizer.</span>
<span class="cm">    If d = distance from the point to the line,</span>
<span class="cm">    then the localizer has the following behavior:</span>

<span class="cm">    point distance                localizer value</span>
<span class="cm">    d &lt;= r0 &lt; r1 or d &gt;= r0 &gt; r1      0</span>
<span class="cm">    d &gt;= r1 &gt; r0 or d &lt;= r1 &lt; r0      1</span>

<span class="cm">    For values of d between r0 and r1, the localizer</span>
<span class="cm">    smoothly transitions between 0 to 1.</span>

<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] cylinder axis point</span>
<span class="cm">    D - [in] cylinder axis direction</span>
<span class="cm">    r0 - [in]</span>
<span class="cm">    r1 - [in]</span>
<span class="cm">      r0 and r1 are radii that control where the localizer is nonzero.</span>
<span class="cm">      Both r0 and r1 must be postive and the cannot be equal.</span>
<span class="cm">      If 0 &lt; r0 &lt; r1, then the localizer is zero for points</span>
<span class="cm">      inside the cylinder of radius r0 and one for points outside</span>
<span class="cm">      the cylinder of radius r1.</span>
<span class="cm">      If 0 &lt; r1 &lt; r0, then the localizer is one for points</span>
<span class="cm">      inside the cylinder of radius r1 and zero for points outside</span>
<span class="cm">      the cylinder of radius r0.</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if the input is value and the localizer is initialized.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CreateCylinderLocalizer</span><span class="p">(</span> <span class="n">ON_3dPoint</span> <span class="n">P</span><span class="p">,</span> <span class="n">ON_3dVector</span> <span class="n">D</span><span class="p">,</span> <span class="kt">double</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">r1</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Descrption:</span>
<span class="cm">    Creates a planar localizer.</span>
<span class="cm">    If d = signed distance from the point to the plane,</span>
<span class="cm">    then the localizer has the following behavior:</span>

<span class="cm">    point distance                localizer value</span>
<span class="cm">    d &lt;= h0 &lt; h1 or d &gt;= h0 &gt; h1      0</span>
<span class="cm">    d &gt;= h1 &gt; h0 or d &lt;= h1 &lt; h0      1</span>

<span class="cm">    For values of d between h0 and h1, the localizer</span>
<span class="cm">    smoothly transitions between 0 to 1.</span>

<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] point on plane</span>
<span class="cm">    N - [in] normal to plane</span>
<span class="cm">    h0 - [in]</span>
<span class="cm">    h1 - [in]</span>
<span class="cm">      h0 and h1 are signed distances that control where the</span>
<span class="cm">      localizer is nonzero.</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if the input is value and the localizer is initialized.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CreatePlaneLocalizer</span><span class="p">(</span> <span class="n">ON_3dPoint</span> <span class="n">P</span><span class="p">,</span> <span class="n">ON_3dVector</span> <span class="n">N</span><span class="p">,</span> <span class="kt">double</span> <span class="n">h0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">h1</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Descrption:</span>
<span class="cm">    Creates a spherical localizer.</span>
<span class="cm">    If d = distance from the point to the center of the sphere,</span>
<span class="cm">    then the localizer has the following behavior:</span>

<span class="cm">    point distance                localizer value</span>
<span class="cm">    d &lt;= r0 &lt; r1 or d &gt;= r0 &gt; r1      0</span>
<span class="cm">    d &gt;= r1 &gt; r0 or d &lt;= r1 &lt; r0      1</span>

<span class="cm">    For values of d between r0 and r1, the localizer</span>
<span class="cm">    smoothly transitions between 0 to 1.</span>

<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] center of sphere</span>
<span class="cm">    r0 - [in]</span>
<span class="cm">    r1 - [in]</span>
<span class="cm">      r0 and r1 are radii that control where the localizer is nonzero.</span>
<span class="cm">      Both r0 and r1 must be postive and the cannot be equal.</span>
<span class="cm">      If 0 &lt; r0 &lt; r1, then the localizer is zero for points</span>
<span class="cm">      inside the cylinder of radius r0 and one for points outside</span>
<span class="cm">      the cylinder of radius r1.</span>
<span class="cm">      If 0 &lt; r1 &lt; r0, then the localizer is one for points</span>
<span class="cm">      inside the cylinder of radius r1 and zero for points outside</span>
<span class="cm">      the cylinder of radius r0.</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if the input is value and the localizer is initialized.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CreateSphereLocalizer</span><span class="p">(</span> <span class="n">ON_3dPoint</span> <span class="n">P</span><span class="p">,</span> <span class="kt">double</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">r1</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Evaluators.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P - [in]</span>
<span class="cm">      Evaluation point</span>
<span class="cm">    distance - [in]</span>
<span class="cm">      Evaluation distance</span>
<span class="cm">  Returns:</span>
<span class="cm">    Value of the localizer.</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">Value</span><span class="p">(</span><span class="n">ON_3dPoint</span> <span class="n">P</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">double</span> <span class="nf">Value</span><span class="p">(</span><span class="kt">double</span> <span class="n">distance</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bbox - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if localizer is identically zero inside bbox.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsZero</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">bbox</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">enum</span> <span class="n">TYPE</span>
  <span class="p">{</span>
    <span class="n">no_type</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">sphere_type</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">plane_type</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cylinder_type</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">curve_type</span>    <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">surface_type</span>  <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">distance_type</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">force_32bit_localizer_type</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
  <span class="p">};</span>

  <span class="n">TYPE</span> <span class="n">m_type</span><span class="p">;</span>

  <span class="n">ON_Interval</span>      <span class="n">m_d</span><span class="p">;</span>
  <span class="n">ON_3dPoint</span>       <span class="n">m_P</span><span class="p">;</span>
  <span class="n">ON_3dVector</span>      <span class="n">m_V</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">ON_NurbsCurve</span><span class="o">*</span>   <span class="n">m_nurbs_curve</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">ON_NurbsSurface</span><span class="o">*</span> <span class="n">m_nurbs_surface</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SpaceMorph</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_SpaceMorph</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ON_SpaceMorph</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Provides a quick way to determine if a morph function</span>
<span class="cm">    is the identity (doesn&#39;t move the points) on a region</span>
<span class="cm">    of space.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bbox - [in] region of space to test.</span>
<span class="cm">  Returns:</span>
<span class="cm">    The default always returns false.  If you override</span>
<span class="cm">    this function, then return true when every point</span>
<span class="cm">    in the bounding box is fixed by the morph.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">bool</span> <span class="nf">IsIdentity</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">bbox</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns the desired accuracy of the morph.</span>
<span class="cm">    This value is primarily used for deforming</span>
<span class="cm">    surfaces and breps.</span>
<span class="cm">  Returns:</span>
<span class="cm">    3d fitting tolerance.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The default is 0.0 and any value &lt;= 0.0 is</span>
<span class="cm">    ignored by morphing functions.</span>
<span class="cm">    The value returned by Tolerance() does not</span>
<span class="cm">    affect the way meshes and points are morphed.</span>
<span class="cm">  */</span>
  <span class="kt">double</span> <span class="nf">Tolerance</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the 3d fitting tolerance used when morphing</span>
<span class="cm">    surfaces and breps.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    tolerance - [in] values &lt; 0.0 are treated as 0.0.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetTolerance</span><span class="p">(</span>
          <span class="kt">double</span> <span class="n">tolerance</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the morph should be done as quickly as</span>
<span class="cm">    possible because the result is being used for</span>
<span class="cm">    some type of dynamic preview.  If QuickPreview</span>
<span class="cm">    is true, the tolerance may be ignored.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The value returned by QuickPreview() does not</span>
<span class="cm">    affect the way meshes and points are morphed.</span>
<span class="cm">    The default is false.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">QuickPreview</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the quick preview value.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bQuickPreview - [in]</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetQuickPreview</span><span class="p">(</span>
          <span class="kt">bool</span> <span class="n">bQuickPreview</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the morph should be done in a way that</span>
<span class="cm">    preserves the structure of the geometry.</span>
<span class="cm">    In particular, for NURBS objects, true</span>
<span class="cm">    means that only the control points are moved.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The value returned by PreserveStructure() does not</span>
<span class="cm">    affect the way meshes and points are morphed.</span>
<span class="cm">    The default is false.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">PreserveStructure</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the preserve structure value.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bPreserveStructure - [in]</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetPreserveStructure</span><span class="p">(</span>
          <span class="kt">bool</span> <span class="n">bPreserveStructure</span>
          <span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">m_tolerance</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">m_bQuickPreview</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">m_bPreserveStructure</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>

<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Xform</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_Localizer</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_zlib.h.html" class="btn btn-neutral float-right" title="File opennurbs_zlib.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_xform.h.html" class="btn btn-neutral float-left" title="File opennurbs_xform.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>