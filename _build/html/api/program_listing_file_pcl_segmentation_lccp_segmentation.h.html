

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File lccp_segmentation.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File lccp_segmentation.hpp" href="file_pcl_segmentation_impl_lccp_segmentation.hpp.html" />
    <link rel="prev" title="File lccp_segmentation.h" href="file_pcl_segmentation_lccp_segmentation.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_segmentation_lccp_segmentation.h.html">File lccp_segmentation.h</a> &raquo;</li>
        
      <li>Program Listing for File lccp_segmentation.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_segmentation_lccp_segmentation.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-lccp-segmentation-h">
<span id="program-listing-file-pcl-segmentation-lccp-segmentation-h"></span><h1>Program Listing for File lccp_segmentation.h<a class="headerlink" href="#program-listing-for-file-lccp-segmentation-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_segmentation_lccp_segmentation.h.html#file-pcl-segmentation-lccp-segmentation-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\segmentation\lccp_segmentation.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Software License Agreement (BSD License)</span>
<span class="cm"> *</span>
<span class="cm"> *  Point Cloud Library (PCL) - www.pointclouds.org</span>
<span class="cm"> *  Copyright (c) 2014-, Open Perception, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above</span>
<span class="cm"> *     copyright notice, this list of conditions and the following</span>
<span class="cm"> *     disclaimer in the documentation and/or other materials provided</span>
<span class="cm"> *     with the distribution.</span>
<span class="cm"> *   * Neither the name of the copyright holder(s) nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="cm"> *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span>
<span class="cm"> *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="cm"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="cm"> *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<span class="cm"> *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> *  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/pcl_base.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/point_cloud.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/segmentation/supervoxel_clustering.h&gt;</span><span class="cp"></span>

<span class="cp">#define PCL_INSTANTIATE_LCCPSegmentation(T) template class PCL_EXPORTS pcl::LCCPSegmentation&lt;T&gt;;</span>

<span class="k">namespace</span> <span class="n">pcl</span>
<span class="p">{</span>
  <span class="cm">/** \brief A simple segmentation algorithm partitioning a supervoxel graph into groups of locally convex connected supervoxels separated by concave borders.</span>
<span class="cm">   *  \note If you use this in a scientific work please cite the following paper:</span>
<span class="cm">   *  S. C. Stein, M. Schoeler, J. Papon, F. Woergoetter</span>
<span class="cm">   *  Object Partitioning using Local Convexity</span>
<span class="cm">   *  In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR) 2014</span>
<span class="cm">   *  \author Simon Christoph Stein and Markus Schoeler (mschoeler@gwdg.de)</span>
<span class="cm">   *  \ingroup segmentation</span>
<span class="cm">   */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">LCCPSegmentation</span>
  <span class="p">{</span>
    <span class="cm">/** \brief Edge Properties stored in the adjacency graph.*/</span>
    <span class="k">struct</span> <span class="n">EdgeProperties</span>
    <span class="p">{</span>
      <span class="cm">/** \brief Describes the difference of normals of the two supervoxels being connected*/</span>
      <span class="kt">float</span> <span class="n">normal_difference</span><span class="p">;</span>

      <span class="cm">/** \brief Describes if a connection is convex or concave*/</span>
      <span class="kt">bool</span> <span class="n">is_convex</span><span class="p">;</span>

      <span class="cm">/** \brief Describes if a connection is valid for the segment growing. Usually convex connections are and concave connection are not. Due to k-concavity a convex connection can be invalidated*/</span>
      <span class="kt">bool</span> <span class="n">is_valid</span><span class="p">;</span>

      <span class="cm">/** \brief Additional member used for the CPC algorithm. If edge has already induced a cut, it should be ignored for further cutting.*/</span>
      <span class="kt">bool</span> <span class="n">used_for_cutting</span><span class="p">;</span>

      <span class="n">EdgeProperties</span> <span class="p">()</span> <span class="o">:</span>
      <span class="n">normal_difference</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">is_convex</span> <span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">is_valid</span> <span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">used_for_cutting</span> <span class="p">(</span><span class="nb">false</span><span class="p">)</span>
      <span class="p">{</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">public</span><span class="o">:</span>

      <span class="c1">// Adjacency list with nodes holding labels (uint32_t) and edges holding EdgeProperties.</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">adjacency_list</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">setS</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">setS</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">undirectedS</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">,</span> <span class="n">EdgeProperties</span><span class="o">&gt;</span> <span class="n">SupervoxelAdjacencyList</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">graph_traits</span><span class="o">&lt;</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&gt;::</span><span class="n">vertex_iterator</span> <span class="n">VertexIterator</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">graph_traits</span><span class="o">&lt;</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&gt;::</span><span class="n">adjacency_iterator</span> <span class="n">AdjacencyIterator</span><span class="p">;</span>

      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">graph_traits</span><span class="o">&lt;</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&gt;::</span><span class="n">vertex_descriptor</span> <span class="n">VertexID</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">graph_traits</span><span class="o">&lt;</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&gt;::</span><span class="n">edge_iterator</span> <span class="n">EdgeIterator</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">graph_traits</span><span class="o">&lt;</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&gt;::</span><span class="n">out_edge_iterator</span> <span class="n">OutEdgeIterator</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">graph_traits</span><span class="o">&lt;</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&gt;::</span><span class="n">edge_descriptor</span> <span class="n">EdgeID</span><span class="p">;</span>

      <span class="n">LCCPSegmentation</span> <span class="p">();</span>
      <span class="k">virtual</span>
      <span class="o">~</span><span class="n">LCCPSegmentation</span> <span class="p">();</span>

      <span class="cm">/** \brief Reset internal memory.  */</span>
      <span class="kt">void</span>
      <span class="nf">reset</span> <span class="p">();</span>


      <span class="cm">/** \brief Set the supervoxel clusters as well as the adjacency graph for the segmentation.Those parameters are generated by using the \ref SupervoxelClustering class. To retrieve the output use the \ref segment method.</span>
<span class="cm">       *  \param[in] supervoxel_clusters_arg Map of &lt; supervoxel labels, supervoxels &gt;</span>
<span class="cm">       *  \param[in] label_adjacency_arg The graph defining the supervoxel adjacency relations</span>
<span class="cm">       *  \note Implicitly calls \ref reset */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setInputSupervoxels</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">supervoxel_clusters_arg</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">label_adjacency_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// Initialization</span>
        <span class="n">prepareSegmentation</span> <span class="p">(</span><span class="n">supervoxel_clusters_arg</span><span class="p">,</span> <span class="n">label_adjacency_arg</span><span class="p">);</span>  <span class="c1">// after this, sv_adjacency_list_ can be used to access adjacency list</span>
        <span class="n">supervoxels_set_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Merge supervoxels using local convexity. The input parameters are generated by using the \ref SupervoxelClustering class. To retrieve the output use the \ref relabelCloud method.</span>
<span class="cm">       *  \note There are three ways to retrieve the segmentation afterwards: \ref relabelCloud, \ref getSegmentSupervoxelMap and \ref getSupervoxelSegmentMap*/</span>
      <span class="kt">void</span>
      <span class="nf">segment</span> <span class="p">();</span>

      <span class="cm">/** \brief Relabels cloud with supervoxel labels with the computed segment labels. labeled_cloud_arg should be created using the \ref getLabeledCloud method of the \ref SupervoxelClustering class.</span>
<span class="cm">       *  \param[in,out] labeled_cloud_arg Cloud to relabel  */</span>
      <span class="kt">void</span>
      <span class="nf">relabelCloud</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZL</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">labeled_cloud_arg</span><span class="p">);</span>

      <span class="cm">/** \brief Get map&lt;SegmentID, std::set&lt;SuperVoxel IDs&gt; &gt;</span>
<span class="cm">       *  \param[out] segment_supervoxel_map_arg The output container. On error the map is empty. */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">getSegmentToSupervoxelMap</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">segment_supervoxel_map_arg</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grouping_data_valid_</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">segment_supervoxel_map_arg</span> <span class="o">=</span> <span class="n">seg_label_to_sv_list_map_</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="n">PCL_WARN</span> <span class="p">(</span><span class="s">&quot;[pcl::LCCPSegmentation::getSegmentMap] WARNING: Call function segment first. Nothing has been done. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
          <span class="n">segment_supervoxel_map_arg</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get map&lt;Supervoxel_ID, Segment_ID&gt;</span>
<span class="cm">       *  \param[out] supervoxel_segment_map_arg The output container. On error the map is empty. */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">getSupervoxelToSegmentMap</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;&amp;</span> <span class="n">supervoxel_segment_map_arg</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grouping_data_valid_</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">supervoxel_segment_map_arg</span> <span class="o">=</span> <span class="n">sv_label_to_seg_label_map_</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="n">PCL_WARN</span> <span class="p">(</span><span class="s">&quot;[pcl::LCCPSegmentation::getSegmentMap] WARNING: Call function segment first. Nothing has been done. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
          <span class="n">supervoxel_segment_map_arg</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get map &lt;SegmentID, std::set&lt;Neighboring SegmentIDs&gt; &gt;</span>
<span class="cm">       * \param[out] segment_adjacency_map_arg map &lt; SegmentID, std::set&lt; Neighboring SegmentIDs&gt; &gt;. On error the map is empty.  */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">getSegmentAdjacencyMap</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">segment_adjacency_map_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grouping_data_valid_</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">seg_label_to_neighbor_set_map_</span><span class="p">.</span><span class="n">empty</span> <span class="p">())</span>
            <span class="n">computeSegmentAdjacency</span> <span class="p">();</span>
          <span class="n">segment_adjacency_map_arg</span> <span class="o">=</span> <span class="n">seg_label_to_neighbor_set_map_</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="n">PCL_WARN</span> <span class="p">(</span><span class="s">&quot;[pcl::LCCPSegmentation::getSegmentAdjacencyMap] WARNING: Call function segment first. Nothing has been done. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
          <span class="n">segment_adjacency_map_arg</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get normal threshold</span>
<span class="cm">       *  \return The concavity tolerance angle in [deg] that is currently set */</span>
      <span class="kr">inline</span> <span class="kt">float</span>
      <span class="nf">getConcavityToleranceThreshold</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">concavity_tolerance_threshold_</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get the supervoxel adjacency graph with classified edges (boost::adjacency_list).</span>
<span class="cm">       * \param[out] adjacency_list_arg The supervoxel adjacency list with classified (convex/concave) edges. On error the list is empty.  */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">getSVAdjacencyList</span> <span class="p">(</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&amp;</span> <span class="n">adjacency_list_arg</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grouping_data_valid_</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">adjacency_list_arg</span> <span class="o">=</span> <span class="n">sv_adjacency_list_</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="n">PCL_WARN</span> <span class="p">(</span><span class="s">&quot;[pcl::LCCPSegmentation::getSVAdjacencyList] WARNING: Call function segment first. Nothing has been done. </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
          <span class="n">adjacency_list_arg</span> <span class="o">=</span> <span class="n">pcl</span><span class="o">::</span><span class="n">LCCPSegmentation</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">SupervoxelAdjacencyList</span> <span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Set normal threshold</span>
<span class="cm">       *  \param[in] concavity_tolerance_threshold_arg the concavity tolerance angle in [deg] to set */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setConcavityToleranceThreshold</span> <span class="p">(</span><span class="kt">float</span> <span class="n">concavity_tolerance_threshold_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">concavity_tolerance_threshold_</span> <span class="o">=</span> <span class="n">concavity_tolerance_threshold_arg</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Determines if a smoothness check is done during segmentation, trying to invalidate edges of non-smooth connected edges (steps). Two supervoxels are unsmooth if their plane-to-plane distance DIST &gt; (expected_distance + smoothness_threshold_*voxel_resolution_). For parallel supervoxels, the expected_distance is zero.</span>
<span class="cm">       *  \param[in] use_smoothness_check_arg Determines if the smoothness check is used</span>
<span class="cm">       *  \param[in] voxel_res_arg The voxel resolution used for the supervoxels that are segmented</span>
<span class="cm">       *  \param[in] seed_res_arg The seed resolution used for the supervoxels that are segmented</span>
<span class="cm">       *  \param[in] smoothness_threshold_arg Threshold (/fudging factor) for smoothness constraint according to the above formula. */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setSmoothnessCheck</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">use_smoothness_check_arg</span><span class="p">,</span>
                          <span class="kt">float</span> <span class="n">voxel_res_arg</span><span class="p">,</span>
                          <span class="kt">float</span> <span class="n">seed_res_arg</span><span class="p">,</span>
                          <span class="kt">float</span> <span class="n">smoothness_threshold_arg</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">use_smoothness_check_</span> <span class="o">=</span> <span class="n">use_smoothness_check_arg</span><span class="p">;</span>
        <span class="n">voxel_resolution_</span> <span class="o">=</span> <span class="n">voxel_res_arg</span><span class="p">;</span>
        <span class="n">seed_resolution_</span> <span class="o">=</span> <span class="n">seed_res_arg</span><span class="p">;</span>
        <span class="n">smoothness_threshold_</span> <span class="o">=</span> <span class="n">smoothness_threshold_arg</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Determines if we want to use the sanity criterion to invalidate singular connected patches</span>
<span class="cm">       *  \param[in] use_sanity_criterion_arg Determines if the sanity check is performed */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setSanityCheck</span> <span class="p">(</span><span class="k">const</span> <span class="kt">bool</span> <span class="n">use_sanity_criterion_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">use_sanity_check_</span> <span class="o">=</span> <span class="n">use_sanity_criterion_arg</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Set the value used for k convexity. For k&gt;0 convex connections between p_i and p_j require k common neighbors of these patches that have a convex connection to both.</span>
<span class="cm">       *  \param[in] k_factor_arg factor used for extended convexity check */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setKFactor</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">k_factor_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">k_factor_</span> <span class="o">=</span> <span class="n">k_factor_arg</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Set the value \ref min_segment_size_ used in \ref mergeSmallSegments</span>
<span class="cm">       *  \param[in] min_segment_size_arg Segments smaller than this size will be merged */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setMinSegmentSize</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">min_segment_size_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">min_segment_size_</span> <span class="o">=</span> <span class="n">min_segment_size_arg</span><span class="p">;</span>
      <span class="p">}</span>

    <span class="k">protected</span><span class="o">:</span>

      <span class="cm">/** \brief Segments smaller than \ref min_segment_size_ are merged to the label of largest neighbor */</span>
      <span class="kt">void</span>
      <span class="n">mergeSmallSegments</span> <span class="p">();</span>

      <span class="cm">/** \brief Compute the adjacency of the segments */</span>
      <span class="kt">void</span>
      <span class="nf">computeSegmentAdjacency</span> <span class="p">();</span>

      <span class="cm">/** \brief Is called within \ref setInputSupervoxels mainly to reserve required memory.</span>
<span class="cm">       *  \param[in] supervoxel_clusters_arg map of &lt; supervoxel labels, supervoxels &gt;</span>
<span class="cm">       *  \param[in] label_adjacency_arg The graph defining the supervoxel adjacency relations */</span>
      <span class="kt">void</span>
      <span class="nf">prepareSegmentation</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">supervoxel_clusters_arg</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">label_adjacency_arg</span><span class="p">);</span>


      <span class="cm">/** Perform depth search on the graph and recursively group all supervoxels with convex connections</span>
<span class="cm">       *  \note The vertices in the supervoxel adjacency list are the supervoxel centroids */</span>
      <span class="kt">void</span>
      <span class="nf">doGrouping</span> <span class="p">();</span>

      <span class="cm">/** \brief Assigns neighbors of the query point to the same group as the query point. Recursive part of \ref doGrouping. Grouping is done by a depth-search of nodes in the adjacency-graph.</span>
<span class="cm">       *  \param[in] queryPointID ID of point whose neighbors will be considered for grouping</span>
<span class="cm">       *  \param[in] group_label ID of the group/segment the queried point belongs to  */</span>
      <span class="kt">void</span>
      <span class="nf">recursiveSegmentGrowing</span> <span class="p">(</span><span class="k">const</span> <span class="n">VertexID</span>  <span class="o">&amp;</span><span class="n">queryPointID</span><span class="p">,</span>
                               <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group_label</span><span class="p">);</span>

      <span class="cm">/** \brief Calculates convexity of edges and saves this to the adjacency graph.</span>
<span class="cm">       *  \param[in,out] adjacency_list_arg The supervoxel adjacency list*/</span>
      <span class="kt">void</span>
      <span class="nf">calculateConvexConnections</span> <span class="p">(</span><span class="n">SupervoxelAdjacencyList</span><span class="o">&amp;</span> <span class="n">adjacency_list_arg</span><span class="p">);</span>

      <span class="cm">/** \brief Connections are only convex if this is true for at least k_arg common neighbors of the two patches. Call \ref setKFactor before \ref segment to use this.</span>
<span class="cm">       *  \param[in] k_arg Factor used for extended convexity check */</span>
      <span class="kt">void</span>
      <span class="nf">applyKconvexity</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k_arg</span><span class="p">);</span>

      <span class="cm">/** \brief Returns true if the connection between source and target is convex.</span>
<span class="cm">       *  \param[in] source_label_arg Label of one supervoxel connected to the edge that should be checked</span>
<span class="cm">       *  \param[in] target_label_arg Label of the other supervoxel connected to the edge that should be checked</span>
<span class="cm">       *  \param[out] normal_angle The angle between source and target</span>
<span class="cm">       *  \return True if connection is convex */</span>
      <span class="kt">bool</span>
      <span class="nf">connIsConvex</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">source_label_arg</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">target_label_arg</span><span class="p">,</span>
                    <span class="kt">float</span> <span class="o">&amp;</span><span class="n">normal_angle</span><span class="p">);</span>

      <span class="c1">///  *** Parameters *** ///</span>

      <span class="cm">/** \brief Normal Threshold in degrees [0,180] used for merging */</span>
      <span class="kt">float</span> <span class="n">concavity_tolerance_threshold_</span><span class="p">;</span>

      <span class="cm">/** \brief Marks if valid grouping data (\ref sv_adjacency_list_, \ref sv_label_to_seg_label_map_, \ref processed_) is available */</span>
      <span class="kt">bool</span> <span class="n">grouping_data_valid_</span><span class="p">;</span>

      <span class="cm">/** \brief Marks if supervoxels have been set by calling \ref setInputSupervoxels */</span>
      <span class="kt">bool</span> <span class="n">supervoxels_set_</span><span class="p">;</span>

      <span class="cm">/** \brief Determines if the smoothness check is used during segmentation*/</span>
      <span class="kt">bool</span> <span class="n">use_smoothness_check_</span><span class="p">;</span>

      <span class="cm">/** \brief Two supervoxels are unsmooth if their plane-to-plane distance DIST &gt;  (expected_distance + smoothness_threshold_*voxel_resolution_). For parallel supervoxels, the expected_distance is zero. */</span>
      <span class="kt">float</span> <span class="n">smoothness_threshold_</span><span class="p">;</span>

      <span class="cm">/** \brief Determines if we use the sanity check which tries to find and invalidate singular connected patches*/</span>
      <span class="kt">bool</span> <span class="n">use_sanity_check_</span><span class="p">;</span>

      <span class="cm">/** \brief Seed resolution of the supervoxels (used only for smoothness check) */</span>
      <span class="kt">float</span> <span class="n">seed_resolution_</span><span class="p">;</span>

      <span class="cm">/** \brief Voxel resolution used to build the supervoxels (used only for smoothness check)*/</span>
      <span class="kt">float</span> <span class="n">voxel_resolution_</span><span class="p">;</span>

      <span class="cm">/** \brief Factor used for k-convexity */</span>
      <span class="kt">uint32_t</span> <span class="n">k_factor_</span><span class="p">;</span>

      <span class="cm">/** \brief Minimum segment size */</span>
      <span class="kt">uint32_t</span> <span class="n">min_segment_size_</span><span class="p">;</span>

      <span class="cm">/** \brief Stores which supervoxel labels were already visited during recursive grouping.</span>
<span class="cm">       *  \note processed_[sv_Label] = false (default)/true (already processed) */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">processed_</span><span class="p">;</span>

      <span class="cm">/** \brief Adjacency graph with the supervoxel labels as nodes and edges between adjacent supervoxels */</span>
      <span class="n">SupervoxelAdjacencyList</span> <span class="n">sv_adjacency_list_</span><span class="p">;</span>

      <span class="cm">/** \brief map from the supervoxel labels to the supervoxel objects  */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span><span class="o">&gt;</span> <span class="n">sv_label_to_supervoxel_map_</span><span class="p">;</span>

      <span class="cm">/** \brief Storing relation between original SuperVoxel Labels and new segmantion labels.</span>
<span class="cm">       *  \note sv_label_to_seg_label_map_[old_labelID] = new_labelID */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">sv_label_to_seg_label_map_</span><span class="p">;</span>

      <span class="cm">/** \brief map &lt;Segment Label, std::set &lt;SuperVoxel Labels&gt; &gt; */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">seg_label_to_sv_list_map_</span><span class="p">;</span>

      <span class="cm">/** \brief map &lt; SegmentID, std::set&lt; Neighboring segment labels&gt; &gt; */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">seg_label_to_neighbor_set_map_</span><span class="p">;</span>

  <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#ifdef PCL_NO_PRECOMPILE</span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/segmentation/impl/lccp_segmentation.hpp&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_segmentation_impl_lccp_segmentation.hpp.html" class="btn btn-neutral float-right" title="File lccp_segmentation.hpp" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_segmentation_lccp_segmentation.h.html" class="btn btn-neutral float-left" title="File lccp_segmentation.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>