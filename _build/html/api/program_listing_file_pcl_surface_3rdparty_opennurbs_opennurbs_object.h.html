

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_object.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_object_history.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_object_history.h.html" />
    <link rel="prev" title="File opennurbs_object.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_object.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_object.h.html">File opennurbs_object.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_object.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_object.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-object-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-object-h"></span><h1>Program Listing for File opennurbs_object.h<a class="headerlink" href="#program-listing-for-file-opennurbs-object-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_object.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-object-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_object.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">//   virtual base class for all openNURBS objects</span>
<span class="c1">//</span>
<span class="c1">////////////////////////////////////////////////////////////////</span>

<span class="cp">#if !defined(OPENNURBS_OBJECT_INC_)</span>
<span class="cp">#define OPENNURBS_OBJECT_INC_</span>


<span class="k">class</span> <span class="nc">ON_ClassId</span><span class="p">;</span> <span class="c1">// used for runtime class identification</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// Runtime class id</span>
<span class="c1">//</span>

<span class="c1">// Description:</span>
<span class="c1">//   Every class derived from ON_Object has a class id that records</span>
<span class="c1">//   its class name, baseclass name, and class uuid.  The</span>
<span class="c1">//   ON_OBJECT_DECLARE and ON_OBJECT_IMPLEMENT macros generate</span>
<span class="c1">//   the code that creates and initializes class ids.</span>
<span class="c1">//</span>
<span class="c1">//   The ON_Object::IsKindOf() and ON_Object::Cast() functions</span>
<span class="c1">//   use these class ids.</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassId</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   This constructor is called to initialize each class id.</span>
  <span class="c1">//   The call is generated by the ON_OBJECT_IMPLEMENT macro.</span>
  <span class="c1">//</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   sClassName - [in] name of the class (like ON_Geometry)</span>
  <span class="c1">//   sBaseClassName - [in] name of baseclass (like ON_Object)</span>
  <span class="c1">//   create - [in] function to create a new object(like CreateNewON_Geometry())</span>
  <span class="c1">//   copy - [in] function to copy</span>
  <span class="c1">//   sUUID - [in] UUID in registry format from Windows guidgen.exe</span>
  <span class="n">ON_ClassId</span><span class="p">(</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sClassName</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sBaseClassName</span><span class="p">,</span>
          <span class="n">ON_Object</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(),</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sUUID</span>
           <span class="p">);</span>

  <span class="n">ON_ClassId</span><span class="p">(</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sClassName</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sBaseClassName</span><span class="p">,</span>
          <span class="n">ON_Object</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(),</span>
          <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="k">const</span> <span class="n">ON_Object</span><span class="o">*</span><span class="p">,</span><span class="n">ON_Object</span><span class="o">*</span> <span class="p">),</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sUUID</span>
           <span class="p">);</span>

  <span class="o">~</span><span class="n">ON_ClassId</span><span class="p">();</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Gets a class&#39;s ON_ClassId from the class&#39;s name.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   sClassName - [in] name of class</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Pointer to the class&#39;s ON_ClassId.</span>
  <span class="c1">// Example:</span>
  <span class="c1">//   const ON_ClassId* brep_id = ON_CLassId::ClassId(&quot;ON_Brep&quot;);</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="nf">ClassId</span><span class="p">(</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sClassName</span>
          <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Gets a class&#39;s ON_ClassId from the class&#39;s uuid.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   class_uuid - [in] uuid for the class</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Pointer to the class&#39;s ON_ClassId.</span>
  <span class="c1">// Example:</span>
  <span class="c1">//   ON_UUID brep_uuid = ON_UuidFromString(&quot;60B5DBC5-E660-11d3-BFE4-0010830122F0&quot;);</span>
  <span class="c1">//   const ON_ClassId* brep_id = ON_CLassId::ClassId(brep_uuid);</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="nf">ClassId</span><span class="p">(</span>
          <span class="n">ON_UUID</span> <span class="n">class_uuid</span>
          <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Each class derived from ON_Object has a corresponding ON_ClassId</span>
  <span class="c1">//   stored in a linked list and the class is marked with an integer</span>
  <span class="c1">//   value.  ON_ClassId::IncrementMark() increments the value used to</span>
  <span class="c1">//   mark new classes and returns the new marking value.</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Value that will be used to mark all future ON_ClassIds.</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">IncrementMark</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">CurrentMark</span><span class="p">();</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="nf">LastClassId</span><span class="p">();</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Each class derived from ON_Object has a corresponding</span>
  <span class="c1">//   ON_ClassId stored in a linked list.  If a class definition</span>
  <span class="c1">//   is going to disappear (which happens when the derived object</span>
  <span class="c1">//   definition is in a DLL that uses openNURBS as a DLL and the</span>
  <span class="c1">//   DLL containing the derived object&#39;s definition is unloaded),</span>
  <span class="c1">//   then the class&#39;s ON_ClassId needs to be removed from the class</span>
  <span class="c1">//   list.  ON_ClassId::Purge( mark ) removes all ON_ClassIds with a</span>
  <span class="c1">//   a prescribed mark and returns the number of classes that</span>
  <span class="c1">//   were purged.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   mark - [in] All ON_ClassIds with this mark will be purged.</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Number of classes that were purged.</span>
  <span class="c1">// Example:</span>
  <span class="c1">//   // Call ON_ClassId::IncrementMark() BEFORE loading MY.DLL.</span>
  <span class="c1">//   int my_dll_classid_mark = ON_ClassId::IncrementMark();</span>
  <span class="c1">//   load MY.DLL with classes derived from ON_Object</span>
  <span class="c1">//   ...</span>
  <span class="c1">//   // Call ON_ClassId::Purge() BEFORE unloading MY.DLL.</span>
  <span class="c1">//   ON_ClassId::Purge( my_dll_classid_mark );</span>
  <span class="c1">//   unload MY.DLL</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">Purge</span><span class="p">(</span><span class="kt">int</span> <span class="n">mark</span><span class="p">);</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="nf">PurgeAfter</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="n">pClassId</span><span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Dumps the ON_ClassId list</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   dump - [in] destination for the text dump.</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span>
    <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="n">dump</span>
    <span class="p">);</span>

  <span class="c1">// Returns:</span>
  <span class="c1">//   class name</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">ClassName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Returns:</span>
  <span class="c1">//   base class name</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">BaseClassName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Returns:</span>
  <span class="c1">//   base class id</span>
  <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="nf">BaseClass</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Determine if the class associated with this ON_ClassId</span>
  <span class="c1">//   is derived from another class.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   potential_parent - [in] Class to test as parent.</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   true if this is derived from potential_parent.</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsDerivedFrom</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="n">potential_parent</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Descrption:</span>
  <span class="c1">//   Create an instance of the class associated with</span>
  <span class="c1">//   class id.</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Instance of the class id&#39;s class.</span>
  <span class="n">ON_Object</span><span class="o">*</span> <span class="nf">Create</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Returns:</span>
  <span class="c1">//   class uuid</span>
  <span class="n">ON_UUID</span> <span class="nf">Uuid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Opennurbs classes have a mark value of 0.  Core Rhino</span>
<span class="cm">    classes have a mark value of 1.  Rhino plug-in classes</span>
<span class="cm">    have a mark value of &gt; 1.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Class mark value</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">Mark</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ClassIdVersion</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="n">m_p0</span><span class="p">;</span>     <span class="c1">// first id in the linked list of class ids</span>
  <span class="k">static</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="n">m_p1</span><span class="p">;</span>     <span class="c1">// last id in the linked list of class ids</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">m_mark0</span><span class="p">;</span>  <span class="c1">// current mark value</span>
  <span class="n">ON_ClassId</span><span class="o">*</span> <span class="n">m_pNext</span><span class="p">;</span>         <span class="c1">// next in the linked list of class ids</span>
  <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="n">m_pBaseClassId</span><span class="p">;</span>  <span class="c1">// base class id</span>
  <span class="kt">char</span> <span class="n">m_sClassName</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">m_sBaseClassName</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
  <span class="n">ON_Object</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">m_create</span><span class="p">)();</span>
  <span class="n">ON_UUID</span> <span class="n">m_uuid</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_mark</span><span class="p">;</span> <span class="c1">// bit 0x80000000 is used to indicate new extensions</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// no implementaion to prohibit use</span>
  <span class="n">ON_ClassId</span><span class="p">();</span>
  <span class="n">ON_ClassId</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_ClassId</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">ConstructorHelper</span><span class="p">(</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sClassName</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sBaseClassName</span><span class="p">,</span>
          <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">sUUID</span>
          <span class="p">);</span>

  <span class="c1">// This is a temporary way to add simple virtual functions</span>
  <span class="c1">// to ON_Object without breaking the SDK.  At V6 these will</span>
  <span class="c1">// be redone to be ordinary virtual functions.</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Object</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_class_id_version</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">m_copy</span><span class="p">)(</span><span class="k">const</span> <span class="n">ON_Object</span><span class="o">*</span><span class="p">,</span><span class="n">ON_Object</span><span class="o">*</span><span class="p">);</span> <span class="c1">// on version 1 class ids</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_f2</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_f3</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_f4</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_f5</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_f6</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_f7</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_f8</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Description:</span>
<span class="c1">//   Macro to easily get a pointer to the ON_ClassId for a</span>
<span class="c1">//   given class;</span>
<span class="c1">//</span>
<span class="c1">// Example:</span>
<span class="c1">//</span>
<span class="c1">//          const ON_ClassId* brep_class_id = ON_CLASS_ID(&quot;ON_Brep&quot;);</span>
<span class="c1">//</span>
<span class="cp">#define ON_CLASS_ID( cls ) ON_ClassId::ClassId( #cls )</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Expert user function to get the value of ON_ClassId::m_uuid</span>
<span class="cm">  of the last instance of ON_ClassId to call ON_ClassId::Create().</span>
<span class="cm">  This function was created to support Rhino&#39;s .NET SDK.</span>
<span class="cm">  This function returns the value of a static id in</span>
<span class="cm">  opennurbs_object.cpp and is NOT thread safe.</span>
<span class="cm">Returns:</span>
<span class="cm">  Value of ON_ClassId::m_uuid of the instance of ON_ClassId that</span>
<span class="cm">  most recently called ON_ClassId::Create().</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_UUID</span> <span class="nf">ON_GetMostRecentClassIdCreateUuid</span><span class="p">();</span>

<span class="cm">/*</span>
<span class="cm">All classes derived from ON_Object must have</span>

<span class="cm">  ON_OBJECT_DECLARE( &lt;classname&gt; );</span>

<span class="cm">as the first line in their class definition an a corresponding</span>

<span class="cm">  ON_VIRTUAL_OBJECT_IMPLEMENT( &lt;classname&gt;, &lt;basclassname&gt;, &lt;classuuid&gt; );</span>

<span class="cm">or</span>

<span class="cm">  ON_OBJECT_IMPLEMENT( &lt;classname&gt;, &lt;basclassname&gt;, &lt;classuuid&gt; );</span>

<span class="cm">in a .CPP file.</span>
<span class="cm">*/</span>
<span class="cp">#define ON_OBJECT_DECLARE( cls )                                \</span>
<span class="cp">  protected:                                                    \</span>
<span class="cp">    static void* m_s_##cls##_ptr;                               \</span>
<span class="cp">  public:                                                       \</span>
<span class="cp">    static const ON_ClassId m_##cls##_class_id;                 \</span>
<span class="cp">    </span><span class="cm">/*record used for ON_Object runtime type information*/</span><span class="cp">      \</span>
<span class="cp">                                                                \</span>
<span class="cp">    static cls * Cast( ON_Object* );                            \</span>
<span class="cp">    </span><span class="cm">/*Description: Similar to C++ dynamic_cast*/</span><span class="cp">                \</span>
<span class="cp">    </span><span class="cm">/*Returns: object on success. NULL on failure*/</span><span class="cp">             \</span>
<span class="cp">                                                                \</span>
<span class="cp">    static const cls * Cast( const ON_Object* );                \</span>
<span class="cp">    </span><span class="cm">/*Description: Similar to C++ dynamic_cast*/</span><span class="cp">                \</span>
<span class="cp">    </span><span class="cm">/*Returns: object on success. NULL on failure*/</span><span class="cp">             \</span>
<span class="cp">                                                                \</span>
<span class="cp">    virtual const ON_ClassId* ClassId() const;                  \</span>
<span class="cp">    </span><span class="cm">/*Description:*/</span><span class="cp">                                            \</span>
<span class="cp">                                                                \</span>
<span class="cp">  private:                                                      \</span>
<span class="cp">    virtual ON_Object* DuplicateObject() const;                 \</span>
<span class="cp">    </span><span class="cm">/*used by Duplicate to create copy of an object.*/</span><span class="cp">          \</span>
<span class="cp">                                                                \</span>
<span class="cp">    static bool Copy##cls( const ON_Object*, ON_Object* );      \</span>
<span class="cp">    </span><span class="cm">/* used by ON_Object::CopyFrom copy object into this. */</span><span class="cp">    \</span>
<span class="cp">    </span><span class="cm">/* In V6 Copy##cls will vanish and be replaced with   */</span><span class="cp">    \</span>
<span class="cp">    </span><span class="cm">/* virtual bool CopyFrom( const ON_Object* src )      */</span><span class="cp">    \</span>
<span class="cp">                                                                \</span>
<span class="cp">  public:                                                       \</span>
<span class="cp">    cls * Duplicate() const;                                    \</span>
<span class="cp">    </span><span class="cm">/*Description: Expert level tool - no support available.*/</span><span class="cp">  \</span>
<span class="cp">    </span><span class="cm">/*If this class is derived from CRhinoObject, use CRhinoObject::DuplicateRhinoObject instead*/</span><span class="cp"></span>

<span class="c1">// Objects derived from ON_Object that do not have a valid new, operator=,</span>
<span class="c1">// or copy constructor must use ON_VIRTUAL_OBJECT_IMPLEMENT instead of</span>
<span class="c1">// ON_OBJECT_IMPLEMENT.  Objects defined with ON_VIRTUAL_OBJECT_IMPLEMENT</span>
<span class="c1">// cannot be serialized using ON_BinaryArchive::ReadObject()/WriteObject()</span>
<span class="c1">// or duplicated using ON_Object::Duplicate().</span>
<span class="c1">//</span>
<span class="c1">// The Cast() and ClassId() members work on objects defined with either</span>
<span class="c1">// ON_VIRTUAL_OBJECT_IMPLEMENT or ON_OBJECT_IMPLEMENT.</span>
<span class="cp">#define ON_VIRTUAL_OBJECT_IMPLEMENT( cls, basecls, uuid ) \</span>
<span class="cp">  void* cls::m_s_##cls##_ptr = 0;\</span>
<span class="cp">  const ON_ClassId cls::m_##cls##_class_id(#cls,#basecls,0,0,uuid);\</span>
<span class="cp">  cls * cls::Cast( ON_Object* p) {return(cls *)Cast((const ON_Object*)p);} \</span>
<span class="cp">  const cls * cls::Cast( const ON_Object* p) {return(p&amp;&amp;p-&gt;IsKindOf(&amp;cls::m_##cls##_class_id))?(const cls *)p:0;} \</span>
<span class="cp">  const ON_ClassId* cls::ClassId() const {return &amp;cls::m_##cls##_class_id;} \</span>
<span class="cp">  ON_Object* cls::DuplicateObject() const {return 0;} \</span>
<span class="cp">  bool cls::Copy##cls( const ON_Object*, ON_Object* ) {return false;} \</span>
<span class="cp">  cls * cls::Duplicate() const {return static_cast&lt;cls *&gt;(DuplicateObject());}</span>

<span class="c1">// Objects derived from ON_Object that use ON_OBJECT_IMPLEMENT must</span>
<span class="c1">// have a valid operator= and copy constructor.  Objects defined with</span>
<span class="c1">// ON_OBJECT_IMPLEMENT may be serialized using</span>
<span class="c1">// ON_BinaryArchive::ReadObject()/WriteObject()</span>
<span class="c1">// and duplicated by calling ON_Object::Duplicate().</span>
<span class="cp">#define ON_OBJECT_IMPLEMENT( cls, basecls, uuid ) \</span>
<span class="cp">  void* cls::m_s_##cls##_ptr = 0;\</span>
<span class="cp">  static ON_Object* CreateNew##cls() {return new cls();} \</span>
<span class="cp">  const ON_ClassId cls::m_##cls##_class_id(#cls,#basecls,CreateNew##cls,cls::Copy##cls,uuid);\</span>
<span class="cp">  cls * cls::Cast( ON_Object* p) {return(cls *)Cast((const ON_Object*)p);} \</span>
<span class="cp">  const cls * cls::Cast( const ON_Object* p) {return(p&amp;&amp;p-&gt;IsKindOf(&amp;cls::m_##cls##_class_id))?(const cls *)p:0;} \</span>
<span class="cp">  const ON_ClassId* cls::ClassId() const {return &amp;cls::m_##cls##_class_id;} \</span>
<span class="cp">  ON_Object* cls::DuplicateObject() const {cls* p = new cls(); if (p) *p=*this; return p;} \</span>
<span class="cp">  bool cls::Copy##cls( const ON_Object* src, ON_Object* dst ){cls* d;const cls* s;if (0!=(s=cls::Cast(src))&amp;&amp;0!=(d=cls::Cast(dst))) {d-&gt;cls::operator=(*s);return true;}return false;} \</span>
<span class="cp">  cls * cls::Duplicate() const {return static_cast&lt;cls *&gt;(DuplicateObject());}</span>

<span class="cp">#define ON__SET__THIS__PTR(ptr) if (ptr) *((void**)this) = ptr</span>

<span class="k">class</span> <span class="nc">ON_UserData</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_UserString</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_UserString</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_UserString</span><span class="p">();</span>
  <span class="n">ON_wString</span> <span class="n">m_key</span><span class="p">;</span>
  <span class="n">ON_wString</span> <span class="n">m_string_value</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span><span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="n">text_log</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_UserString</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  When ON_Object::IsValid() fails and returns false, ON_IsNotValid()</span>
<span class="cm">  is called.  This way, a developer can put a breakpoint in</span>
<span class="cm">  ON_IsNotValid() and stop execution at the exact place IsValid()</span>
<span class="cm">  fails.</span>
<span class="cm">Returns:</span>
<span class="cm">  false;</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_IsNotValid</span><span class="p">();</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>

<span class="c1">// Description:</span>
<span class="c1">//   Pure virtual base class for all classes that must provide</span>
<span class="c1">//   runtime class id or support object level 3DM serialization</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_Object</span>
<span class="p">{</span>
  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Any object derived from ON_Object should have a</span>
  <span class="c1">//   ON_OBJECT_DECLARE(ON_...);</span>
  <span class="c1">// as the last line of its class definition and a</span>
  <span class="c1">//   ON_OBJECT_IMPLEMENT( ON_..., ON_baseclass );</span>
  <span class="c1">// in a .cpp file.</span>
  <span class="c1">//</span>
  <span class="c1">// These macros declare and implement public members</span>
  <span class="c1">//</span>
  <span class="c1">// static ON_ClassId m_ON_Object;</span>
  <span class="c1">// static cls * Cast( ON_Object* );</span>
  <span class="c1">// static const cls * Cast( const ON_Object* );</span>
  <span class="c1">// virtual const ON_ClassId* ClassId() const;</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_Object</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Copies src into this, if possible.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    src - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if this-&gt;operator= could be called to copy src.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This should be virtual function declared in the</span>
<span class="cm">    ON_OBJECT_DECLARE macro along the lines of DuplicateObject()</span>
<span class="cm">    but is was added after the SDK was frozen (adding virtual</span>
<span class="cm">    functions breaks the SDK).  In V6, the function will work</span>
<span class="cm">    the same but be implemented like DuplicateObject();</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="n">CopyFrom</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">*</span> <span class="n">src</span> <span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="n">ON_Object</span><span class="p">();</span>
  <span class="n">ON_Object</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ON_Object</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets m_user_data_list = 0.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    The MemoryRelocate() function is called when an</span>
<span class="cm">    object&#39;s location in memory is changed.  For</span>
<span class="cm">    example, if an object resides in a chunk of</span>
<span class="cm">    memory that is grown by calling a realloc</span>
<span class="cm">    that has to allocate a new chunk and</span>
<span class="cm">    copy the contents of the old chunk to the</span>
<span class="cm">    new chunk, then the location of the object&#39;s</span>
<span class="cm">    memory changes.  In practice this happens when</span>
<span class="cm">    classes derived from ON_Object are stored</span>
<span class="cm">    in dynamic arrays, like the default implementation</span>
<span class="cm">    of ON_ObjectArray&lt;&gt;&#39;s that use realloc to grow</span>
<span class="cm">    the dynamic array.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">void</span> <span class="nf">MemoryRelocate</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Low level tool to test if an object is derived</span>
<span class="cm">    from a specified class.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    pClassId - [in] use classname::ClassId()</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if the instantiated object is derived from the</span>
<span class="cm">    class whose id is passed as the argument.</span>
<span class="cm">  Example:</span>

<span class="cm">          ON_Object* p = ....;</span>
<span class="cm">          if ( p-&gt;IsKindOf( ON_NurbsCurve::ClassId() ) )</span>
<span class="cm">          {</span>
<span class="cm">            it&#39;s a NURBS curve</span>
<span class="cm">          }</span>

<span class="cm">  Remarks:</span>
<span class="cm">    The primary reason for IsKindOf() is to support the</span>
<span class="cm">    static Cast() members declared in the ON_OBJECT_DECLARE</span>
<span class="cm">    macro.  If we determine that dynamic_cast is properly</span>
<span class="cm">    supported and implemented by all supported compilers,</span>
<span class="cm">    then IsKindOf() may dissappear.  If an application needs</span>
<span class="cm">    to determine if a pointer points to a class derived from</span>
<span class="cm">    ON_SomeClassName, then call</span>
<span class="cm">    ON_SomeClassName::Cast(mystery pointer) and check for</span>
<span class="cm">    a non-null return.</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsKindOf</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_ClassId</span><span class="o">*</span> <span class="n">pClassId</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Creates a text dump of the object.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Dump() is intended for debugging and is not suitable</span>
<span class="cm">    for creating high quality text descriptions of an</span>
<span class="cm">    object.</span>

<span class="cm">    The default implementations of this virtual function</span>
<span class="cm">    prints the class&#39;s name.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    An estimate of the amount of memory the class uses in bytes.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns a CRC calculated from the information that defines</span>
<span class="cm">    the object.  This CRC can be used as a quick way to see</span>
<span class="cm">    if two objects are not identical.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    current_remainder - [in];</span>
<span class="cm">  Returns:</span>
<span class="cm">    CRC of the information the defines the object.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="n">ON__UINT32</span> <span class="nf">DataCRC</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">current_remainder</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Low level archive writing tool used by ON_BinaryArchive::WriteObject().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    binary_archive - archive to write to</span>
<span class="cm">  Returns:</span>
<span class="cm">    Returns true if the write is successful.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Use ON_BinaryArchive::WriteObject() to write objects.</span>
<span class="cm">    This Write() function should just write the specific definition of</span>
<span class="cm">    this object.  It should not write and any chunk typecode or length</span>
<span class="cm">    information.</span>

<span class="cm">    The default implementation of this virtual function returns</span>
<span class="cm">    false and does nothing.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span>
         <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Low level archive writing tool used by ON_BinaryArchive::ReadObject().</span>
<span class="cm">  Parameters:</span>
<span class="cm">    binary_archive - archive to read from</span>
<span class="cm">  Returns:</span>
<span class="cm">    Returns true if the read is successful.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Use ON_BinaryArchive::ReadObject() to read objects.</span>
<span class="cm">    This Read() function should read the objects definition back into</span>
<span class="cm">    its data members.</span>

<span class="cm">    The default implementation of this virtual function returns</span>
<span class="cm">    false and does nothing.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span>
         <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span>
       <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Useful for switch statements that need to differentiate</span>
<span class="cm">    between basic object types like points, curves, surfaces,</span>
<span class="cm">    and so on.</span>

<span class="cm">  Returns:</span>
<span class="cm">    ON::object_type enum value.</span>

<span class="cm">    @untitled table</span>
<span class="cm">    ON::unknown_object_type      unknown object</span>
<span class="cm">    ON::point_object             derived from ON_Point</span>
<span class="cm">    ON::pointset_object          some type of ON_PointCloud, ON_PointGrid, ...</span>
<span class="cm">    ON::curve_object             derived from ON_Curve</span>
<span class="cm">    ON::surface_object           derived from ON_Surface</span>
<span class="cm">    ON::brep_object              derived from ON_Brep</span>
<span class="cm">    ON::extrusion_object         derived from ON_Extrusion</span>
<span class="cm">    ON::mesh_object              derived from ON_Mesh</span>
<span class="cm">    ON::layer_object             derived from ON_Layer</span>
<span class="cm">    ON::material_object          derived from ON_Material</span>
<span class="cm">    ON::light_object             derived from ON_Light</span>
<span class="cm">    ON::annotation_object        derived from ON_Annotation,</span>
<span class="cm">    ON::userdata_object          derived from ON_UserData</span>
<span class="cm">    ON::text_dot                 derived from ON_TextDot</span>

<span class="cm">  Remarks:</span>
<span class="cm">    The default implementation of this virtual function returns</span>
<span class="cm">    ON::unknown_object_type</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>



  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    All objects in an opennurbs model have an id</span>
<span class="cm">    ( ON_Layer.m_layer_id, ON_Font.m_font_id,</span>
<span class="cm">      ON_Material.m_material_id, ON_3dmObjectAttributes.m_uuid</span>
<span class="cm">      ).</span>
<span class="cm">  Returns:</span>
<span class="cm">    The id used to identify the object in the openurbs model.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="n">ON_UUID</span> <span class="nf">ModelObjectId</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// BEGIN: User string support</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Attach a user string to the object.  This information will</span>
<span class="cm">    perisist through copy construction, operator=, and file IO.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    key - [in] id used to retrieve this string.</span>
<span class="cm">    string_value - [in]</span>
<span class="cm">      If NULL, the string with this id will be removed.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetUserString</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">string_value</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Append entries to the user string list</span>
<span class="cm">  Parameters:</span>
<span class="cm">    count - [in]</span>
<span class="cm">      number of element in us[] array</span>
<span class="cm">    user_strings - [in]</span>
<span class="cm">      entries to append.</span>
<span class="cm">    bReplace - [in]</span>
<span class="cm">      If bReplace is true, then existing entries with the same key are</span>
<span class="cm">      updated with the new entry&#39;s value.  If bReplace is false, then</span>
<span class="cm">      existing entries are not updated.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of entries added, deleted, or modified.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SetUserStrings</span><span class="p">(</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_UserString</span><span class="o">*</span> <span class="n">user_strings</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bReplace</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get user string from the object.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    key - [in] id used to retrieve the string.</span>
<span class="cm">    string_value - [out]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a string with id was found.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetUserString</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span>
    <span class="n">ON_wString</span><span class="o">&amp;</span> <span class="n">string_value</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a list of all user strings on the object.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    user_strings - [out]</span>
<span class="cm">      user strings are appended to this list.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of elements appended to the user_strings list.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetUserStrings</span><span class="p">(</span>
    <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_UserString</span><span class="o">&gt;&amp;</span> <span class="n">user_strings</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a list of all user string keys on the object.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    user_string_keys - [out]</span>
<span class="cm">      user string keys are appended to this list.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of elements appended to the user_strings list.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetUserStringKeys</span><span class="p">(</span>
    <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_wString</span><span class="o">&gt;&amp;</span> <span class="n">user_string_keys</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of user strings on the object.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">UserStringCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//</span>
  <span class="c1">// END: User string support</span>
  <span class="c1">//</span>
  <span class="c1">//////////////////////////////////////////////////////////////////</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// User data provides a standard way for extra information to</span>
  <span class="c1">// be attached to any class derived from ON_Object.  The attached</span>
  <span class="c1">// information can persist and be transformed.  If you use user</span>
  <span class="c1">// data, please carefully read all the comments from here to the</span>
  <span class="c1">// end of the file.</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Attach user data to an object.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    pUserData - [in] user data to attach to object.</span>
<span class="cm">        The ON_UserData pointer passed to AttachUserData()</span>
<span class="cm">        must be created with new.</span>
<span class="cm">  Returns:</span>
<span class="cm">    If true is returned, then ON_Object will delete the user</span>
<span class="cm">    data when appropriate.  If false is returned, then data</span>
<span class="cm">    could not be attached and caller must delete.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    AttachUserData() will fail if the user data&#39;s m_userdata_uuid</span>
<span class="cm">    field is nil or not unique.</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">AttachUserData</span><span class="p">(</span>
          <span class="n">ON_UserData</span><span class="o">*</span> <span class="n">pUserData</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Remove user data from an object.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    pUserData - [in] user data to attach to object.</span>
<span class="cm">        The ON_UserData pointer passed to DetachUserData()</span>
<span class="cm">        must have been previously attached using</span>
<span class="cm">        AttachUserData().</span>
<span class="cm">  Returns:</span>
<span class="cm">    If true is returned, then the user data was</span>
<span class="cm">    attached to this object and it was detached.  If false</span>
<span class="cm">    is returned, then the user data was not attached to this</span>
<span class="cm">    object to begin with.  In all cases, you can be assured</span>
<span class="cm">    that the user data is no longer attached to &quot;this&quot;.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Call delete pUserData if you want to destroy the user data.</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">DetachUserData</span><span class="p">(</span>
          <span class="n">ON_UserData</span><span class="o">*</span> <span class="n">pUserData</span>
          <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a pointer to user data.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    userdata_uuid - [in] value of the user data&#39;s</span>
<span class="cm">       m_userdata_uuid field.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The returned user data is still attached to the object.</span>
<span class="cm">    Deleting the returned user data will automatically remove</span>
<span class="cm">    the user data from the object.</span>
<span class="cm">  */</span>
  <span class="n">ON_UserData</span><span class="o">*</span> <span class="nf">GetUserData</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="n">userdata_uuid</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    PurgeUserData() removes all user data from object.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Use delete GetUserData(...) to destroy a single piece</span>
<span class="cm">    of user data.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">PurgeUserData</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    User data is stored as a linked list of ON_UserData</span>
<span class="cm">    classes.  FirstUserData gets the first item in the</span>
<span class="cm">    linked list.  This is the most recent item attached</span>
<span class="cm">    using AttachUserData().</span>
<span class="cm">  Remark:</span>
<span class="cm">    To iterate through all the user data on an object,</span>
<span class="cm">    call FirstUserData() and then use ON_UserData::Next()</span>
<span class="cm">    to traverse the list.</span>
<span class="cm">  */</span>
  <span class="n">ON_UserData</span><span class="o">*</span> <span class="nf">FirstUserData</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Objects derived from ON_Geometry must call</span>
<span class="cm">    TransformUserData() in their Transform() member function.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    xform - [in] transformation to apply to user data</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">TransformUserData</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool that copies user data that has a positive</span>
<span class="cm">    m_userdata_copycount from the source_object to this.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    source_object - [in] source of user data to copy</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Generally speaking you don&#39;t need to use CopyUserData().</span>
<span class="cm">    Simply rely on ON_Object::operator=() or the copy constructor</span>
<span class="cm">    to do the right thing.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">CopyUserData</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="n">source_object</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user tool Moves user data from source_object</span>
<span class="cm">    to this, including user data with a nil m_userdata_copycount.</span>
<span class="cm">    Deletes any source user data with a duplicate m_userdata_uuid</span>
<span class="cm">    on this.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">MoveUserData</span><span class="p">(</span>
    <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="n">source_object</span>
    <span class="p">);</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Expert interface</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function.  If you are using openNURBS in its</span>
<span class="cm">    default configuration to read and write 3dm archives,</span>
<span class="cm">    you never need to call this function.</span>
<span class="cm">    Many objects employ lazy creation of (runtime) caches</span>
<span class="cm">    that save information to help speed geometric calculations.</span>
<span class="cm">    This function will destroy all runtime information.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bDelete - [in] if true, any cached information is properly</span>
<span class="cm">                   deleted.  If false, any cached information</span>
<span class="cm">                   is simply discarded.  This is useful when</span>
<span class="cm">                   the cached information may be in alternate</span>
<span class="cm">                   memory pools that are managed in nonstandard</span>
<span class="cm">                   ways.</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">void</span> <span class="nf">DestroyRuntimeCache</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDelete</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="kt">int</span> <span class="n">ON_BinaryArchive</span><span class="o">::</span><span class="n">ReadObject</span><span class="p">(</span> <span class="n">ON_Object</span><span class="o">**</span> <span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">ON_BinaryArchive</span><span class="o">::</span><span class="n">WriteObject</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">ON_BinaryArchive</span><span class="o">::</span><span class="n">ReadObjectUserData</span><span class="p">(</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="n">ON_BinaryArchive</span><span class="o">::</span><span class="n">WriteObjectUserData</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Object</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_UserData</span><span class="p">;</span>
  <span class="n">ON_UserData</span><span class="o">*</span> <span class="n">m_userdata_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_object_history.h.html" class="btn btn-neutral float-right" title="File opennurbs_object_history.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_object.h.html" class="btn btn-neutral float-left" title="File opennurbs_object.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>