

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_texture_mapping.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_torus.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_torus.h.html" />
    <link rel="prev" title="File opennurbs_texture_mapping.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_texture_mapping.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_texture_mapping.h.html">File opennurbs_texture_mapping.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_texture_mapping.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_texture_mapping.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-texture-mapping-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-texture-mapping-h"></span><h1>Program Listing for File opennurbs_texture_mapping.h<a class="headerlink" href="#program-listing-for-file-opennurbs-texture-mapping-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_texture_mapping.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-texture-mapping-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_texture_mapping.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="c1">////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">//   defines ON_TextureMapping</span>
<span class="c1">//</span>
<span class="c1">////////////////////////////////////////////////////////////////</span>

<span class="cp">#if !defined(OPENNURBS_TEXTURE_MAPPING_INC_)</span>
<span class="cp">#define OPENNURBS_TEXTURE_MAPPING_INC_</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// Class ON_TextureMapping</span>
<span class="c1">//</span>
<span class="k">class</span> <span class="nc">ON_Line</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_BrepFace</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ON_3dPoint</span><span class="p">;</span>

<span class="k">typedef</span> <span class="nf">int</span>  <span class="p">(</span> <span class="o">*</span><span class="n">TEXMAP_INTERSECT_LINE_SURFACE</span> <span class="p">)(</span> <span class="k">const</span> <span class="n">ON_Line</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_BrepFace</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_X_EVENT</span><span class="o">&gt;&amp;</span> <span class="p">);</span>
<span class="k">typedef</span> <span class="nf">bool</span> <span class="p">(</span> <span class="o">*</span><span class="n">TEXMAP_BREP_FACE_CLOSEST_POINT</span> <span class="p">)(</span> <span class="k">const</span> <span class="n">ON_BrepFace</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span><span class="p">,</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="p">);</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_TextureMapping</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Object</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_TextureMapping</span><span class="p">);</span>

  <span class="n">ON_TextureMapping</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_TextureMapping</span><span class="p">();</span>

  <span class="c1">// The copy constructor and operator= overrides are needed</span>
  <span class="c1">// to ensure m_geometry is properly copied.</span>
  <span class="n">ON_TextureMapping</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_TextureMapping</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>
  <span class="n">ON_TextureMapping</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_TextureMapping</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>

  <span class="c1">// overrides virtual ON_Object::IsValid</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virtual ON_Object::Dump</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virtual ON_Object::SizeOf</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virtual ON_Object::Write</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span>
         <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span>
       <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides virtual ON_Object::Read</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span>
         <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="n">binary_archive</span>
       <span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Default</span><span class="p">();</span>

  <span class="k">virtual</span>
  <span class="n">ON_UUID</span> <span class="nf">ModelObjectId</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Determines whether the mapping, as currently set up, requires vertex normals to be present on the</span>
<span class="cm">  mesh in order to evaluate the mapping correctly.</span>
<span class="cm">    */</span>
  <span class="kt">bool</span> <span class="nf">RequiresVertexNormals</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsPeriodic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a mapping that will convert surface parameters into</span>
<span class="cm">    normalized (0,1)x(0,1) texture coordinates.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetSurfaceParameterMapping</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a planar projection texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plane - [in]</span>
<span class="cm">    dx - [in]  portion of the plane&#39;s x axis that is mapped to [0,1]</span>
<span class="cm">               (can be a decreasing interval)</span>
<span class="cm">    dy - [in]  portion of the plane&#39;s x axis that is mapped to [0,1]</span>
<span class="cm">               (can be a decreasing interval)</span>
<span class="cm">    dz - [in]  portion of the plane&#39;s x axis that is mapped to [0,1]</span>
<span class="cm">               (can be a decreasing interval)</span>
<span class="cm">    projection_method - [in]</span>
<span class="cm">        1: Closest point mapping.</span>
<span class="cm">          A target point P is mapped to the point on the plane</span>
<span class="cm">          that is closest to P.  The target normal is ignored.</span>
<span class="cm">        2: Target line mapping.  A target point-vector pair</span>
<span class="cm">          (P, N), are mapped to the point on the plane</span>
<span class="cm">          where the line through P, parallel to N, intersects</span>
<span class="cm">          the plane.  If the line is parallel to the plane,</span>
<span class="cm">          the closest point mapping is used.</span>
<span class="cm">  Example:</span>
<span class="cm">    Create a mapping that maps the world axis aligned rectangle in</span>
<span class="cm">    the world yz plane with corners at (0,3,5) and (0,7,19) to the</span>
<span class="cm">    texture coordinate unit square.</span>

<span class="cm">          ON_3dVector plane_xaxis(0.0,1.0,0.0);</span>
<span class="cm">          ON_3dVector plane_yaxis(0.0,0,0,1.0);</span>
<span class="cm">          ON_3dPoint plane_origin(0.0,2.0,4.0);</span>
<span class="cm">          ON_Plane plane(plane_origin,plane_xaxis,plane_yaxis);</span>
<span class="cm">          ON_Interval dx( 0.0, 7.0 - 3.0);</span>
<span class="cm">          ON_Interval dy( 0.0, 19.0 - 5.0);</span>
<span class="cm">          ON_Interval dz( 0.0, 1.0 );</span>
<span class="cm">          ON_TextureMapping mapping;</span>
<span class="cm">          mapping.CreatePlaneMapping(plane,dx,dy,dz);</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if input is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetPlaneMapping</span><span class="p">(</span>
            <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dx</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dy</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dz</span>
            <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a cylindrical projection texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    cylinder - [in]</span>
<span class="cm">        cylinder in world space used to define a cylindrical</span>
<span class="cm">        coordinate system.  The angular parameter maps (0,2pi)</span>
<span class="cm">        to texture &quot;u&quot; (0,1), The height parameter maps</span>
<span class="cm">        (height[0],height[1]) to texture &quot;v&quot; (0,1), and</span>
<span class="cm">        the radial parameter maps (0,r) to texture &quot;w&quot; (0,1).</span>
<span class="cm">    bIsCapped - [in]</span>
<span class="cm">        If true, the cylinder is treated as a finite</span>
<span class="cm">        capped cylinder.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if input is valid.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    When the cylinder is capped and m_texture_space = divided,</span>
<span class="cm">    the cylinder is mapped to texture space as follows:</span>
<span class="cm">      The side is mapped to 0 &lt;= &quot;u&quot; &lt;= 2/3.</span>
<span class="cm">      The bottom is mapped to 2/3 &lt;= &quot;u&quot; &lt;= 5/6.</span>
<span class="cm">      The top is mapped to 5/6 &lt;= &quot;u&quot; &lt;= 5/6.</span>
<span class="cm">    This is the same convention box mapping uses.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetCylinderMapping</span><span class="p">(</span>
     <span class="k">const</span> <span class="n">ON_Cylinder</span><span class="o">&amp;</span> <span class="n">cylinder</span><span class="p">,</span>
     <span class="kt">bool</span> <span class="n">bIsCapped</span>
  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a spherical projection texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sphere - [in]</span>
<span class="cm">        sphere in world space used to define a spherical</span>
<span class="cm">        coordinate system. The longitude parameter maps</span>
<span class="cm">        (0,2pi) to texture &quot;u&quot; (0,1).  The latitude paramter</span>
<span class="cm">        maps (-pi/2,+pi/2) to texture &quot;v&quot; (0,1).</span>
<span class="cm">        The radial parameter maps (0,r) to texture &quot;w&quot; (0,1).</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if input is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetSphereMapping</span><span class="p">(</span>
     <span class="k">const</span> <span class="n">ON_Sphere</span><span class="o">&amp;</span> <span class="n">sphere</span>
  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a box projection texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plane - [in]</span>
<span class="cm">        The sides of the box the box are parallel to the</span>
<span class="cm">        plane&#39;s coordinate planes.  The dx, dy, dz intervals</span>
<span class="cm">        determine the location of the sides.</span>
<span class="cm">    dx - [in]</span>
<span class="cm">       Determines the location of the front and back planes.</span>
<span class="cm">       The vector plane.xaxis is perpendicular to these planes</span>
<span class="cm">       and they pass through plane.PointAt(dx[0],0,0) and</span>
<span class="cm">       plane.PointAt(dx[1],0,0), respectivly.</span>
<span class="cm">    dy - [in]</span>
<span class="cm">       Determines the location of the left and right planes.</span>
<span class="cm">       The vector plane.yaxis is perpendicular to these planes</span>
<span class="cm">       and they pass through plane.PointAt(0,dy[0],0) and</span>
<span class="cm">       plane.PointAt(0,dy[1],0), respectivly.</span>
<span class="cm">    dz - [in]</span>
<span class="cm">       Determines the location of the top and bottom planes.</span>
<span class="cm">       The vector plane.zaxis is perpendicular to these planes</span>
<span class="cm">       and they pass through plane.PointAt(0,0,dz[0]) and</span>
<span class="cm">       plane.PointAt(0,0,dz[1]), respectivly.</span>
<span class="cm">    bIsCapped - [in]</span>
<span class="cm">        If true, the box is treated as a finite</span>
<span class="cm">        capped box.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if input is valid.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    When m_texture_space = divided, the box is mapped to texture</span>
<span class="cm">    space as follows:</span>

<span class="cm">    If the box is not capped, then each side maps to 1/4 of the texture map.</span>

<span class="cm">          v=1+---------+---------+---------+---------+</span>
<span class="cm">             | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] |</span>
<span class="cm">             | Front   | Right   | Back    | Left    |</span>
<span class="cm">             | --y-&gt;   | &lt;-x--   | &lt;-y--   | --x-&gt;   |</span>
<span class="cm">          v=0+---------+---------+---------+---------+</span>
<span class="cm">            0/4 &lt;=u&lt;= 1/4 &lt;=u&lt;= 2/4 &lt;=u&lt;= 3/4 &lt;=u&lt;= 4/4</span>

<span class="cm">    If the box is capped, then each side and cap gets 1/6 of the texture map.</span>

<span class="cm">          v=1+---------+---------+---------+---------+---------+---------+</span>
<span class="cm">             | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] | z=dx[1] | z=dz[0] |</span>
<span class="cm">             | Front   | Right   | Back    | Left    | Top     |  Bottom |</span>
<span class="cm">             | --y-&gt;   | &lt;-x--   | &lt;-y--   | --x-&gt;   | --x-&gt;   | --x-&gt;   |</span>
<span class="cm">          v=0+---------+---------+---------+---------+---------+---------+</span>
<span class="cm">            0/6 &lt;=u&lt;= 1/6 &lt;=u&lt;= 2/6 &lt;=u&lt;= 3/6 &lt;=u&lt;= 4/6 &lt;=u&lt;= 5/6 &lt;=u&lt;= 6/6</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetBoxMapping</span><span class="p">(</span>
     <span class="k">const</span> <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
     <span class="n">ON_Interval</span> <span class="n">dx</span><span class="p">,</span>
     <span class="n">ON_Interval</span> <span class="n">dy</span><span class="p">,</span>
     <span class="n">ON_Interval</span> <span class="n">dz</span><span class="p">,</span>
     <span class="kt">bool</span> <span class="n">bIsCapped</span>
  <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get plane mapping parameters from this texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    plane - [out]</span>
<span class="cm">    dx - [out]</span>
<span class="cm">      Portion of the plane&#39;s x axis that is mapped to [0,1]</span>
<span class="cm">    dy - [out]</span>
<span class="cm">      Portion of the plane&#39;s y axis that is mapped to [0,1]</span>
<span class="cm">    dz - [out]</span>
<span class="cm">      Portion of the plane&#39;s z axis that is mapped to [0,1]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if valid plane mapping parameters were returned.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    NOTE WELL:</span>
<span class="cm">      Generally, GetMappingPlane will not return the same</span>
<span class="cm">      parameters passed to SetPlaneMapping.  However, the</span>
<span class="cm">      location of the plane will be the same.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetMappingPlane</span><span class="p">(</span>
     <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
     <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dx</span><span class="p">,</span>
     <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dy</span><span class="p">,</span>
     <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dz</span>
     <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a cylindrical projection parameters from this texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    cylinder - [out]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a valid cylinder is returned.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Generally, GetMappingCylinder will not return the same</span>
<span class="cm">    parameters passed to SetCylinderMapping.  However, the</span>
<span class="cm">    location of the cylinder will be the same.</span>
<span class="cm">    If this mapping is not cylindrical, the cylinder will</span>
<span class="cm">    approximate the actual mapping primitive.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetMappingCylinder</span><span class="p">(</span>
     <span class="n">ON_Cylinder</span><span class="o">&amp;</span> <span class="n">cylinder</span>
  <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a spherical projection parameters from this texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    sphere - [out]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a valid sphere is returned.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Generally, GetMappingShere will not return the same</span>
<span class="cm">    parameters passed to SetSphereMapping.  However, the</span>
<span class="cm">    location of the sphere will be the same.</span>
<span class="cm">    If this mapping is not cylindrical, the cylinder will</span>
<span class="cm">    approximate the actual mapping primitive.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetMappingSphere</span><span class="p">(</span>
     <span class="n">ON_Sphere</span><span class="o">&amp;</span> <span class="n">sphere</span>
  <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Get a box projection from the texture mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">  plane - [out]</span>
<span class="cm">    The center of the box is at plane.origin and the sides</span>
<span class="cm">    of the box are parallel to the plane&#39;s coordinate planes.</span>
<span class="cm">  dx - [out]</span>
<span class="cm">     The &quot;front&quot; and &quot;back&quot; sides of the box are in spanned</span>
<span class="cm">     by the vectors plane.yaxis and plane.zaxis.  The back</span>
<span class="cm">     plane contains the point plane.PointAt(dx[0],0,0) and</span>
<span class="cm">     the front plane contains the point plane.PointAt(dx[1],0,0).</span>
<span class="cm">  dy - [out]</span>
<span class="cm">     The &quot;left&quot; and &quot;right&quot; sides of the box are in spanned</span>
<span class="cm">     by the vectors plane.zaxis and plane.xaxis.  The left</span>
<span class="cm">     plane contains the point plane.PointAt(0,dx[0],0) and</span>
<span class="cm">     the back plane contains the point plane.PointAt(0,dy[1],0).</span>
<span class="cm">  dz - [out]</span>
<span class="cm">     The &quot;top&quot; and &quot;bottom&quot; sides of the box are in spanned</span>
<span class="cm">     by the vectors plane.xaxis and plane.yaxis.  The bottom</span>
<span class="cm">     plane contains the point plane.PointAt(0,0,dz[0]) and</span>
<span class="cm">     the top plane contains the point plane.PointAt(0,0,dz[1]).</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if a valid box is returned.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Generally, GetMappingBox will not return the same</span>
<span class="cm">    parameters passed to SetBoxMapping.  However, the</span>
<span class="cm">    location of the box will be the same.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetMappingBox</span><span class="p">(</span>
     <span class="n">ON_Plane</span><span class="o">&amp;</span> <span class="n">plane</span><span class="p">,</span>
     <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dx</span><span class="p">,</span>
     <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dy</span><span class="p">,</span>
     <span class="n">ON_Interval</span><span class="o">&amp;</span> <span class="n">dz</span>
  <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Reverses the texture in the specified direction.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dir - [in] 0 = reverse &quot;u&quot;, 1 = reverse &quot;v&quot;, 2 = reverse &quot;w&quot;.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Modies m_uvw so that the spedified direction transforms</span>
<span class="cm">    the texture coordinate t to 1-t.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if input is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReverseTextureCoordinate</span><span class="p">(</span> <span class="kt">int</span> <span class="n">dir</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Swaps the specified texture coordinates.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    i - [in]</span>
<span class="cm">    j - [in]</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Modifies m_uvw so that the specified texture coordinates are swapped.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if input is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SwapTextureCoordinate</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tiles the specified texture coordinates.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dir - [in] 0 =  &quot;u&quot;, 1 = &quot;v&quot;, 2 = &quot;w&quot;.</span>
<span class="cm">    count - [in] number of tiles</span>
<span class="cm">    offset - [in] offset of the tile</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Modies m_uvw so that the specified texture coordinate is</span>
<span class="cm">    tiled.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if input is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TileTextureCoordinate</span><span class="p">(</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">double</span> <span class="n">count</span><span class="p">,</span> <span class="kt">double</span> <span class="n">offset</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Evaluate the mapping to get a texture coordinate.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    P - [in] Vertex location</span>
<span class="cm">    N - [in] If the mapping projection is ray_projection,</span>
<span class="cm">             then this is the vertex unit normal.  Otherwise</span>
<span class="cm">             N is ignored.</span>
<span class="cm">    T - [out] Texture coordinate (u,v,w)</span>

<span class="cm">    P_xform -[in]</span>
<span class="cm">      Transformation to be applied to P before performing</span>
<span class="cm">      the mapping calculation.</span>
<span class="cm">    N_xform - [in]</span>
<span class="cm">      Transformation to be applied to N before performing</span>
<span class="cm">      the mapping calculation.  One way to calculate N_xform</span>
<span class="cm">      is to use the call P_xform::GetVectorTransform(N_xform).</span>

<span class="cm">  Returns:</span>
<span class="cm">    Nonzero if evaluation is successful.  When the mapping</span>
<span class="cm">    is a box or capped cylinder mapping, the value indicates</span>
<span class="cm">    which side was evaluated.</span>

<span class="cm">      Cylinder mapping:</span>
<span class="cm">        1 = cylinder wall, 2 = bottom cap, 3 = top cap</span>
<span class="cm">      Box mapping:</span>
<span class="cm">        1 = front</span>
<span class="cm">        2 = right</span>
<span class="cm">        3 = back</span>
<span class="cm">        4 = left</span>
<span class="cm">        5 = bottom</span>
<span class="cm">        6 = top</span>

<span class="cm">  See Also:</span>
<span class="cm">    ON_TextureMapping::GetTextureCoordinates</span>
<span class="cm">    ON_Mesh::SetTextureCoordinates</span>
<span class="cm">  */</span>
  <span class="k">virtual</span>
  <span class="kt">int</span> <span class="nf">Evaluate</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">N</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">T</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">virtual</span>
  <span class="kt">int</span> <span class="nf">Evaluate</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">N</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">P_xform</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">N_xform</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">EvaluatePlaneMapping</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">N</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">T</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">EvaluateSphereMapping</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">N</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">T</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">EvaluateCylinderMapping</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">N</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">T</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">EvaluateBoxMapping</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">N</span><span class="p">,</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">T</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Quickly check to see if a mesh or tag has texture coordinates</span>
<span class="cm">    set by this mapping.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh - [in]</span>
<span class="cm">    tag - [in]</span>
<span class="cm">    object_xform - [in] (optional)</span>
<span class="cm">      If this transform is not NULL, then true will be</span>
<span class="cm">      returned only if the mapping function is the same and</span>
<span class="cm">      the tag&#39;s m_mesh_xform field is the same as mesh_xform.</span>
<span class="cm">      This parameter is typically NULL or the value of</span>
<span class="cm">      ON_MappingRef::m_object_xform.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the meshes texture coordinates were set by this</span>
<span class="cm">    mapping.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">HasMatchingTextureCoordinates</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">object_xform</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">HasMatchingTextureCoordinates</span><span class="p">(</span>
         <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_MappingTag</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">object_xform</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get texture coordinates.  This calculation is</span>
<span class="cm">    expensive.  When possible, use a MappingMatch()</span>
<span class="cm">    query to avoid unnecessary calculations.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh - [in]</span>
<span class="cm">    T - [out] Texture coordinates returned here.</span>
<span class="cm">    mesh_xform - [in] (optional)</span>
<span class="cm">      If the mesh has been transformed since the texture mapping was set</span>
<span class="cm">      up, pass the transformation here.  Typically this is the value</span>
<span class="cm">      of ON_Mesh::m_mapping_xform or ON_MappingRef::m_object_xform</span>
<span class="cm">    bLazy - [in]</span>
<span class="cm">      If true and the mesh.m_T[] values were calculated using</span>
<span class="cm">      this mapping, they are simply copied to the T[] array</span>
<span class="cm">      and no calculations are performed.  If you are calling</span>
<span class="cm">      the 3d point version and you care about the z-coordinate,</span>
<span class="cm">      then do not use the lazy option (meshes only store</span>
<span class="cm">      2d texture coordinates).</span>
<span class="cm">    Tside - [out]</span>
<span class="cm">      In the case of divided textures, side information is returned</span>
<span class="cm">      here if a lazy mapping is not done.  Otherwise Tside-&gt;Count()</span>
<span class="cm">      will be zero.</span>
<span class="cm">      Cylinder mapping:</span>
<span class="cm">        1 = cylinder wall, 2 = bottom cap, 3 = top cap</span>
<span class="cm">      Box mapping:</span>
<span class="cm">        1 = front</span>
<span class="cm">        2 = right</span>
<span class="cm">        3 = back</span>
<span class="cm">        4 = left</span>
<span class="cm">        5 = bottom</span>
<span class="cm">        6 = top</span>
<span class="cm">  Example:</span>

<span class="cm">          ON_TextureMapping mapping = ...;</span>
<span class="cm">          const ON_Mesh* mesh = ...;</span>
<span class="cm">          bool bLazy = true;</span>
<span class="cm">          ON_SimpleArray&lt;ON_3dPoint&gt; T(mesh-&gt;VertexCount());</span>
<span class="cm">          T.SetCount(mesh-&gt;m_VertexCount());</span>
<span class="cm">          if ( !mapping.GetTextureCoordinates(mesh,3,3,&amp;T[0].x,bLazy) )</span>
<span class="cm">            T.SetCount(0).</span>

<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetTextureCoordinates</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3fPoint</span><span class="o">&gt;&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">mesh_xform</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">Tside</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">GetTextureCoordinates</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2fPoint</span><span class="o">&gt;&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">mesh_xform</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">Tside</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="c1">// The only reliable and persistent way to reference texture</span>
  <span class="c1">// mappings is by the mapping_id.  If the mapping id is</span>
  <span class="c1">// set to m_srfp_mapping_id, then all other mapping settings</span>
  <span class="c1">// are ignored.</span>
  <span class="n">ON_UUID</span> <span class="n">m_mapping_id</span><span class="p">;</span>

  <span class="c1">// Runtime texture mapping table index.</span>
  <span class="c1">// This value is NOT SAVED IN 3DM FILES.</span>
  <span class="c1">// This value is constant for each runtime instance of Rhino,</span>
  <span class="c1">// but can change each time a model is loaded or saved.</span>
  <span class="c1">// Once a texture mapping is in the CRhinoDoc material table,</span>
  <span class="c1">// its id and index never change in that instance of Rhino.</span>
  <span class="kt">int</span> <span class="n">m_mapping_index</span><span class="p">;</span>

  <span class="c1">// The texture mapping name is for UI and user comfort.</span>
  <span class="c1">// Duplicates are permitted.</span>
  <span class="n">ON_wString</span> <span class="n">m_mapping_name</span><span class="p">;</span>

  <span class="c1">//////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Mapping types:</span>
  <span class="c1">//</span>
  <span class="c1">//   You can either calculate texture coordinates based on</span>
  <span class="c1">//   the parameterization of the surface used to create a mesh,</span>
  <span class="c1">//   or project the natural parameterization from a mapping</span>
  <span class="c1">//   primitive, like a plane, sphere, box, or cylinder.</span>
  <span class="c1">//</span>
  <span class="c1">// Do not change TYPE enum values - they are saved in 3dm files.</span>
  <span class="c1">//</span>
  <span class="k">enum</span> <span class="n">TYPE</span>
  <span class="p">{</span>
    <span class="n">no_mapping</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="n">srfp_mapping</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// u,v = linear transform of surface params,w = 0</span>
    <span class="n">plane_mapping</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// u,v,w = 3d coordinates wrt frame</span>
    <span class="n">cylinder_mapping</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// u,v,w = logitude, height, radius</span>
    <span class="n">sphere_mapping</span>   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">// (u,v,w) = longitude,latitude,radius</span>
    <span class="n">box_mapping</span>      <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">mesh_mapping_primitive</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="c1">// m_mapping_primitive is an ON_Mesh</span>
    <span class="n">srf_mapping_primitive</span>  <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="c1">// m_mapping_primitive is an ON_Surface</span>
    <span class="n">brep_mapping_primitive</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="c1">// m_mapping_primitive is an ON_Brep</span>

    <span class="n">force_32bit_mapping_type</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
  <span class="p">};</span>

  <span class="n">TYPE</span> <span class="n">m_type</span><span class="p">;</span>

  <span class="c1">//////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Projection:</span>
  <span class="c1">//</span>
  <span class="c1">//   When a mapping primitive, like a plane, sphere, box,</span>
  <span class="c1">//   or cylinder, is used, there are two projection options.</span>
  <span class="c1">//</span>
  <span class="c1">//  clspt_projection: world xyz maps to the point on the</span>
  <span class="c1">//                    mapping primitive that is closest to xyz.</span>
  <span class="c1">//                    In this case, ON_TextureMapping::Evaluate</span>
  <span class="c1">//                    ignores the vector argument.</span>
  <span class="c1">//</span>
  <span class="c1">//  ray_projection:   world xyz + world vector defines a world line.</span>
  <span class="c1">//                    The world line is intersected with the mapping</span>
  <span class="c1">//                    primitive and the intersection point that is</span>
  <span class="c1">//                    closest to the world xyz point is used to</span>
  <span class="c1">//                    calculate the mapping parameters.</span>
  <span class="c1">//</span>
  <span class="c1">//  The value of m_projection can be changed as needed.</span>
  <span class="c1">//</span>
  <span class="c1">//  If m_type = srfp_mapping, then m_projection is ignored.</span>
  <span class="c1">//</span>
  <span class="k">enum</span> <span class="n">PROJECTION</span>
  <span class="p">{</span>
    <span class="n">no_projection</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">clspt_projection</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">ray_projection</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">force_32bit_mapping_projection</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
  <span class="p">};</span>

  <span class="n">PROJECTION</span> <span class="n">m_projection</span><span class="p">;</span>

  <span class="c1">//////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Texture space</span>
  <span class="c1">//</span>
  <span class="c1">//   When a mapping primitive is a box or a capped cylinder,</span>
  <span class="c1">//   there are two options for the mapping.  Either the sides</span>
  <span class="c1">//   all map to (0,1)x(0,1) (so the either texture map appears</span>
  <span class="c1">//   on each side, or the sides map to distinct regions of the</span>
  <span class="c1">//   texture space.</span>
  <span class="c1">//</span>
  <span class="k">enum</span> <span class="n">TEXTURE_SPACE</span>
  <span class="p">{</span>
    <span class="n">single</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// sides and caps map to same texture space</span>
    <span class="n">divided</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// sides and caps map to distinct vertical</span>
                 <span class="c1">// regions of texture space.</span>
                 <span class="c1">// (0, 1/4, 2/4, 3/4, 1) for uncapped boxes.</span>
                 <span class="c1">// (0, 1/6, 2/6, 3/6, 4/6, 5/6, 1) for capped boxes.</span>
                 <span class="c1">// (0, 4/6, 5/6, 1) for capped cylinders.</span>
    <span class="n">force_32bit_texture_space</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>
  <span class="p">};</span>

  <span class="n">TEXTURE_SPACE</span> <span class="n">m_texture_space</span><span class="p">;</span>

  <span class="c1">// The m_bCapped applies to planar, cylinder and box mappings.</span>
  <span class="c1">// If m_bCapped is false, the cylinder or box is &quot;infinite&quot;, if m_bCapped is true, they are finite.</span>
  <span class="c1">// In planar mappings, m_bCapped=false means &quot;the Z texture coordinate will always be 0.0&quot;</span>
  <span class="c1">// this is now the default behaviour in Rhino 5.0 - it&#39;s what users expect apparently.</span>
  <span class="kt">bool</span> <span class="n">m_bCapped</span><span class="p">;</span>

  <span class="c1">//////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// For primitive based mappings, these transformations are</span>
  <span class="c1">// used to map the world coordinate (x,y,z) point P and</span>
  <span class="c1">// surface normal N before it is projected to the normalized</span>
  <span class="c1">// mapping primitive. The surface normal transformation,</span>
  <span class="c1">// m_Nxyz, is always calculated from m_Pxyz.  It is a</span>
  <span class="c1">// runtime setting that is not saved in 3dm files.</span>
  <span class="c1">// If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are</span>
  <span class="c1">// ignored.</span>
  <span class="n">ON_Xform</span> <span class="n">m_Pxyz</span><span class="p">;</span>
  <span class="n">ON_Xform</span> <span class="n">m_Nxyz</span><span class="p">;</span>

  <span class="c1">// Transform applied to mapping coordinate (u,v,w) to</span>
  <span class="c1">// convert it into a texture coordinate.</span>
  <span class="n">ON_Xform</span> <span class="n">m_uvw</span><span class="p">;</span>

  <span class="c1">// Custom mapping primitive.</span>
  <span class="n">ON_Object</span><span class="o">*</span> <span class="n">m_mapping_primitive</span><span class="p">;</span>

  <span class="k">static</span> <span class="n">TYPE</span> <span class="nf">TypeFromInt</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">);</span>
  <span class="k">static</span> <span class="n">PROJECTION</span> <span class="nf">ProjectionFromInt</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">);</span>
  <span class="k">static</span> <span class="n">TEXTURE_SPACE</span> <span class="nf">TextureSpaceFromInt</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

  <span class="n">ON__UINT32</span> <span class="nf">MappingCRC</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_TextureMapping</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ObjectArray</span><span class="o">&lt;</span><span class="n">ON_TextureMapping</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>


<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_torus.h.html" class="btn btn-neutral float-right" title="File opennurbs_torus.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_texture_mapping.h.html" class="btn btn-neutral float-left" title="File opennurbs_texture_mapping.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>