

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File sac_model.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File sac_model_1point_plane.h" href="file_E__pcl_docs_pcl_cuda_sample_consensus_include_pcl_cuda_sample_consensus_sac_model_1point_plane.h.html" />
    <link rel="prev" title="File sac_model.h" href="file_pcl_sample_consensus_sac_model.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_sample_consensus_sac_model.h.html">File sac_model.h</a> &raquo;</li>
        
      <li>Program Listing for File sac_model.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_sample_consensus_sac_model.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-sac-model-h">
<span id="program-listing-file-pcl-sample-consensus-sac-model-h"></span><h1>Program Listing for File sac_model.h<a class="headerlink" href="#program-listing-for-file-sac-model-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_sample_consensus_sac_model.h.html#file-pcl-sample-consensus-sac-model-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\sample_consensus\sac_model.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Software License Agreement (BSD License)</span>
<span class="cm"> *</span>
<span class="cm"> *  Point Cloud Library (PCL) - www.pointclouds.org</span>
<span class="cm"> *  Copyright (c) 2010-2011, Willow Garage, Inc.</span>
<span class="cm"> *  Copyright (c) 2012-, Open Perception, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above</span>
<span class="cm"> *     copyright notice, this list of conditions and the following</span>
<span class="cm"> *     disclaimer in the documentation and/or other materials provided</span>
<span class="cm"> *     with the distribution.</span>
<span class="cm"> *   * Neither the name of the copyright holder(s) nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="cm"> *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span>
<span class="cm"> *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="cm"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="cm"> *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<span class="cm"> *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> *  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> * $Id$</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;cfloat&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/console/print.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/point_cloud.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/sample_consensus/boost.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/sample_consensus/model_types.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/search/search.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">pcl</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">ProgressiveSampleConsensus</span><span class="p">;</span>

  <span class="cm">/** \brief @b SampleConsensusModel represents the base model class. All sample consensus models must inherit</span>
<span class="cm">    * from this class.</span>
<span class="cm">    * \author Radu B. Rusu</span>
<span class="cm">    * \ingroup sample_consensus</span>
<span class="cm">    */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">SampleConsensusModel</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="n">PointCloud</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">PointCloud</span><span class="o">::</span><span class="n">ConstPtr</span> <span class="n">PointCloudConstPtr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">PointCloud</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">PointCloudPtr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">search</span><span class="o">::</span><span class="n">Search</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">SearchPtr</span><span class="p">;</span>

      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SampleConsensusModel</span><span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">SampleConsensusModel</span><span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief Empty constructor for base SampleConsensusModel.</span>
<span class="cm">        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)</span>
<span class="cm">        */</span>
      <span class="n">SampleConsensusModel</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">random</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">input_</span> <span class="p">()</span>
        <span class="p">,</span> <span class="n">radius_min_</span> <span class="p">(</span><span class="o">-</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">())</span>
        <span class="p">,</span> <span class="n">radius_max_</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">())</span>
        <span class="p">,</span> <span class="n">samples_radius_</span> <span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">samples_radius_search_</span> <span class="p">()</span>
        <span class="p">,</span> <span class="n">rng_dist_</span> <span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">()))</span>
      <span class="p">{</span>
        <span class="c1">// Create a random number generator object</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">random</span><span class="p">)</span>
          <span class="n">rng_alg_</span><span class="p">.</span><span class="n">seed</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)));</span>
        <span class="k">else</span>
          <span class="n">rng_alg_</span><span class="p">.</span><span class="n">seed</span> <span class="p">(</span><span class="mi">12345u</span><span class="p">);</span>

        <span class="n">rng_gen_</span><span class="p">.</span><span class="n">reset</span> <span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="n">variate_generator</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mt19937</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">rng_alg_</span><span class="p">,</span> <span class="o">*</span><span class="n">rng_dist_</span><span class="p">));</span>
       <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="cm">/** \brief Constructor for base SampleConsensusModel.</span>
<span class="cm">        * \param[in] cloud the input point cloud dataset</span>
<span class="cm">        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)</span>
<span class="cm">        */</span>
      <span class="n">SampleConsensusModel</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointCloudConstPtr</span> <span class="o">&amp;</span><span class="n">cloud</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">random</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">input_</span> <span class="p">()</span>
        <span class="p">,</span> <span class="n">radius_min_</span> <span class="p">(</span><span class="o">-</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">())</span>
        <span class="p">,</span> <span class="n">radius_max_</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">())</span>
        <span class="p">,</span> <span class="n">samples_radius_</span> <span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">samples_radius_search_</span> <span class="p">()</span>
        <span class="p">,</span> <span class="n">rng_dist_</span> <span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">()))</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">random</span><span class="p">)</span>
          <span class="n">rng_alg_</span><span class="p">.</span><span class="n">seed</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">time</span> <span class="p">(</span><span class="k">nullptr</span><span class="p">)));</span>
        <span class="k">else</span>
          <span class="n">rng_alg_</span><span class="p">.</span><span class="n">seed</span> <span class="p">(</span><span class="mi">12345u</span><span class="p">);</span>

        <span class="c1">// Sets the input cloud and creates a vector of &quot;fake&quot; indices</span>
        <span class="n">setInputCloud</span> <span class="p">(</span><span class="n">cloud</span><span class="p">);</span>

        <span class="c1">// Create a random number generator object</span>
        <span class="n">rng_gen_</span><span class="p">.</span><span class="n">reset</span> <span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="n">variate_generator</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mt19937</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">rng_alg_</span><span class="p">,</span> <span class="o">*</span><span class="n">rng_dist_</span><span class="p">));</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Constructor for base SampleConsensusModel.</span>
<span class="cm">        * \param[in] cloud the input point cloud dataset</span>
<span class="cm">        * \param[in] indices a vector of point indices to be used from \a cloud</span>
<span class="cm">        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)</span>
<span class="cm">        */</span>
      <span class="n">SampleConsensusModel</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointCloudConstPtr</span> <span class="o">&amp;</span><span class="n">cloud</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span>
                            <span class="kt">bool</span> <span class="n">random</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">input_</span> <span class="p">(</span><span class="n">cloud</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">indices_</span> <span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">indices</span><span class="p">))</span>
        <span class="p">,</span> <span class="n">radius_min_</span> <span class="p">(</span><span class="o">-</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">())</span>
        <span class="p">,</span> <span class="n">radius_max_</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">())</span>
        <span class="p">,</span> <span class="n">samples_radius_</span> <span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">samples_radius_search_</span> <span class="p">()</span>
        <span class="p">,</span> <span class="n">rng_dist_</span> <span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span> <span class="p">()))</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">random</span><span class="p">)</span>
          <span class="n">rng_alg_</span><span class="p">.</span><span class="n">seed</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)));</span>
        <span class="k">else</span>
          <span class="n">rng_alg_</span><span class="p">.</span><span class="n">seed</span> <span class="p">(</span><span class="mi">12345u</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">indices_</span><span class="o">-&gt;</span><span class="n">size</span> <span class="p">()</span> <span class="o">&gt;</span> <span class="n">input_</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">size</span> <span class="p">())</span>
        <span class="p">{</span>
          <span class="n">PCL_ERROR</span> <span class="p">(</span><span class="s">&quot;[pcl::SampleConsensusModel] Invalid index vector given with size %lu while the input PointCloud has size %lu!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">indices_</span><span class="o">-&gt;</span><span class="n">size</span> <span class="p">(),</span> <span class="n">input_</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">size</span> <span class="p">());</span>
          <span class="n">indices_</span><span class="o">-&gt;</span><span class="n">clear</span> <span class="p">();</span>
        <span class="p">}</span>
        <span class="n">shuffled_indices_</span> <span class="o">=</span> <span class="o">*</span><span class="n">indices_</span><span class="p">;</span>

        <span class="c1">// Create a random number generator object</span>
        <span class="n">rng_gen_</span><span class="p">.</span><span class="n">reset</span> <span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="n">variate_generator</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mt19937</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">rng_alg_</span><span class="p">,</span> <span class="o">*</span><span class="n">rng_dist_</span><span class="p">));</span>
       <span class="p">};</span>

      <span class="cm">/** \brief Destructor for base SampleConsensusModel. */</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">SampleConsensusModel</span> <span class="p">()</span> <span class="p">{};</span>

      <span class="cm">/** \brief Get a set of random data samples and return them as point</span>
<span class="cm">        * indices.</span>
<span class="cm">        * \param[out] iterations the internal number of iterations used by SAC methods</span>
<span class="cm">        * \param[out] samples the resultant model samples</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">getSamples</span> <span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">iterations</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">samples</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// We&#39;re assuming that indices_ have already been set in the constructor</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">indices_</span><span class="o">-&gt;</span><span class="n">size</span> <span class="p">()</span> <span class="o">&lt;</span> <span class="n">getSampleSize</span> <span class="p">())</span>
        <span class="p">{</span>
          <span class="n">PCL_ERROR</span> <span class="p">(</span><span class="s">&quot;[pcl::SampleConsensusModel::getSamples] Can not select %lu unique points out of %lu!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                     <span class="n">samples</span><span class="p">.</span><span class="n">size</span> <span class="p">(),</span> <span class="n">indices_</span><span class="o">-&gt;</span><span class="n">size</span> <span class="p">());</span>
          <span class="c1">// one of these will make it stop :)</span>
          <span class="n">samples</span><span class="p">.</span><span class="n">clear</span> <span class="p">();</span>
          <span class="n">iterations</span> <span class="o">=</span> <span class="n">INT_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Get a second point which is different than the first</span>
        <span class="n">samples</span><span class="p">.</span><span class="n">resize</span> <span class="p">(</span><span class="n">getSampleSize</span> <span class="p">());</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">max_sample_checks_</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// Choose the random indices</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">samples_radius_</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">epsilon</span> <span class="p">())</span>
            <span class="n">SampleConsensusModel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">drawIndexSample</span> <span class="p">(</span><span class="n">samples</span><span class="p">);</span>
          <span class="k">else</span>
            <span class="n">SampleConsensusModel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">drawIndexSampleRadius</span> <span class="p">(</span><span class="n">samples</span><span class="p">);</span>

          <span class="c1">// If it&#39;s a good sample, stop here</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">isSampleGood</span> <span class="p">(</span><span class="n">samples</span><span class="p">))</span>
          <span class="p">{</span>
            <span class="n">PCL_DEBUG</span> <span class="p">(</span><span class="s">&quot;[pcl::SampleConsensusModel::getSamples] Selected %lu samples.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span> <span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">PCL_DEBUG</span> <span class="p">(</span><span class="s">&quot;[pcl::SampleConsensusModel::getSamples] WARNING: Could not select %d sample points in %d iterations!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getSampleSize</span> <span class="p">(),</span> <span class="n">max_sample_checks_</span><span class="p">);</span>
        <span class="n">samples</span><span class="p">.</span><span class="n">clear</span> <span class="p">();</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Check whether the given index samples can form a valid model,</span>
<span class="cm">        * compute the model coefficients from these samples and store them</span>
<span class="cm">        * in model_coefficients. Pure virtual.</span>
<span class="cm">        * \param[in] samples the point indices found as possible good candidates</span>
<span class="cm">        * for creating a valid model</span>
<span class="cm">        * \param[out] model_coefficients the computed model coefficients</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">bool</span>
      <span class="nf">computeModelCoefficients</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">samples</span><span class="p">,</span>
                                <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Recompute the model coefficients using the given inlier set</span>
<span class="cm">        * and return them to the user. Pure virtual.</span>
<span class="cm">        *</span>
<span class="cm">        * @note: these are the coefficients of the model after refinement</span>
<span class="cm">        * (e.g., after a least-squares optimization)</span>
<span class="cm">        *</span>
<span class="cm">        * \param[in] inliers the data inliers supporting the model</span>
<span class="cm">        * \param[in] model_coefficients the initial guess for the model coefficients</span>
<span class="cm">        * \param[out] optimized_coefficients the resultant recomputed coefficients after non-linear optimization</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">optimizeModelCoefficients</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">inliers</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">,</span>
                                 <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">optimized_coefficients</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Compute all distances from the cloud data to a given model. Pure virtual.</span>
<span class="cm">        *</span>
<span class="cm">        * \param[in] model_coefficients the coefficients of a model that we need to compute distances to</span>
<span class="cm">        * \param[out] distances the resultant estimated distances</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">getDistancesToModel</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">,</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">distances</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Select all the points which respect the given model</span>
<span class="cm">        * coefficients as inliers. Pure virtual.</span>
<span class="cm">        *</span>
<span class="cm">        * \param[in] model_coefficients the coefficients of a model that we need to compute distances to</span>
<span class="cm">        * \param[in] threshold a maximum admissible distance threshold for determining the inliers from</span>
<span class="cm">        * the outliers</span>
<span class="cm">        * \param[out] inliers the resultant model inliers</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">selectWithinDistance</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">,</span>
                            <span class="k">const</span> <span class="kt">double</span> <span class="n">threshold</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">inliers</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Count all the points which respect the given model</span>
<span class="cm">        * coefficients as inliers. Pure virtual.</span>
<span class="cm">        *</span>
<span class="cm">        * \param[in] model_coefficients the coefficients of a model that we need to</span>
<span class="cm">        * compute distances to</span>
<span class="cm">        * \param[in] threshold a maximum admissible distance threshold for</span>
<span class="cm">        * determining the inliers from the outliers</span>
<span class="cm">        * \return the resultant number of inliers</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">int</span>
      <span class="nf">countWithinDistance</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">,</span>
                           <span class="k">const</span> <span class="kt">double</span> <span class="n">threshold</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Create a new point cloud with inliers projected onto the model. Pure virtual.</span>
<span class="cm">        * \param[in] inliers the data inliers that we want to project on the model</span>
<span class="cm">        * \param[in] model_coefficients the coefficients of a model</span>
<span class="cm">        * \param[out] projected_points the resultant projected points</span>
<span class="cm">        * \param[in] copy_data_fields set to true (default) if we want the \a</span>
<span class="cm">        * projected_points cloud to be an exact copy of the input dataset minus</span>
<span class="cm">        * the point projections on the plane model</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">projectPoints</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">inliers</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">,</span>
                     <span class="n">PointCloud</span> <span class="o">&amp;</span><span class="n">projected_points</span><span class="p">,</span>
                     <span class="kt">bool</span> <span class="n">copy_data_fields</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Verify whether a subset of indices verifies a given set of</span>
<span class="cm">        * model coefficients. Pure virtual.</span>
<span class="cm">        *</span>
<span class="cm">        * \param[in] indices the data indices that need to be tested against the model</span>
<span class="cm">        * \param[in] model_coefficients the set of model coefficients</span>
<span class="cm">        * \param[in] threshold a maximum admissible distance threshold for</span>
<span class="cm">        * determining the inliers from the outliers</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">bool</span>
      <span class="nf">doSamplesVerifyModel</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">,</span>
                            <span class="k">const</span> <span class="kt">double</span> <span class="n">threshold</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Provide a pointer to the input dataset</span>
<span class="cm">        * \param[in] cloud the const boost shared pointer to a PointCloud message</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">setInputCloud</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointCloudConstPtr</span> <span class="o">&amp;</span><span class="n">cloud</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">input_</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">indices_</span><span class="p">)</span>
          <span class="n">indices_</span><span class="p">.</span><span class="n">reset</span> <span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">indices_</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="p">())</span>
        <span class="p">{</span>
          <span class="c1">// Prepare a set of indices to be used (entire cloud)</span>
          <span class="n">indices_</span><span class="o">-&gt;</span><span class="n">resize</span> <span class="p">(</span><span class="n">cloud</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">size</span> <span class="p">());</span>
          <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cloud</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">(</span><span class="o">*</span><span class="n">indices_</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">shuffled_indices_</span> <span class="o">=</span> <span class="o">*</span><span class="n">indices_</span><span class="p">;</span>
       <span class="p">}</span>

      <span class="cm">/** \brief Get a pointer to the input point cloud dataset. */</span>
      <span class="kr">inline</span> <span class="n">PointCloudConstPtr</span>
      <span class="nf">getInputCloud</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">input_</span><span class="p">);</span> <span class="p">}</span>

      <span class="cm">/** \brief Provide a pointer to the vector of indices that represents the input data.</span>
<span class="cm">        * \param[in] indices a pointer to the vector of indices that represents the input data.</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setIndices</span> <span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">indices_</span> <span class="o">=</span> <span class="n">indices</span><span class="p">;</span>
        <span class="n">shuffled_indices_</span> <span class="o">=</span> <span class="o">*</span><span class="n">indices_</span><span class="p">;</span>
       <span class="p">}</span>

      <span class="cm">/** \brief Provide the vector of indices that represents the input data.</span>
<span class="cm">        * \param[out] indices the vector of indices that represents the input data.</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="nf">setIndices</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">indices</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">indices_</span><span class="p">.</span><span class="n">reset</span> <span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">indices</span><span class="p">));</span>
        <span class="n">shuffled_indices_</span> <span class="o">=</span> <span class="n">indices</span><span class="p">;</span>
       <span class="p">}</span>

      <span class="cm">/** \brief Get a pointer to the vector of indices used. */</span>
      <span class="kr">inline</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span>
      <span class="n">getIndices</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">indices_</span><span class="p">);</span> <span class="p">}</span>

      <span class="cm">/** \brief Return an unique id for each type of model employed. */</span>
      <span class="k">virtual</span> <span class="n">SacModel</span>
      <span class="n">getModelType</span> <span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief Get a string representation of the name of this class. */</span>
      <span class="kr">inline</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>
      <span class="n">getClassName</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">model_name_</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Return the size of a sample from which the model is computed. */</span>
      <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
      <span class="n">getSampleSize</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="n">sample_size_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Return the number of coefficients in the model. */</span>
      <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
      <span class="n">getModelSize</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="n">model_size_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Set the minimum and maximum allowable radius limits for the</span>
<span class="cm">        * model (applicable to models that estimate a radius)</span>
<span class="cm">        * \param[in] min_radius the minimum radius model</span>
<span class="cm">        * \param[in] max_radius the maximum radius model</span>
<span class="cm">        * \todo change this to set limits on the entire model</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">setRadiusLimits</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">min_radius</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">max_radius</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">radius_min_</span> <span class="o">=</span> <span class="n">min_radius</span><span class="p">;</span>
        <span class="n">radius_max_</span> <span class="o">=</span> <span class="n">max_radius</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get the minimum and maximum allowable radius limits for the</span>
<span class="cm">        * model as set by the user.</span>
<span class="cm">        *</span>
<span class="cm">        * \param[out] min_radius the resultant minimum radius model</span>
<span class="cm">        * \param[out] max_radius the resultant maximum radius model</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">getRadiusLimits</span> <span class="p">(</span><span class="kt">double</span> <span class="o">&amp;</span><span class="n">min_radius</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">max_radius</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="n">min_radius</span> <span class="o">=</span> <span class="n">radius_min_</span><span class="p">;</span>
        <span class="n">max_radius</span> <span class="o">=</span> <span class="n">radius_max_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Set the maximum distance allowed when drawing random samples</span>
<span class="cm">        * \param[in] radius the maximum distance (L2 norm)</span>
<span class="cm">        * \param search</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">setSamplesMaxDist</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">radius</span><span class="p">,</span> <span class="n">SearchPtr</span> <span class="n">search</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">samples_radius_</span> <span class="o">=</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">samples_radius_search_</span> <span class="o">=</span> <span class="n">search</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get maximum distance allowed when drawing random samples</span>
<span class="cm">        *</span>
<span class="cm">        * \param[out] radius the maximum distance (L2 norm)</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">getSamplesMaxDist</span> <span class="p">(</span><span class="kt">double</span> <span class="o">&amp;</span><span class="n">radius</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">samples_radius_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">friend</span> <span class="k">class</span> <span class="nc">ProgressiveSampleConsensus</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">;</span>

      <span class="cm">/** \brief Compute the variance of the errors to the model.</span>
<span class="cm">        * \param[in] error_sqr_dists a vector holding the distances</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">double</span>
      <span class="nf">computeVariance</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">error_sqr_dists</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">dists</span> <span class="p">(</span><span class="n">error_sqr_dists</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">medIdx</span> <span class="o">=</span> <span class="n">dists</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">nth_element</span> <span class="p">(</span><span class="n">dists</span><span class="p">.</span><span class="n">begin</span> <span class="p">(),</span> <span class="n">dists</span><span class="p">.</span><span class="n">begin</span> <span class="p">()</span> <span class="o">+</span> <span class="n">medIdx</span><span class="p">,</span> <span class="n">dists</span><span class="p">.</span><span class="n">end</span> <span class="p">());</span>
        <span class="kt">double</span> <span class="n">median_error_sqr</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">medIdx</span><span class="p">];</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.1981</span> <span class="o">*</span> <span class="n">median_error_sqr</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Compute the variance of the errors to the model from the internally</span>
<span class="cm">        * estimated vector of distances. The model must be computed first (or at least</span>
<span class="cm">        * selectWithinDistance must be called).</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">double</span>
      <span class="nf">computeVariance</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error_sqr_dists_</span><span class="p">.</span><span class="n">empty</span> <span class="p">())</span>
        <span class="p">{</span>
          <span class="n">PCL_ERROR</span> <span class="p">(</span><span class="s">&quot;[pcl::SampleConsensusModel::computeVariance] The variance of the Sample Consensus model distances cannot be estimated, as the model has not been computed yet. Please compute the model first or at least run selectWithinDistance before continuing. Returning NAN!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">quiet_NaN</span> <span class="p">());</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">computeVariance</span> <span class="p">(</span><span class="n">error_sqr_dists_</span><span class="p">));</span>
      <span class="p">}</span>

    <span class="k">protected</span><span class="o">:</span>

      <span class="cm">/** \brief Fills a sample array with random samples from the indices_ vector</span>
<span class="cm">        * \param[out] sample the set of indices of target_ to analyze</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">drawIndexSample</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">sample_size</span> <span class="o">=</span> <span class="n">sample</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span>
        <span class="kt">size_t</span> <span class="n">index_size</span> <span class="o">=</span> <span class="n">shuffled_indices_</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sample_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
          <span class="c1">// The 1/(RAND_MAX+1.0) trick is when the random numbers are not uniformly distributed and for small modulo</span>
          <span class="c1">// elements, that does not matter (and nowadays, random number generators are good)</span>
          <span class="c1">//std::swap (shuffled_indices_[i], shuffled_indices_[i + (rand () % (index_size - i))]);</span>
          <span class="n">std</span><span class="o">::</span><span class="n">swap</span> <span class="p">(</span><span class="n">shuffled_indices_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shuffled_indices_</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">rnd</span> <span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">index_size</span> <span class="o">-</span> <span class="n">i</span><span class="p">))]);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">copy</span> <span class="p">(</span><span class="n">shuffled_indices_</span><span class="p">.</span><span class="n">begin</span> <span class="p">(),</span> <span class="n">shuffled_indices_</span><span class="p">.</span><span class="n">begin</span> <span class="p">()</span> <span class="o">+</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">sample</span><span class="p">.</span><span class="n">begin</span> <span class="p">());</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Fills a sample array with one random sample from the indices_ vector</span>
<span class="cm">        *        and other random samples that are closer than samples_radius_</span>
<span class="cm">        * \param[out] sample the set of indices of target_ to analyze</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">drawIndexSampleRadius</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sample</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">sample_size</span> <span class="o">=</span> <span class="n">sample</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span>
        <span class="kt">size_t</span> <span class="n">index_size</span> <span class="o">=</span> <span class="n">shuffled_indices_</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="n">swap</span> <span class="p">(</span><span class="n">shuffled_indices_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shuffled_indices_</span><span class="p">[</span><span class="mi">0</span> <span class="o">+</span> <span class="p">(</span><span class="n">rnd</span> <span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">index_size</span> <span class="o">-</span> <span class="mi">0</span><span class="p">))]);</span>
        <span class="c1">//const PointT&amp; pt0 = (*input_)[shuffled_indices_[0]];</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sqr_dists</span><span class="p">;</span>

        <span class="c1">// If indices have been set when the search object was constructed,</span>
        <span class="c1">// radiusSearch() expects an index into the indices vector as its</span>
        <span class="c1">// first parameter. This can&#39;t be determined efficiently, so we use</span>
        <span class="c1">// the point instead of the index.</span>
        <span class="c1">// Returned indices are converted automatically.</span>
        <span class="n">samples_radius_search_</span><span class="o">-&gt;</span><span class="n">radiusSearch</span> <span class="p">(</span><span class="n">input_</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">shuffled_indices_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                              <span class="n">samples_radius_</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">sqr_dists</span> <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">&lt;</span> <span class="n">sample_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// radius search failed, make an invalid model</span>
          <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sample_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">shuffled_indices_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shuffled_indices_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sample_size</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">rnd</span> <span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">-</span> <span class="n">i</span><span class="p">))]);</span>
          <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sample_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">shuffled_indices_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">copy</span> <span class="p">(</span><span class="n">shuffled_indices_</span><span class="p">.</span><span class="n">begin</span> <span class="p">(),</span> <span class="n">shuffled_indices_</span><span class="p">.</span><span class="n">begin</span> <span class="p">()</span> <span class="o">+</span> <span class="n">sample_size</span><span class="p">,</span> <span class="n">sample</span><span class="p">.</span><span class="n">begin</span> <span class="p">());</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Check whether a model is valid given the user constraints.</span>
<span class="cm">        *</span>
<span class="cm">        * Default implementation verifies that the number of coefficients in the supplied model is as expected for this</span>
<span class="cm">        * SAC model type. Specific SAC models should extend this function by checking the user constraints (if any).</span>
<span class="cm">        *</span>
<span class="cm">        * \param[in] model_coefficients the set of model coefficients</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">bool</span>
      <span class="n">isModelValid</span> <span class="p">(</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="o">&amp;</span><span class="n">model_coefficients</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">model_coefficients</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">!=</span> <span class="n">model_size_</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">PCL_ERROR</span> <span class="p">(</span><span class="s">&quot;[pcl::%s::isModelValid] Invalid number of model coefficients given (%lu)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getClassName</span> <span class="p">().</span><span class="n">c_str</span> <span class="p">(),</span> <span class="n">model_coefficients</span><span class="p">.</span><span class="n">size</span> <span class="p">());</span>
          <span class="k">return</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Check if a sample of indices results in a good sample of points</span>
<span class="cm">        * indices. Pure virtual.</span>
<span class="cm">        * \param[in] samples the resultant index samples</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">bool</span>
      <span class="n">isSampleGood</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">samples</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="cm">/** \brief The model name. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">model_name_</span><span class="p">;</span>

      <span class="cm">/** \brief A boost shared pointer to the point cloud data array. */</span>
      <span class="n">PointCloudConstPtr</span> <span class="n">input_</span><span class="p">;</span>

      <span class="cm">/** \brief A pointer to the vector of point indices to use. */</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">indices_</span><span class="p">;</span>

      <span class="cm">/** The maximum number of samples to try until we get a good one */</span>
      <span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sample_checks_</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

      <span class="cm">/** \brief The minimum and maximum radius limits for the model.</span>
<span class="cm">        * Applicable to all models that estimate a radius.</span>
<span class="cm">        */</span>
      <span class="kt">double</span> <span class="n">radius_min_</span><span class="p">,</span> <span class="n">radius_max_</span><span class="p">;</span>

      <span class="cm">/** \brief The maximum distance of subsequent samples from the first (radius search) */</span>
      <span class="kt">double</span> <span class="n">samples_radius_</span><span class="p">;</span>

      <span class="cm">/** \brief The search object for picking subsequent samples using radius search */</span>
      <span class="n">SearchPtr</span> <span class="n">samples_radius_search_</span><span class="p">;</span>

      <span class="cm">/** Data containing a shuffled version of the indices. This is used and modified when drawing samples. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shuffled_indices_</span><span class="p">;</span>

      <span class="cm">/** \brief Boost-based random number generator algorithm. */</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng_alg_</span><span class="p">;</span>

      <span class="cm">/** \brief Boost-based random number generator distribution. */</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span> <span class="n">rng_dist_</span><span class="p">;</span>

      <span class="cm">/** \brief Boost-based random number generator. */</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">variate_generator</span><span class="o">&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">mt19937</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">uniform_int</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">rng_gen_</span><span class="p">;</span>

      <span class="cm">/** \brief A vector holding the distances to the computed model. Used internally. */</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">error_sqr_dists_</span><span class="p">;</span>

      <span class="cm">/** \brief The size of a sample from which the model is computed. Every subclass should initialize this appropriately. */</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sample_size_</span><span class="p">;</span>

      <span class="cm">/** \brief The number of coefficients in the model. Every subclass should initialize this appropriately. */</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">model_size_</span><span class="p">;</span>

      <span class="cm">/** \brief Boost-based random number generator. */</span>
      <span class="kr">inline</span> <span class="kt">int</span>
      <span class="nf">rnd</span> <span class="p">()</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="p">((</span><span class="o">*</span><span class="n">rng_gen_</span><span class="p">)</span> <span class="p">());</span>
      <span class="p">}</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>
 <span class="p">};</span>

  <span class="cm">/** \brief @b SampleConsensusModelFromNormals represents the base model class</span>
<span class="cm">    * for models that require the use of surface normals for estimation.</span>
<span class="cm">    */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">PointNT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">SampleConsensusModelFromNormals</span> <span class="c1">//: public SampleConsensusModel&lt;PointT&gt;</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointNT</span><span class="o">&gt;::</span><span class="n">ConstPtr</span> <span class="n">PointCloudNConstPtr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointNT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">PointCloudNPtr</span><span class="p">;</span>

      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SampleConsensusModelFromNormals</span><span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">SampleConsensusModelFromNormals</span><span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Empty constructor for base SampleConsensusModelFromNormals. */</span>
      <span class="n">SampleConsensusModelFromNormals</span> <span class="p">()</span> <span class="o">:</span> <span class="n">normal_distance_weight_</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">normals_</span> <span class="p">()</span> <span class="p">{};</span>

      <span class="cm">/** \brief Destructor. */</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">SampleConsensusModelFromNormals</span> <span class="p">()</span> <span class="p">{}</span>

      <span class="cm">/** \brief Set the normal angular distance weight.</span>
<span class="cm">        * \param[in] w the relative weight (between 0 and 1) to give to the angular</span>
<span class="cm">        * distance (0 to pi/2) between point normals and the plane normal.</span>
<span class="cm">        * (The Euclidean distance will have weight 1-w.)</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">setNormalDistanceWeight</span> <span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">w</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">normal_distance_weight_</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get the normal angular distance weight. */</span>
      <span class="kr">inline</span> <span class="kt">double</span>
      <span class="n">getNormalDistanceWeight</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">normal_distance_weight_</span><span class="p">);</span> <span class="p">}</span>

      <span class="cm">/** \brief Provide a pointer to the input dataset that contains the point</span>
<span class="cm">        * normals of the XYZ dataset.</span>
<span class="cm">        *</span>
<span class="cm">        * \param[in] normals the const boost shared pointer to a PointCloud message</span>
<span class="cm">        */</span>
      <span class="kr">inline</span> <span class="kt">void</span>
      <span class="n">setInputNormals</span> <span class="p">(</span><span class="k">const</span> <span class="n">PointCloudNConstPtr</span> <span class="o">&amp;</span><span class="n">normals</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">normals_</span> <span class="o">=</span> <span class="n">normals</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Get a pointer to the normals of the input XYZ point cloud dataset. */</span>
      <span class="kr">inline</span> <span class="n">PointCloudNConstPtr</span>
      <span class="n">getInputNormals</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">normals_</span><span class="p">);</span> <span class="p">}</span>

    <span class="k">protected</span><span class="o">:</span>
      <span class="cm">/** \brief The relative weight (between 0 and 1) to give to the angular</span>
<span class="cm">        * distance (0 to pi/2) between point normals and the plane normal.</span>
<span class="cm">        */</span>
      <span class="kt">double</span> <span class="n">normal_distance_weight_</span><span class="p">;</span>

      <span class="cm">/** \brief A pointer to the input dataset that contains the point normals</span>
<span class="cm">        * of the XYZ dataset.</span>
<span class="cm">        */</span>
      <span class="n">PointCloudNConstPtr</span> <span class="n">normals_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="cm">/** Base functor all the models that need non linear optimization must</span>
<span class="cm">    * define their own one and implement operator() (const Eigen::VectorXd&amp; x, Eigen::VectorXd&amp; fvec)</span>
<span class="cm">    * or operator() (const Eigen::VectorXf&amp; x, Eigen::VectorXf&amp; fvec) depending on the chosen _Scalar</span>
<span class="cm">    */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Scalar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">NX</span><span class="o">=</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">NY</span><span class="o">=</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">Functor</span>
  <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">_Scalar</span> <span class="n">Scalar</span><span class="p">;</span>
    <span class="k">enum</span>
    <span class="p">{</span>
      <span class="n">InputsAtCompileTime</span> <span class="o">=</span> <span class="n">NX</span><span class="p">,</span>
      <span class="n">ValuesAtCompileTime</span> <span class="o">=</span> <span class="n">NY</span>
    <span class="p">};</span>

    <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">ValuesAtCompileTime</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">InputsAtCompileTime</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">InputType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">,</span><span class="n">ValuesAtCompileTime</span><span class="p">,</span><span class="n">InputsAtCompileTime</span><span class="o">&gt;</span> <span class="n">JacobianType</span><span class="p">;</span>

    <span class="cm">/** \brief Empty Constructor. */</span>
    <span class="n">Functor</span> <span class="p">()</span> <span class="o">:</span> <span class="n">m_data_points_</span> <span class="p">(</span><span class="n">ValuesAtCompileTime</span><span class="p">)</span> <span class="p">{}</span>

    <span class="cm">/** \brief Constructor</span>
<span class="cm">      * \param[in] m_data_points number of data points to evaluate.</span>
<span class="cm">      */</span>
    <span class="n">Functor</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m_data_points</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_data_points_</span> <span class="p">(</span><span class="n">m_data_points</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">Functor</span> <span class="p">()</span> <span class="p">{}</span>

    <span class="cm">/** \brief Get the number of values. */</span>
    <span class="kt">int</span>
    <span class="n">values</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">m_data_points_</span><span class="p">);</span> <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">m_data_points_</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_E__pcl_docs_pcl_cuda_sample_consensus_include_pcl_cuda_sample_consensus_sac_model_1point_plane.h.html" class="btn btn-neutral float-right" title="File sac_model_1point_plane.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_sample_consensus_sac_model.h.html" class="btn btn-neutral float-left" title="File sac_model.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>