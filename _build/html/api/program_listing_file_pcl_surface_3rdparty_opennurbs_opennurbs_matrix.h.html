

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_matrix.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_memory.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_memory.h.html" />
    <link rel="prev" title="File opennurbs_matrix.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_matrix.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_matrix.h.html">File opennurbs_matrix.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_matrix.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_matrix.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-matrix-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-matrix-h"></span><h1>Program Listing for File opennurbs_matrix.h<a class="headerlink" href="#program-listing-for-file-opennurbs-matrix-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_matrix.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-matrix-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_matrix.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="cp">#if !defined(ON_MATRIX_INC_)</span>
<span class="cp">#define ON_MATRIX_INC_</span>

<span class="k">class</span> <span class="nc">ON_Xform</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_Matrix</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_Matrix</span><span class="p">();</span>
  <span class="n">ON_Matrix</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row_count</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col_count</span>
     <span class="p">);</span>
  <span class="n">ON_Matrix</span><span class="p">(</span> <span class="c1">// see ON_Matrix::Create(int,int,int,int) for details</span>
     <span class="kt">int</span><span class="p">,</span> <span class="c1">// first valid row index</span>
     <span class="kt">int</span><span class="p">,</span> <span class="c1">// last valid row index</span>
     <span class="kt">int</span><span class="p">,</span> <span class="c1">// first valid column index</span>
     <span class="kt">int</span>  <span class="c1">// last valid column index</span>
     <span class="p">);</span>
  <span class="n">ON_Matrix</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_Matrix</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    This constructor is for experts who have storage for a matrix</span>
<span class="cm">    and need to use it in ON_Matrix form.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    row_count - [in]</span>
<span class="cm">    col_count - [in]</span>
<span class="cm">    M - [in]</span>
<span class="cm">    bDestructorFreeM - [in]</span>
<span class="cm">      If true, ~ON_Matrix will call onfree(M).</span>
<span class="cm">      If false, caller is managing M&#39;s memory.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    ON_Matrix functions that increase the value of row_count or col_count</span>
<span class="cm">    will fail on a matrix created with this constructor.</span>
<span class="cm">  */</span>
  <span class="n">ON_Matrix</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row_count</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col_count</span><span class="p">,</span>
    <span class="kt">double</span><span class="o">**</span> <span class="n">M</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bDestructorFreeM</span>
    <span class="p">);</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">ON_Matrix</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span> <span class="c1">// call if memory pool used matrix by becomes invalid</span>

  <span class="c1">// ON_Matrix[i][j] = value at row i and column j</span>
  <span class="c1">//           0 &lt;= i &lt; RowCount()</span>
  <span class="c1">//           0 &lt;= j &lt; ColCount()</span>
  <span class="kt">double</span><span class="o">*</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">IsSquare</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// returns 0 for no and m_row_count (= m_col_count) for yes</span>
  <span class="kt">int</span> <span class="nf">RowCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">ColCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">MinCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// smallest of row and column count</span>
  <span class="kt">int</span> <span class="nf">MaxCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// largest of row and column count</span>

  <span class="kt">void</span> <span class="nf">RowScale</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">ColScale</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">RowOp</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">ColOp</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span>
     <span class="kt">int</span><span class="p">,</span> <span class="c1">// number of rows</span>
     <span class="kt">int</span>  <span class="c1">// number of columns</span>
     <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span> <span class="o">//</span> <span class="n">E</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span> <span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="n">creates</span> <span class="n">a</span> <span class="mi">5</span><span class="n">x7</span> <span class="n">sized</span> <span class="n">matrix</span> <span class="n">that</span> <span class="n">with</span>
               <span class="c1">// &quot;top&quot; row = m[1][1],...,m[1][7] and &quot;bottom&quot; row</span>
               <span class="c1">// = m[5][1],...,m[5][7].  The result of Create(0,m,0,n) is</span>
               <span class="c1">// identical to the result of Create(m+1,n+1).</span>
     <span class="kt">int</span><span class="p">,</span> <span class="c1">// first valid row index</span>
     <span class="kt">int</span><span class="p">,</span> <span class="c1">// last valid row index</span>
     <span class="kt">int</span><span class="p">,</span> <span class="c1">// first valid column index</span>
     <span class="kt">int</span>  <span class="c1">// last valid column index</span>
     <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    This constructor is for experts who have storage for a matrix</span>
<span class="cm">    and need to use it in ON_Matrix form.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    row_count - [in]</span>
<span class="cm">    col_count - [in]</span>
<span class="cm">    M - [in]</span>
<span class="cm">    bDestructorFreeM - [in]</span>
<span class="cm">      If true, ~ON_Matrix will call onfree(M).</span>
<span class="cm">      If false, caller is managing M&#39;s memory.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    ON_Matrix functions that increase the value of row_count or col_count</span>
<span class="cm">    will fail on a matrix created with this constructor.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">row_count</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">col_count</span><span class="p">,</span>
    <span class="kt">double</span><span class="o">**</span> <span class="n">M</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bDestructorFreeM</span>
    <span class="p">);</span>


  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>

  <span class="kt">void</span> <span class="nf">Zero</span><span class="p">();</span>

  <span class="kt">void</span> <span class="nf">SetDiagonal</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span> <span class="c1">// sets diagonal value and zeros off diagonal values</span>
  <span class="kt">void</span> <span class="nf">SetDiagonal</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">);</span> <span class="c1">// sets diagonal values and zeros off diagonal values</span>
  <span class="kt">void</span> <span class="nf">SetDiagonal</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">);</span> <span class="c1">// sets size to count x count and diagonal values and zeros off diagonal values</span>
  <span class="kt">void</span> <span class="nf">SetDiagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// sets size to length X lengthdiagonal values and zeros off diagonal values</span>

  <span class="kt">bool</span> <span class="nf">Transpose</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">SwapRows</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span> <span class="c1">// ints are row indices to swap</span>
  <span class="kt">bool</span> <span class="nf">SwapCols</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span> <span class="c1">// ints are col indices to swap</span>
  <span class="kt">bool</span> <span class="nf">Invert</span><span class="p">(</span>
          <span class="kt">double</span> <span class="c1">// zero tolerance</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set this = A*B.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    A - [in]</span>
<span class="cm">      (Can be this)</span>
<span class="cm">    B - [in]</span>
<span class="cm">      (Can be this)</span>
<span class="cm">  Returns:</span>
<span class="cm">    True when A is an mXk matrix and B is a k X n matrix; in which case</span>
<span class="cm">    &quot;this&quot; will be an mXn matrix = A*B.</span>
<span class="cm">    False when A.ColCount() != B.RowCount().</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Multiply</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="n">B</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set this = A+B.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    A - [in]</span>
<span class="cm">      (Can be this)</span>
<span class="cm">    B - [in]</span>
<span class="cm">      (Can be this)</span>
<span class="cm">  Returns:</span>
<span class="cm">    True when A and B are mXn matrices; in which case</span>
<span class="cm">    &quot;this&quot; will be an mXn matrix = A+B.</span>
<span class="cm">    False when A and B have different sizes.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Add</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_Matrix</span><span class="o">&amp;</span> <span class="n">B</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set this = s*this.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    s - [in]</span>
<span class="cm">  Returns:</span>
<span class="cm">    True when A and s are valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Scale</span><span class="p">(</span> <span class="kt">double</span> <span class="n">s</span> <span class="p">);</span>


  <span class="c1">// Description:</span>
  <span class="c1">//   Row reduce a matrix to calculate rank and determinant.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   zero_tolerance - [in] (&gt;=0.0) zero tolerance for pivot test</span>
  <span class="c1">//       If the absolute value of a pivot is &lt;= zero_tolerance,</span>
  <span class="c1">//       then the pivot is assumed to be zero.</span>
  <span class="c1">//   determinant - [out] value of determinant is returned here.</span>
  <span class="c1">//   pivot - [out] value of the smallest pivot is returned here</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Rank of the matrix.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   The matrix itself is row reduced so that the result is</span>
  <span class="c1">//   an upper triangular matrix with 1&#39;s on the diagonal.</span>
  <span class="kt">int</span> <span class="nf">RowReduce</span><span class="p">(</span> <span class="c1">// returns rank</span>
    <span class="kt">double</span><span class="p">,</span>  <span class="c1">// zero_tolerance</span>
    <span class="kt">double</span><span class="o">&amp;</span><span class="p">,</span> <span class="c1">// determinant</span>
    <span class="kt">double</span><span class="o">&amp;</span>  <span class="c1">// pivot</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Row reduce a matrix as the first step in solving M*X=B where</span>
  <span class="c1">//   B is a column of values.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   zero_tolerance - [in] (&gt;=0.0) zero tolerance for pivot test</span>
  <span class="c1">//       If the absolute value of a pivot is &lt;= zero_tolerance,</span>
  <span class="c1">//       then the pivot is assumed to be zero.</span>
  <span class="c1">//   B - [in/out] an array of m_row_count values that is row reduced</span>
  <span class="c1">//       with the matrix.</span>
  <span class="c1">//   determinant - [out] value of determinant is returned here.</span>
  <span class="c1">//   pivot - [out] If not NULL, then the value of the smallest</span>
  <span class="c1">//       pivot is returned here</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Rank of the matrix.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   The matrix itself is row reduced so that the result is</span>
  <span class="c1">//   an upper triangular matrix with 1&#39;s on the diagonal.</span>
  <span class="c1">// Example:</span>
  <span class="c1">//   Solve M*X=B;</span>
  <span class="c1">//   double B[m] = ...;</span>
  <span class="c1">//   double B[n] = ...;</span>
  <span class="c1">//   ON_Matrix M(m,n) = ...;</span>
  <span class="c1">//   M.RowReduce(ON_ZERO_TOLERANCE,B); // modifies M and B</span>
  <span class="c1">//   M.BackSolve(m,B,X); // solution is in X</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Matrix::BackSolve</span>
  <span class="kt">int</span> <span class="nf">RowReduce</span><span class="p">(</span>
    <span class="kt">double</span><span class="p">,</span>        <span class="c1">// zero_tolerance</span>
    <span class="kt">double</span><span class="o">*</span><span class="p">,</span>       <span class="c1">// B</span>
    <span class="kt">double</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="c1">// pivot</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Row reduce a matrix as the first step in solving M*X=B where</span>
  <span class="c1">//   B is a column of 3d points</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   zero_tolerance - [in] (&gt;=0.0) zero tolerance for pivot test</span>
  <span class="c1">//       If the absolute value of a pivot is &lt;= zero_tolerance,</span>
  <span class="c1">//       then the pivot is assumed to be zero.</span>
  <span class="c1">//   B - [in/out] an array of m_row_count 3d points that is</span>
  <span class="c1">//       row reduced with the matrix.</span>
  <span class="c1">//   determinant - [out] value of determinant is returned here.</span>
  <span class="c1">//   pivot - [out] If not NULL, then the value of the smallest</span>
  <span class="c1">//       pivot is returned here</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Rank of the matrix.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   The matrix itself is row reduced so that the result is</span>
  <span class="c1">//   an upper triangular matrix with 1&#39;s on the diagonal.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Matrix::BackSolve</span>
  <span class="kt">int</span> <span class="nf">RowReduce</span><span class="p">(</span>
    <span class="kt">double</span><span class="p">,</span>        <span class="c1">// zero_tolerance</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span><span class="p">,</span>   <span class="c1">// B</span>
    <span class="kt">double</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="c1">// pivot</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Row reduce a matrix as the first step in solving M*X=B where</span>
  <span class="c1">//   B is a column arbitrary dimension points.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   zero_tolerance - [in] (&gt;=0.0) zero tolerance for pivot test</span>
  <span class="c1">//       If a the absolute value of a pivot is &lt;= zero_tolerance,</span>
  <span class="c1">//       then the pivoit is assumed to be zero.</span>
  <span class="c1">//   pt_dim - [in] dimension of points</span>
  <span class="c1">//   pt_stride - [in] stride between points (&gt;=pt_dim)</span>
  <span class="c1">//   pt - [in/out] array of m_row_count*pt_stride values.</span>
  <span class="c1">//        The i-th point is</span>
  <span class="c1">//        (pt[i*pt_stride],...,pt[i*pt_stride+pt_dim-1]).</span>
  <span class="c1">//        This array of points is row reduced along with the</span>
  <span class="c1">//        matrix.</span>
  <span class="c1">//   pivot - [out] If not NULL, then the value of the smallest</span>
  <span class="c1">//       pivot is returned here</span>
  <span class="c1">// Returns:</span>
  <span class="c1">//   Rank of the matrix.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   The matrix itself is row reduced so that the result is</span>
  <span class="c1">//   an upper triangular matrix with 1&#39;s on the diagonal.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Matrix::BackSolve</span>
  <span class="kt">int</span> <span class="nf">RowReduce</span><span class="p">(</span> <span class="c1">// returns rank</span>
    <span class="kt">double</span><span class="p">,</span>      <span class="c1">// zero_tolerance</span>
    <span class="kt">int</span><span class="p">,</span>         <span class="c1">// pt_dim</span>
    <span class="kt">int</span><span class="p">,</span>         <span class="c1">// pt_stride</span>
    <span class="kt">double</span><span class="o">*</span><span class="p">,</span>     <span class="c1">// pt</span>
    <span class="kt">double</span><span class="o">*</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="c1">// pivot</span>
    <span class="p">);</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Solve M*X=B where M is upper triangular with a unit diagonal and</span>
  <span class="c1">//   B is a column of values.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   zero_tolerance - [in] (&gt;=0.0) used to test for &quot;zero&quot; values in B</span>
  <span class="c1">//       in under determined systems of equations.</span>
  <span class="c1">//   Bsize - [in] (&gt;=m_row_count) length of B.  The values in</span>
  <span class="c1">//       B[m_row_count],...,B[Bsize-1] are tested to make sure they are</span>
  <span class="c1">//       &quot;zero&quot;.</span>
  <span class="c1">//   B - [in] array of length Bsize.</span>
  <span class="c1">//   X - [out] array of length m_col_count.  Solutions returned here.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   Actual values M[i][j] with i &lt;= j are ignored.</span>
  <span class="c1">//   M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.</span>
  <span class="c1">//   For square M, B and X can point to the same memory.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Matrix::RowReduce</span>
  <span class="kt">bool</span> <span class="nf">BackSolve</span><span class="p">(</span>
    <span class="kt">double</span><span class="p">,</span>        <span class="c1">// zero_tolerance</span>
    <span class="kt">int</span><span class="p">,</span>           <span class="c1">// Bsize</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span> <span class="c1">// B</span>
    <span class="kt">double</span><span class="o">*</span>        <span class="c1">// X</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Solve M*X=B where M is upper triangular with a unit diagonal and</span>
  <span class="c1">//   B is a column of 3d points.</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   zero_tolerance - [in] (&gt;=0.0) used to test for &quot;zero&quot; values in B</span>
  <span class="c1">//       in under determined systems of equations.</span>
  <span class="c1">//   Bsize - [in] (&gt;=m_row_count) length of B.  The values in</span>
  <span class="c1">//       B[m_row_count],...,B[Bsize-1] are tested to make sure they are</span>
  <span class="c1">//       &quot;zero&quot;.</span>
  <span class="c1">//   B - [in] array of length Bsize.</span>
  <span class="c1">//   X - [out] array of length m_col_count.  Solutions returned here.</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   Actual values M[i][j] with i &lt;= j are ignored.</span>
  <span class="c1">//   M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.</span>
  <span class="c1">//   For square M, B and X can point to the same memory.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Matrix::RowReduce</span>
  <span class="kt">bool</span> <span class="nf">BackSolve</span><span class="p">(</span>
    <span class="kt">double</span><span class="p">,</span>            <span class="c1">// zero_tolerance</span>
    <span class="kt">int</span><span class="p">,</span>               <span class="c1">// Bsize</span>
    <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span><span class="p">,</span> <span class="c1">// B</span>
    <span class="n">ON_3dPoint</span><span class="o">*</span>        <span class="c1">// X</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Solve M*X=B where M is upper triangular with a unit diagonal and</span>
  <span class="c1">//   B is a column of points</span>
  <span class="c1">// Parameters:</span>
  <span class="c1">//   zero_tolerance - [in] (&gt;=0.0) used to test for &quot;zero&quot; values in B</span>
  <span class="c1">//       in under determined systems of equations.</span>
  <span class="c1">//   pt_dim - [in] dimension of points</span>
  <span class="c1">//   Bsize - [in] (&gt;=m_row_count) number of points in B[].  The points</span>
  <span class="c1">//       correspoinding to indices m_row_count, ..., (Bsize-1)</span>
  <span class="c1">//       are tested to make sure they are &quot;zero&quot;.</span>
  <span class="c1">//   Bpt_stride - [in] stride between B points (&gt;=pt_dim)</span>
  <span class="c1">//   Bpt - [in/out] array of m_row_count*Bpt_stride values.</span>
  <span class="c1">//        The i-th B point is</span>
  <span class="c1">//        (Bpt[i*Bpt_stride],...,Bpt[i*Bpt_stride+pt_dim-1]).</span>
  <span class="c1">//   Xpt_stride - [in] stride between X points (&gt;=pt_dim)</span>
  <span class="c1">//   Xpt - [out] array of m_col_count*Xpt_stride values.</span>
  <span class="c1">//        The i-th X point is</span>
  <span class="c1">//        (Xpt[i*Xpt_stride],...,Xpt[i*Xpt_stride+pt_dim-1]).</span>
  <span class="c1">// Remarks:</span>
  <span class="c1">//   Actual values M[i][j] with i &lt;= j are ignored.</span>
  <span class="c1">//   M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.</span>
  <span class="c1">//   For square M, B and X can point to the same memory.</span>
  <span class="c1">// See Also:</span>
  <span class="c1">//   ON_Matrix::RowReduce</span>
  <span class="kt">bool</span> <span class="nf">BackSolve</span><span class="p">(</span>
    <span class="kt">double</span><span class="p">,</span>       <span class="c1">// zero_tolerance</span>
    <span class="kt">int</span><span class="p">,</span>          <span class="c1">// pt_dim</span>
    <span class="kt">int</span><span class="p">,</span>          <span class="c1">// Bsize</span>
    <span class="kt">int</span><span class="p">,</span>          <span class="c1">// Bpt_stride</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span><span class="p">,</span><span class="c1">// Bpt</span>
    <span class="kt">int</span><span class="p">,</span>          <span class="c1">// Xpt_stride</span>
    <span class="kt">double</span><span class="o">*</span>       <span class="c1">// Xpt</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">IsRowOrthoganal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsRowOrthoNormal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">IsColOrthoganal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsColOrthoNormal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>


  <span class="kt">double</span><span class="o">**</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// m[i][j] = value at row i and column j</span>
              <span class="c1">//           0 &lt;= i &lt; RowCount()</span>
              <span class="c1">//           0 &lt;= j &lt; ColCount()</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">m_row_count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_col_count</span><span class="p">;</span>
  <span class="c1">// m_rowmem[i][j] = row i+m_row_offset and column j+m_col_offset.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">*&gt;</span> <span class="n">m_rowmem</span><span class="p">;</span>
  <span class="kt">double</span><span class="o">**</span> <span class="n">m_Mmem</span><span class="p">;</span> <span class="c1">// used by Create(row_count,col_count,user_memory,true);</span>
  <span class="kt">int</span>   <span class="n">m_row_offset</span><span class="p">;</span> <span class="c1">// = ri0 when sub-matrix constructor is used</span>
  <span class="kt">int</span>   <span class="n">m_col_offset</span><span class="p">;</span> <span class="c1">// = ci0 when sub-matrix constructor is used</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">m_cmem</span><span class="p">;</span>
  <span class="c1">// returns 0 based arrays, even in submatrix case.</span>
  <span class="kt">double</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="nf">ThisM</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">double</span> <span class="o">*</span> <span class="o">*</span> <span class="nf">ThisM</span><span class="p">();</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Calculate the singular value decomposition of a matrix.</span>

<span class="cm">Parameters:</span>
<span class="cm">  row_count - [in]</span>
<span class="cm">    number of rows in matrix A</span>
<span class="cm">  col_count - [in]</span>
<span class="cm">    number of columns in matrix A</span>
<span class="cm">  A - [in]</span>
<span class="cm">    Matrix for which you want the singular value decomposition.</span>
<span class="cm">    A[0][0] = coefficeint in the first row and first column.</span>
<span class="cm">    A[row_count-1][col_count-1] = coefficeint in the last row</span>
<span class="cm">    and last column.</span>
<span class="cm">  U - [out]</span>
<span class="cm">    The singular value decomposition of A is U*Diag(W)*Transpose(V),</span>
<span class="cm">    where U has the same size as A, Diag(W) is a col_count X col_count</span>
<span class="cm">    diagonal matrix with (W[0],...,W[col_count-1]) on the diagonal</span>
<span class="cm">    and V is a col_count X col_count matrix.</span>
<span class="cm">    U and A may be the same pointer.  If the input value of U is</span>
<span class="cm">    null, heap storage will be allocated using onmalloc()</span>
<span class="cm">    and the calling function must call onfree(U).  If the input</span>
<span class="cm">    value of U is not null, U[i] must point to an array of col_count</span>
<span class="cm">    doubles.</span>
<span class="cm">  W - [out]</span>
<span class="cm">    If the input value W is null, then heap storage will be allocated</span>
<span class="cm">    using onmalloc() and the calling function must call onfree(W).</span>
<span class="cm">    If the input value of W is not null, then W must point to</span>
<span class="cm">    an array of col_count doubles.</span>
<span class="cm">  V - [out]</span>
<span class="cm">    If the input value V is null, then heap storage will be allocated</span>
<span class="cm">    using onmalloc() and the calling function must call onfree(V).</span>
<span class="cm">    If the input value of V is not null, then V[i] must point</span>
<span class="cm">    to an array of col_count doubles.</span>

<span class="cm">Example:</span>

<span class="cm">          int m = row_count;</span>
<span class="cm">          int n = col_count;</span>
<span class="cm">          ON_Matrix A(m,n);</span>
<span class="cm">          for (i = 0; i &lt; m; i++ ) for ( j = 0; j &lt; n; j++ )</span>
<span class="cm">          {</span>
<span class="cm">            A[i][j] = ...;</span>
<span class="cm">          }</span>
<span class="cm">          ON_Matrix U(m,n);</span>
<span class="cm">          double* W = 0; // ON_GetMatrixSVD() will allocate W</span>
<span class="cm">          ON_Matrix V(n,n);</span>
<span class="cm">          bool rc = ON_GetMatrixSVD(m,n,A.m,U.m,W,V.m);</span>
<span class="cm">          ...</span>
<span class="cm">          onfree(W); // W allocated in ON_GetMatrixSVD()</span>

<span class="cm">Returns:</span>
<span class="cm">  True if the singular value decomposition was cacluated.</span>
<span class="cm">  False if the algorithm failed to converge.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_GetMatrixSVD</span><span class="p">(</span>
  <span class="kt">int</span> <span class="n">row_count</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">col_count</span><span class="p">,</span>
  <span class="kt">double</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">A</span><span class="p">,</span>
  <span class="kt">double</span><span class="o">**&amp;</span> <span class="n">U</span><span class="p">,</span>
  <span class="kt">double</span><span class="o">*&amp;</span> <span class="n">W</span><span class="p">,</span>
  <span class="kt">double</span><span class="o">**&amp;</span> <span class="n">V</span>
  <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Invert the diagonal matrix in a the singular value decomposition.</span>
<span class="cm">Parameters:</span>
<span class="cm">  count - [in] number of elements in W</span>
<span class="cm">  W - [in]</span>
<span class="cm">    diagonal values in the singular value decomposition.</span>
<span class="cm">  invW - [out]</span>
<span class="cm">    The inverted diagonal is returned here.  invW may be the same</span>
<span class="cm">    pointer as W.  If the input value of invW is not null, it must</span>
<span class="cm">    point to an array of count doubles.  If the input value of</span>
<span class="cm">    invW is null, heap storage will be allocated using onmalloc()</span>
<span class="cm">    and the calling function must call onfree(invW).</span>
<span class="cm">Remarks:</span>
<span class="cm">  If the singular value decomposition were mathematically perfect, then</span>
<span class="cm">  this function would be:</span>
<span class="cm">    for (i = 0; i &lt; count; i++)</span>
<span class="cm">      invW[i] = (W[i] != 0.0) ? 1.0/W[i] : 0.0;</span>
<span class="cm">  Because the double precision arithmetic is not mathematically perfect,</span>
<span class="cm">  very small values of W[i] may well be zero and this function makes</span>
<span class="cm">  a reasonable guess as to when W[i] should be treated as zero.</span>
<span class="cm">Returns:</span>
<span class="cm">  Number of non-zero elements in invW, which, in a mathematically perfect</span>
<span class="cm">  situation, is the rank of Diag(W).</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_InvertSVDW</span><span class="p">(</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">W</span><span class="p">,</span>
  <span class="kt">double</span><span class="o">*&amp;</span> <span class="n">invW</span>
  <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Solve a linear system of equations using the singular value decomposition.</span>
<span class="cm">Parameters:</span>
<span class="cm">  row_count - [in]</span>
<span class="cm">    number of rows in matrix U</span>
<span class="cm">  col_count - [in]</span>
<span class="cm">    number of columns in matrix U</span>
<span class="cm">  U - [in]</span>
<span class="cm">    row_count X col_count matix.</span>
<span class="cm">    See the remarks section for the definition of U.</span>
<span class="cm">  invW - [in]</span>
<span class="cm">    inverted DVD diagonal.</span>
<span class="cm">    See the remarks section for the definition of invW.</span>
<span class="cm">  V - [in]</span>
<span class="cm">    col_count X col_count matrix.</span>
<span class="cm">    See the remarks section for the definition of V.</span>
<span class="cm">  B - [in]</span>
<span class="cm">    An array of row_count values.</span>
<span class="cm">  X - [out]</span>
<span class="cm">    The solution array of col_count values is returned here.</span>
<span class="cm">    If the input value of X is not null, it must point to an</span>
<span class="cm">    array of col_count doubles.  If the input value of X is</span>
<span class="cm">    null, heap storage will be allocated using onmalloc() and</span>
<span class="cm">    the calling function must call onfree(X).</span>
<span class="cm">Remarks:</span>
<span class="cm">  If A*X = B is an m X n system of equations (m = row_count, n = col_count)</span>
<span class="cm">  and A = U*Diag(W)*Transpose(V) is the singular value decompostion of A,</span>
<span class="cm">  then a solution is X = V*Diag(1/W)*Transpose(U).</span>
<span class="cm">Example:</span>

<span class="cm">          int m = row_count;</span>
<span class="cm">          int n = col_count;</span>
<span class="cm">          ON_Matrix A(m,n);</span>
<span class="cm">          for (i = 0; i &lt; m; i++ ) for ( j = 0; j &lt; n; j++ )</span>
<span class="cm">          {</span>
<span class="cm">            A[i][j] = ...;</span>
<span class="cm">          }</span>
<span class="cm">          ON_SimpleArray&lt;double&gt; B(m);</span>
<span class="cm">          for (i = 0; i &lt; m; i++ )</span>
<span class="cm">          {</span>
<span class="cm">            B[i] = ...;</span>
<span class="cm">          }</span>

<span class="cm">          ON_SimpleArray&lt;double&gt; X; // solution returned here.</span>
<span class="cm">          {</span>
<span class="cm">            double** U = 0;</span>
<span class="cm">            double* W = 0;</span>
<span class="cm">            double** V = 0;</span>
<span class="cm">            if ( ON_GetMatrixSVD(m,n,A.m,U,W,V) )</span>
<span class="cm">            {</span>
<span class="cm">              double* invW = 0;</span>
<span class="cm">              int rankW = ON_InvertSVDW(n,W,W); // save invW into W</span>
<span class="cm">              X.Reserve(n);</span>
<span class="cm">              if ( ON_SolveSVD(m,n,U,W,V,B,X.Array()) )</span>
<span class="cm">                X.SetCount(n);</span>
<span class="cm">            }</span>
<span class="cm">            onfree(U); // U allocated in ON_GetMatrixSVD()</span>
<span class="cm">            onfree(W); // W allocated in ON_GetMatrixSVD()</span>
<span class="cm">            onfree(V); // V allocated in ON_GetMatrixSVD()</span>
<span class="cm">          }</span>

<span class="cm">          if ( n == X.Count() )</span>
<span class="cm">          {</span>
<span class="cm">            ... use solution</span>
<span class="cm">          }</span>
<span class="cm">Returns:</span>
<span class="cm">  True if input is valid and X[] was calculated.</span>
<span class="cm">  False if input is not valid.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_SolveSVD</span><span class="p">(</span>
  <span class="kt">int</span> <span class="n">row_count</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">col_count</span><span class="p">,</span>
  <span class="kt">double</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">U</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">invW</span><span class="p">,</span>
  <span class="kt">double</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">V</span><span class="p">,</span>
  <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span>
  <span class="kt">double</span><span class="o">*&amp;</span> <span class="n">X</span>
  <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Perform simple row reduction on a matrix.  If A is square, positive</span>
<span class="cm">  definite, and really really nice, then the returned B is the inverse</span>
<span class="cm">  of A.  If A is not positive definite and really really nice, then it</span>
<span class="cm">  is probably a waste of time to call this function.</span>
<span class="cm">Parameters:</span>
<span class="cm">  row_count - [in]</span>
<span class="cm">  col_count - [in]</span>
<span class="cm">  zero_pivot - [in]</span>
<span class="cm">    absolute values &lt;= zero_pivot are considered to be zero</span>
<span class="cm">  A - [in/out]</span>
<span class="cm">    A row_count X col_count matrix.  Input is the matrix to be</span>
<span class="cm">    row reduced.  The calculation destroys A, so output A is garbage.</span>
<span class="cm">  B - [out]</span>
<span class="cm">    A a row_count X row_count matrix. That records the row reduction.</span>
<span class="cm">  pivots - [out]</span>
<span class="cm">    minimum and maximum absolute values of pivots.</span>
<span class="cm">Returns:</span>
<span class="cm">  Rank of A.  If the returned value &lt; min(row_count,col_count),</span>
<span class="cm">  then a zero pivot was encountered.</span>
<span class="cm">  If C = input value of A, then B*C = (I,*)</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">int</span> <span class="nf">ON_RowReduce</span><span class="p">(</span>
          <span class="kt">int</span> <span class="n">row_count</span><span class="p">,</span>
          <span class="kt">int</span> <span class="n">col_count</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">zero_pivot</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">**</span> <span class="n">A</span><span class="p">,</span>
          <span class="kt">double</span><span class="o">**</span> <span class="n">B</span><span class="p">,</span>
          <span class="kt">double</span> <span class="n">pivots</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
          <span class="p">);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_memory.h.html" class="btn btn-neutral float-right" title="File opennurbs_memory.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_matrix.h.html" class="btn btn-neutral float-left" title="File opennurbs_matrix.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>