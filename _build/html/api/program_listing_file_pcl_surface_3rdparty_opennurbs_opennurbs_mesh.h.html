

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File opennurbs_mesh.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File opennurbs_nurbscurve.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_nurbscurve.h.html" />
    <link rel="prev" title="File opennurbs_mesh.h" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_mesh.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_mesh.h.html">File opennurbs_mesh.h</a> &raquo;</li>
        
      <li>Program Listing for File opennurbs_mesh.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_surface_3rdparty_opennurbs_opennurbs_mesh.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-opennurbs-mesh-h">
<span id="program-listing-file-pcl-surface-3rdparty-opennurbs-opennurbs-mesh-h"></span><h1>Program Listing for File opennurbs_mesh.h<a class="headerlink" href="#program-listing-for-file-opennurbs-mesh-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_surface_3rdparty_opennurbs_opennurbs_mesh.h.html#file-pcl-surface-3rdparty-opennurbs-opennurbs-mesh-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\surface\3rdparty\opennurbs\opennurbs_mesh.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* $NoKeywords: $ */</span>
<span class="cm">/*</span>
<span class="cm">//</span>
<span class="cm">// Copyright (c) 1993-2012 Robert McNeel &amp; Associates. All rights reserved.</span>
<span class="cm">// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert</span>
<span class="cm">// McNeel &amp; Associates.</span>
<span class="cm">//</span>
<span class="cm">// THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; WITHOUT EXPRESS OR IMPLIED WARRANTY.</span>
<span class="cm">// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF</span>
<span class="cm">// MERCHANTABILITY ARE HEREBY DISCLAIMED.</span>
<span class="cm">//</span>
<span class="cm">// For complete openNURBS copyright information see &lt;http://www.opennurbs.org&gt;.</span>
<span class="cm">//</span>
<span class="cm">////////////////////////////////////////////////////////////////</span>
<span class="cm">*/</span>

<span class="cp">#if !defined(OPENNURBS_MESH_INC_)</span>
<span class="cp">#define OPENNURBS_MESH_INC_</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// Class  ON_Mesh</span>
<span class="c1">//</span>
<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_MeshParameters</span>
<span class="p">{</span>
  <span class="c1">// surface meshing perameters</span>
<span class="k">public</span><span class="o">:</span>

  <span class="k">enum</span> <span class="n">MESH_STYLE</span>
  <span class="p">{</span>
    <span class="c1">// All of these enum values must be in the range 0-255 because</span>
    <span class="c1">// unsigned chars are use for storage in some locations.</span>
    <span class="n">unset_mesh_style</span>      <span class="o">=</span>   <span class="mi">0</span><span class="p">,</span>
    <span class="n">render_mesh_fast</span>      <span class="o">=</span>   <span class="mi">1</span><span class="p">,</span> <span class="c1">// Use ON_MeshParameters::FastRenderMesh</span>
    <span class="n">render_mesh_quality</span>   <span class="o">=</span>   <span class="mi">2</span><span class="p">,</span> <span class="c1">// Use ON_MeshParameters::QualityRenderMesh</span>
    <span class="c1">// 3 - 8 reserved for future predefined render mesh styles</span>
    <span class="n">render_mesh_custom</span>    <span class="o">=</span>   <span class="mi">9</span><span class="p">,</span><span class="c1">// Use ON_3dmSettings::m_CustomRenderMeshSettings</span>
    <span class="n">render_mesh_per_object</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">// Use ON_Object::GetMeshParameters().</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Parameters that create render meshes where meshing</span>
<span class="cm">    speed is prefered over mesh quality.</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="k">const</span> <span class="n">ON_MeshParameters</span> <span class="n">FastRenderMesh</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Parameters that create render meshes where mesh quality</span>
<span class="cm">    is prefered over meshing speed.</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="k">const</span> <span class="n">ON_MeshParameters</span> <span class="n">QualityRenderMesh</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a value to use for tolerance based on the relative_tolerance</span>
<span class="cm">    and actual size.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    relative_tolerance - [in]</span>
<span class="cm">      See m_relative_tolerance field</span>
<span class="cm">    actual_size - [in]</span>
<span class="cm">      Diagonal ov object bounding box or some similar measure of</span>
<span class="cm">      an object&#39;s 3d size.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A value that can be used for m_tolerance if no</span>
<span class="cm">    user specified value is available.</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="kt">double</span> <span class="nf">Tolerance</span><span class="p">(</span> <span class="kt">double</span> <span class="n">relative_tolerance</span><span class="p">,</span> <span class="kt">double</span> <span class="n">actual_size</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a value to use for minimum edge length base on max_edge_length</span>
<span class="cm">    and tolerance settings.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    max_edge_length - [in]</span>
<span class="cm">      3d maximum edge length used to create mesh.</span>
<span class="cm">    tolerance - [in]</span>
<span class="cm">      3d distance tolerance used to create mesh.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A value that can be used for m_min_edge_length if no</span>
<span class="cm">    user specified value is available.</span>
<span class="cm">  */</span>
  <span class="k">static</span>
  <span class="kt">double</span> <span class="nf">MinEdgeLength</span><span class="p">(</span> <span class="kt">double</span> <span class="n">max_edge_length</span><span class="p">,</span> <span class="kt">double</span> <span class="n">tolerance</span> <span class="p">);</span>

  <span class="n">ON_MeshParameters</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshParameters</span><span class="p">();</span>
  <span class="c1">// C++ default works fine // ON_MeshParameters(const ON_MeshParameters&amp; );</span>
  <span class="c1">// C++ default works fine // ON_MeshParameters&amp; operator=(const ON_MeshParameters&amp;);</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshParameters</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshParameters</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// compares with mesh&#39;s mesh parameters</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="n">test_log</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Default</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tool for provding a simple slider interface.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    density - [in] 0.0 &lt;= density &lt;= 1.0</span>
<span class="cm">      0 quickly creates coarse meshes.</span>
<span class="cm">      1 creates accurate meshes but takes lots of time.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Set</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">density</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">min_edge_length</span> <span class="o">=</span> <span class="mf">0.0001</span>
    <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets the meshing parameters to ON_MeshParameters::FastRenderMesh.</span>
<span class="cm">  */</span>
  <span class="n">ON_DEPRECATED</span>
  <span class="kt">void</span> <span class="nf">JaggedAndFasterMeshParameters</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets the meshing parameters to ON_MeshParameters::QualityRenderMesh.</span>
<span class="cm">  */</span>
  <span class="n">ON_DEPRECATED</span>
  <span class="kt">void</span> <span class="nf">SmoothAndSlowerMeshParameters</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets the meshing parameters to create the default</span>
<span class="cm">    analysis mesh.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DefaultAnalysisMeshParameters</span><span class="p">();</span>

  <span class="c1">// Compare() ignores weld and curvature settings</span>
  <span class="c1">// Ignores m_min_tolerance setting.</span>
  <span class="kt">int</span> <span class="nf">Compare</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_MeshParameters</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Compares all meshing parameters that control mesh geometry.</span>
<span class="cm">    Does not compare m_bCustomSettings, m_bComputeCurvature,</span>
<span class="cm">    m_bDoublePrecision, m_min_tolerance, and m_texture_range.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">CompareGeometrySettings</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_MeshParameters</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON__UINT32</span> <span class="nf">DataCRC</span><span class="p">(</span><span class="n">ON__UINT32</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">// Meshing happens in two stages.  The first stage creates a</span>
  <span class="c1">// rectangular grid.  The second stage refines the grid until</span>
  <span class="c1">// the mesh meets all meshing requirements.  The third stage</span>
  <span class="c1">// combines coincident vertices if the resulting mesh is a composite.</span>

  <span class="kt">bool</span> <span class="n">m_bCustomSettings</span><span class="p">;</span>    <span class="c1">// false - if these settings were used to create</span>
                             <span class="c1">//         a mesh and the app settings don&#39;t match,</span>
                             <span class="c1">//         then remesh the object using the app</span>
                             <span class="c1">//         settings.</span>
                             <span class="c1">// true  - these settings are customized for a</span>
                             <span class="c1">//         particular object - ignore app mesh</span>
                             <span class="c1">//         settings.</span>

  <span class="kt">bool</span> <span class="n">m_bComputeCurvature</span><span class="p">;</span>  <span class="c1">// false - (default) - ON_Mesh::m_K[] not computed</span>
                             <span class="c1">// true  - ON_Mesh::m_K[] computed</span>

  <span class="kt">bool</span> <span class="n">m_bSimplePlanes</span><span class="p">;</span>      <span class="c1">// false - (default) planar surfaces are meshed</span>
                             <span class="c1">//          using the controls below.</span>
                             <span class="c1">// true   - planar surfaces are meshed using</span>
                             <span class="c1">//          minimal number of triangles and</span>
                             <span class="c1">//          aspect/edge controls are ignored.</span>

  <span class="kt">bool</span> <span class="n">m_bRefine</span><span class="p">;</span>            <span class="c1">// false - skip stage 2</span>
                             <span class="c1">// true  - (default) do stage 2</span>

  <span class="kt">bool</span> <span class="n">m_bJaggedSeams</span><span class="p">;</span>       <span class="c1">// false - (default) edges of meshes of joined</span>
                             <span class="c1">//          b-rep faces match with no gaps or</span>
                             <span class="c1">//          &quot;T&quot; joints.</span>
                             <span class="c1">// true   - faces in b-reps are meshed independently.</span>
                             <span class="c1">//          This is faster but results in gaps and</span>
                             <span class="c1">//          &quot;T&quot; joints along seams between faces.</span>

  <span class="kt">bool</span> <span class="n">m_bDoublePrecision</span><span class="p">;</span>   <span class="c1">// false - (default) the mesh vertices will be</span>
                             <span class="c1">//         float precision values in the m_V[] array.</span>
                             <span class="c1">// true -  The mesh vertices will be double precision</span>
                             <span class="c1">//         values in the DoublePrecisionVertices()</span>
                             <span class="c1">//         array.  Float precision values will also</span>
                             <span class="c1">//         be returned in the m_V[] array.</span>
  <span class="kt">bool</span> <span class="n">m_bCustomSettingsEnabled</span><span class="p">;</span> <span class="c1">// false - if these settings should be ignored</span>
                             <span class="c1">//         when used as per object custom render mesh</span>
                             <span class="c1">//         settings.</span>
                             <span class="c1">//  true - ignore these settings.</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">m_mesher</span><span class="p">;</span>    <span class="c1">// 0 = slow mesher, 1 = fast mesher</span>

  <span class="kt">int</span> <span class="n">m_texture_range</span><span class="p">;</span>       <span class="c1">// 1: normalized</span>
                             <span class="c1">//</span>
                             <span class="c1">//          each face has a normalized texture range</span>
                             <span class="c1">//          [0,1]x[0,1].</span>
                             <span class="c1">//</span>
                             <span class="c1">// 2: packed normalized (default)</span>
                             <span class="c1">//</span>
                             <span class="c1">//          each face in a polysurface is assigned</span>
                             <span class="c1">//          a texture range that is a subrectangle</span>
                             <span class="c1">//          of [0,1]x[0,1].  The subrectangles are</span>
                             <span class="c1">//          mutually disjoint and packed into</span>
                             <span class="c1">//          into [0,1]x[0,1] in a way that minimizes</span>
                             <span class="c1">//          distortion and maximizes the coverage</span>
                             <span class="c1">//          of [0,1]x[0,1].  (This texture style</span>
                             <span class="c1">//          is suitable for creating texture maps</span>
                             <span class="c1">//          with popular 3D painting programs.)</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_reserved2</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>

  <span class="c1">// These controls are used in both stages</span>

  <span class="kt">double</span> <span class="n">m_tolerance</span><span class="p">;</span> <span class="c1">// maximum distance from center of edge to surface</span>


  <span class="kt">double</span> <span class="n">m_relative_tolerance</span><span class="p">;</span> <span class="c1">// If 0 &lt; m_relative_tolerance &lt; 1,</span>
  <span class="kt">double</span> <span class="n">m_min_tolerance</span><span class="p">;</span>      <span class="c1">// then the maximum distance from the</span>
                               <span class="c1">// center of an edge to the surface will</span>
                               <span class="c1">// be &lt;= T, where T is the larger of</span>
                               <span class="c1">// (m_min_tolerance,d*m_relative_tolerance),</span>
                               <span class="c1">// where d is an esimate of the size of the</span>
                               <span class="c1">// object being meshed.</span>


  <span class="kt">double</span> <span class="n">m_min_edge_length</span><span class="p">;</span> <span class="c1">// edges shorter than m_min_edge_length will</span>
                            <span class="c1">// not be split even if the do not meet other</span>
                            <span class="c1">// meshing requirements</span>

  <span class="kt">double</span> <span class="n">m_max_edge_length</span><span class="p">;</span> <span class="c1">// edges longer than m_max_edge_length will</span>
                            <span class="c1">// be split even when they meet all other</span>
                            <span class="c1">// meshing requirements</span>

  <span class="c1">// These controls are used during stage 1 to generate the grid</span>
  <span class="kt">double</span> <span class="n">m_grid_aspect_ratio</span><span class="p">;</span>  <span class="c1">// desired aspect ratio of quads in grid</span>
                               <span class="c1">// 0.0 = any aspect ratio is acceptable</span>
                               <span class="c1">// values &gt;0 and &lt; sqrt(2) are treated as sqrt(2)</span>
  <span class="kt">int</span>    <span class="n">m_grid_min_count</span><span class="p">;</span>     <span class="c1">// minimum number of quads in initial grid</span>
  <span class="kt">int</span>    <span class="n">m_grid_max_count</span><span class="p">;</span>     <span class="c1">// desired masimum number of quads in initial grid</span>
  <span class="kt">double</span> <span class="n">m_grid_angle</span><span class="p">;</span>         <span class="c1">// (in radians) maximum angle between surface</span>
                               <span class="c1">// normal evaluated at adjacent vertices.</span>
                               <span class="c1">// 0.0 is treated as pi.</span>
  <span class="kt">double</span> <span class="n">m_grid_amplification</span><span class="p">;</span> <span class="c1">// The parameters above generate a grid.</span>
                               <span class="c1">// If you want fewer quads, set m_grid_amplification</span>
                               <span class="c1">// to a value &lt; 1.  If you want more quads,</span>
                               <span class="c1">// set m_grid_amplification to a value &gt; 1.</span>
                               <span class="c1">// default = 1 and values &lt;= 0 are treated as 1.</span>

  <span class="c1">// These controls are used during stage 2 to refine the grid</span>
  <span class="kt">double</span> <span class="n">m_refine_angle</span><span class="p">;</span>       <span class="c1">// (in radians) maximum angle in radians between</span>
                               <span class="c1">// surface normal evaluated at adjacent vertices.</span>

  <span class="c1">// These controls are used during stage 3</span>
  <span class="kt">int</span>     <span class="n">m_face_type</span><span class="p">;</span>         <span class="c1">// 0 = mixed triangle and quads</span>
                               <span class="c1">// 1 = all triangles</span>
                               <span class="c1">// 2 = all quads</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_reserved3</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_MeshCurvatureStats</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MeshCurvatureStats</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshCurvatureStats</span><span class="p">();</span>
  <span class="n">ON_MeshCurvatureStats</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshCurvatureStats</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_MeshCurvatureStats</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshCurvatureStats</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">Set</span><span class="p">(</span> <span class="n">ON</span><span class="o">::</span><span class="n">curvature_style</span><span class="p">,</span>
            <span class="kt">int</span><span class="p">,</span>           <span class="c1">// Kcount,</span>
            <span class="k">const</span> <span class="n">ON_SurfaceCurvature</span><span class="o">*</span><span class="p">,</span> <span class="c1">// K[]</span>
            <span class="k">const</span> <span class="n">ON_3fVector</span><span class="o">*</span><span class="p">,</span> <span class="c1">// N[] surface normals needed for normal sectional curvatures</span>
            <span class="kt">double</span> <span class="o">=</span> <span class="mf">0.0</span>   <span class="c1">// if &gt; 0, value is used for &quot;infinity&quot;</span>
            <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="n">ON</span><span class="o">::</span><span class="n">curvature_style</span> <span class="n">m_style</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">m_infinity</span><span class="p">;</span> <span class="c1">// curvature values &gt;= this are considered infinite</span>
                     <span class="c1">// and not used to compute the m_average or m_adev</span>
  <span class="kt">int</span>    <span class="n">m_count_infinite</span><span class="p">;</span> <span class="c1">// number of &quot;infinte&quot; values</span>
  <span class="kt">int</span>    <span class="n">m_count</span><span class="p">;</span>    <span class="c1">// count of &quot;finite&quot; values</span>
  <span class="kt">double</span> <span class="n">m_mode</span><span class="p">;</span>     <span class="c1">// mode of &quot;finite&quot; values</span>
  <span class="kt">double</span> <span class="n">m_average</span><span class="p">;</span>  <span class="c1">// average of &quot;finite&quot; values</span>
  <span class="kt">double</span> <span class="n">m_adev</span><span class="p">;</span>     <span class="c1">// average deviation of &quot;finite&quot; values</span>

  <span class="n">ON_Interval</span> <span class="n">m_range</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// Class  ON_MeshTopology</span>
<span class="c1">//</span>

<span class="k">struct</span> <span class="n">ON_MeshTopologyVertex</span>
<span class="p">{</span>
  <span class="c1">// m_tope_count = number of topological edges that begin or</span>
  <span class="c1">// end at this topological vertex.</span>
  <span class="kt">int</span> <span class="n">m_tope_count</span><span class="p">;</span>

  <span class="c1">// m_topei[] is an array of length m_tope_count with the indices</span>
  <span class="c1">// of the topological edges that begin or end at this topological</span>
  <span class="c1">// vertex.  Generally, these edges are listed in no particular</span>
  <span class="c1">// order.  If you want the edges listed &quot;radially&quot;, then call</span>
  <span class="c1">// ON_MeshTopology::SortVertexEdges.</span>
  <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">m_topei</span><span class="p">;</span>

  <span class="c1">// m_v_count = number of ON_Mesh vertices that correspond to</span>
  <span class="c1">// this topological vertex.</span>
  <span class="kt">int</span> <span class="n">m_v_count</span><span class="p">;</span>

  <span class="c1">// m_vi[] is an array of length m_v_count with the indices of the</span>
  <span class="c1">// ON_Mesh vertices that correspond to this topological vertex.</span>
  <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">m_vi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_MeshTopologyEdge</span>
<span class="p">{</span>
  <span class="c1">// m_topvi[] = indices of the topological verteices where the</span>
  <span class="c1">// edge begins and ends.</span>
  <span class="kt">int</span> <span class="n">m_topvi</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="c1">// m_topf_count = number of topological faces tat share this topological edge</span>
  <span class="kt">int</span> <span class="n">m_topf_count</span><span class="p">;</span>

  <span class="c1">// m_topfi[] is an array of length m_topf_count with the indices of the</span>
  <span class="c1">// topological faces that share this topological edge.</span>
  <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">m_topfi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_CLASS</span> <span class="n">ON_MeshTopologyFace</span>
<span class="p">{</span>
  <span class="cm">/*</span>
<span class="cm">    m_topei[] = indices of the topological edges that bound the face.</span>
<span class="cm">    If m_topei[2] = m_topei[3], then the face is a triangle, otherwise</span>
<span class="cm">    the face is a quad.</span>

<span class="cm">    NOTE WELL:</span>
<span class="cm">      The topological edge with index m_topei[k] ENDS at the</span>
<span class="cm">      vertex corresponding to ON_MeshFace.vi[k]. So, ...</span>

<span class="cm">      If the face is a quad, (ON_MeshFace.vi[2]!=ON_MeshFace.vi[3]),</span>
<span class="cm">      the topological edge with index m_topei[0] STARTS at</span>
<span class="cm">      ON_MeshFace.vi[3] and ENDS at ON_MeshFace.vi[0],</span>
<span class="cm">      the topological edge with index m_topei[1] STARTS at</span>
<span class="cm">      ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],</span>
<span class="cm">      the topological edge with index m_topei[2] STARTS at</span>
<span class="cm">      ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2], and</span>
<span class="cm">      the topological edge with index m_topei[3] STARTS at</span>
<span class="cm">      ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],</span>

<span class="cm">      If the face is a triangle, (ON_MeshFace.vi[2]==ON_MeshFace.vi[3]),</span>
<span class="cm">      the topological edge with index m_topei[0] STARTS at</span>
<span class="cm">      ON_MeshFace.vi[2] and ENDS at ON_MeshFace.vi[0],</span>
<span class="cm">      the topological edge with index m_topei[1] STARTS at</span>
<span class="cm">      ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],</span>
<span class="cm">      the topological edge with index m_topei[2] STARTS at</span>
<span class="cm">      ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2].</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="n">m_topei</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="cm">/*</span>
<span class="cm">    If m_reve[i] is 0, then the orientation of the edge matches the</span>
<span class="cm">    orientation of the face.  If m_reve[i] is 1, then the orientation</span>
<span class="cm">    of the edge is opposite that of the face.</span>
<span class="cm">  */</span>
  <span class="kt">char</span> <span class="n">m_reve</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    A topological mesh face is a valid triangle if m_topei[0],</span>
<span class="cm">    m_topei[1], m_topei[2] are distinct edges and</span>
<span class="cm">    m_topei[3]=m_topei[2].</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if face is a triangle.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsTriangle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    A topological mesh face is a valid quad if m_topei[0],</span>
<span class="cm">    m_topei[1], m_topei[2], and m_topei[3] are distinct edges.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if face is a quad.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsQuad</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    A topological mesh face is valid if m_topei[0], m_topei[1],</span>
<span class="cm">    and m_topei[2] are mutually distinct, and m_topei[3] is</span>
<span class="cm">    either equal to m_topei[2] or mutually distinct from the</span>
<span class="cm">    first three indices.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if face is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_MeshFace</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">vi</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// vertex index - vi[2]==vi[3] for tirangles</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if vi[2] == vi[3];</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Assumes the face is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsTriangle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if vi[2] != vi[3];</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Assumes the face is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsQuad</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine if a face is valid by checking that the vertices</span>
<span class="cm">    are distinct.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh_vertex_count - [in]</span>
<span class="cm">      number of vertices in the mesh</span>
<span class="cm">    V - [in]</span>
<span class="cm">      optional array of mesh_vertex_count vertex locations.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true</span>
<span class="cm">      The face is valid.</span>
<span class="cm">    false</span>
<span class="cm">      The face is not valid. It may be possible to repair the</span>
<span class="cm">      face by calling ON_MeshFace::Repair().</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">mesh_vertex_count</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">mesh_vertex_count</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">*</span> <span class="n">V</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">mesh_vertex_count</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">V</span>
        <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Reverses the order of the vertices in v[].</span>
<span class="cm">    vi[0] is not changed.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Flip</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If IsValid() returns false, then you can use Repair()</span>
<span class="cm">    to attempt to create a valid triangle.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh_vertex_count - [in]</span>
<span class="cm">      number of vertices in the mesh</span>
<span class="cm">    V - [in]</span>
<span class="cm">      optional array of mesh_vertex_count vertex locations.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true</span>
<span class="cm">     repair was successful and v[0], v[1], vi[2] have distinct valid</span>
<span class="cm">     values and v[2] == v[3].</span>
<span class="cm">    false</span>
<span class="cm">     this face&#39;s vi[] values cannot be repaired</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">Repair</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">mesh_vertex_count</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Repair</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">mesh_vertex_count</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">*</span> <span class="n">V</span>
        <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Repair</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">mesh_vertex_count</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">V</span>
        <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Compute the face normal</span>
<span class="cm">  Parameters:</span>
<span class="cm">    dV - [in] double precision vertex array for the mesh</span>
<span class="cm">    fV - [in] float precision vertex array for the mesh</span>
<span class="cm">    FN - [out] face normal</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if FN is valid.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ComputeFaceNormal</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">*</span> <span class="n">dV</span><span class="p">,</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">FN</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">ComputeFaceNormal</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">*</span> <span class="n">fV</span><span class="p">,</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="n">FN</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_MeshFaceSide</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">vi</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// vertex indices</span>
  <span class="kt">int</span> <span class="n">fi</span><span class="p">;</span>    <span class="c1">// mesh m_F[] array face index</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">side</span><span class="p">;</span>  <span class="c1">// edge connects mesh m_V[m_F[fi].vi[side]] and m_V[m_F[fi].vi[(side+1)%4]]</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">dir</span><span class="p">;</span>   <span class="c1">// 0 = counterclockwise, 1 = clockwise (reversed)</span>
  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// Set to zero by ON_Mesh::GetFaceSideList(). Can be used as needed.</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Sort the sides[] array of ON_MeshFaceSide structs in dictionary</span>
<span class="cm">  order by &quot;vi[0]&quot;, &quot;vi[1]&quot;, &quot;fi&quot;, and &quot;side&quot; values.</span>
<span class="cm">Paramters:</span>
<span class="cm">  sides_count - [in]</span>
<span class="cm">    number of elements in the sides[] array.</span>
<span class="cm">  sides - [in/out]</span>
<span class="cm">Remarks:</span>
<span class="cm">  The function is thread safe.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">void</span> <span class="nf">ON_SortMeshFaceSidesByVertexIndex</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">sides_count</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">ON_MeshFaceSide</span><span class="o">*</span> <span class="n">sides</span>
        <span class="p">);</span>

<span class="k">struct</span> <span class="n">ON_MeshPart</span>
<span class="p">{</span>
  <span class="c1">// ON_Mesh faces with indices fi[0] &lt;= i &lt; fi[1] reference</span>
  <span class="c1">// vertices with indices vi[0] &lt;= j &lt; vi[1].</span>
  <span class="kt">int</span> <span class="n">vi</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// subinterval of mesh m_V[] array</span>
  <span class="kt">int</span> <span class="n">fi</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// subinterval of mesh m_F[] array</span>
  <span class="kt">int</span> <span class="n">vertex_count</span><span class="p">;</span>   <span class="c1">// = vi[1] - vi[0];</span>
  <span class="kt">int</span> <span class="n">triangle_count</span><span class="p">;</span> <span class="c1">// tris + 2*quads &gt;= fi[1] - fi[0]</span>
<span class="p">};</span>

<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshFace</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshTopologyVertex</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshTopologyEdge</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshTopologyFace</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="k">struct</span> <span class="n">ON_MeshPart</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_MeshTopology</span>
<span class="p">{</span>
  <span class="c1">// A mesh topology class is always associated with an ON_Mesh</span>
  <span class="c1">// and can be retrieved by calling ON_Mesh::Topology()</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MeshTopology</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshTopology</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//////////</span>
  <span class="c1">// The parent ON_Mesh geometry used to compute this mesh topology.</span>
  <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">m_mesh</span><span class="p">;</span>

  <span class="c1">//////////</span>
  <span class="c1">// number of topoligical vertices (&lt;= m_mesh.VertexCount())</span>
  <span class="kt">int</span> <span class="nf">TopVertexCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//////////</span>
  <span class="c1">// number of topoligical edges</span>
  <span class="kt">int</span> <span class="nf">TopEdgeCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//////////</span>
  <span class="c1">// number of topoligical faces (same as m_mesh.FaceCount())</span>
  <span class="kt">int</span> <span class="nf">TopFaceCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a vertex reference to a mesh vertex index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    ci - [in] component index with type mesh_vertex or meshtop_vertex.</span>
<span class="cm">  Returns:</span>
<span class="cm">    a reference to the vertex</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_MeshVertexRef</span> <span class="nf">VertexRef</span><span class="p">(</span><span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">ON_MeshVertexRef</span> <span class="nf">VertexRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">topv_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get an edge reference.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    ci - [in] component index with type meshtop_edge.</span>
<span class="cm">  Returns:</span>
<span class="cm">    a reference to the edge</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_MeshEdgeRef</span> <span class="nf">EdgeRef</span><span class="p">(</span><span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">ON_MeshEdgeRef</span> <span class="nf">EdgeRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">tope_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a face reference from a mesh face index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    ci - [in] component index with type mesh_face.</span>
<span class="cm">  Returns:</span>
<span class="cm">    a reference to the face.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The OM_Mesh.m_F[] and ON_MeshTopology.m_topf[] arrays</span>
<span class="cm">    are parallel arrays; corresponding faces have identical</span>
<span class="cm">    indices.</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_MeshFaceRef</span> <span class="nf">FaceRef</span><span class="p">(</span><span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">ON_MeshFaceRef</span> <span class="nf">FaceRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">topf_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the 3d point location of a vertex.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    topv_index - [in];</span>
<span class="cm">  Returns:</span>
<span class="cm">    Location of vertex.</span>
<span class="cm">  */</span>
  <span class="n">ON_3fPoint</span> <span class="nf">TopVertexPoint</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">topv_index</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get the 3d line along an edge.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    tope_index - [in];</span>
<span class="cm">  Returns:</span>
<span class="cm">    Line along edge.  If input is not valid,</span>
<span class="cm">    the line.from and to are ON_UNSET_POINT</span>
<span class="cm">  */</span>
  <span class="n">ON_Line</span> <span class="nf">TopEdgeLine</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">tope_index</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">////////</span>
  <span class="c1">// returns index of edge that connects topological vertices</span>
  <span class="c1">// returns -1 if no edge is found.</span>
  <span class="kt">int</span> <span class="nf">TopEdge</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">vtopi0</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">vtopi1</span> <span class="c1">// ON_MeshTopology vertex topology indices</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">////////</span>
  <span class="c1">// returns ON_MeshTopology vertex topology index of a face</span>
  <span class="c1">// corner.  The face is triangle iv TopFaceVertex(2) = TopFaceVertex(3)</span>
  <span class="kt">bool</span> <span class="nf">GetTopFaceVertices</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">topfi</span><span class="p">,</span>    <span class="o">//</span> <span class="n">ON_MeshTopology</span> <span class="n">face</span> <span class="n">topology</span> <span class="n">index</span> <span class="p">(</span><span class="o">=</span> <span class="n">ON_Mesh</span> <span class="n">face</span> <span class="n">index</span><span class="p">)</span>
    <span class="kt">int</span> <span class="n">topvi</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="c1">// ON_MeshTopology vertex indices returned here</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sort the m_topei[] list of a mesh topology vertex so that</span>
<span class="cm">    the edges are in radial order.  The &quot;const&quot; is a white</span>
<span class="cm">    lie to make this function easier to call.</span>
<span class="cm">  Parameter:</span>
<span class="cm">    topvi - [in] index of vertex in m_topv[] array.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    A nonmanifold edge is treated as a boundary edge with respect</span>
<span class="cm">    to sorting.  If any boundary or nonmanifold edges end at the</span>
<span class="cm">    vertex, then the first edge will be a boundary or nonmanifold</span>
<span class="cm">    edge.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SortVertexEdges</span><span class="p">(</span> <span class="kt">int</span> <span class="n">topvi</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sort the m_topei[] list of every mesh topology vertex so</span>
<span class="cm">    that the edges are in radial order.  The &quot;const&quot; is a white</span>
<span class="cm">    lie to make this function easier to call.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Same as</span>
<span class="cm">    for ( int topvi = 0; topvi &lt; m_topv.Count(); topvi++ )</span>
<span class="cm">      SortVertexEdges(topvi);</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SortVertexEdges</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns true if the topological vertex is hidden.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    topvi - [in] mesh topology vertex index.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if mesh topology vertex is hidden.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The mesh topology vertex is hidden if and only if</span>
<span class="cm">    all the ON_Mesh vertices it represents is hidden.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TopVertexIsHidden</span><span class="p">(</span> <span class="kt">int</span> <span class="n">topvi</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns true if the topological edge is hidden.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    topei - [in] mesh topology edge index.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if mesh topology edge is hidden.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The mesh topology edge is hidden if and only if</span>
<span class="cm">    either of its mesh topology vertices is hidden.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TopEdgeIsHidden</span><span class="p">(</span> <span class="kt">int</span> <span class="n">topei</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns true if the topological face is hidden.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    topfi - [in] mesh topology face index.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if mesh topology face is hidden.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    The mesh topology face is hidden if and only if</span>
<span class="cm">    any of its mesh topology edges are hidden.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TopFaceIsHidden</span><span class="p">(</span> <span class="kt">int</span> <span class="n">topfi</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">//////////</span>
  <span class="c1">// m_topv_map[] has length m_mesh.VertexCount() and</span>
  <span class="c1">// m_topv[m_topv_map[vi]] is the topological mesh vertex that is assocated</span>
  <span class="c1">// the with the mesh vertex m_mesh.m_V[vi].</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_topv_map</span><span class="p">;</span>

  <span class="c1">////////////</span>
  <span class="c1">// Array of topological mesh vertices.  See the comments in the definition</span>
  <span class="c1">// of ON_MeshTopologyVertex for details.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshTopologyVertex</span><span class="o">&gt;</span> <span class="n">m_topv</span><span class="p">;</span>

  <span class="c1">////////////</span>
  <span class="c1">// Array of topological mesh edges.  See the comments in the definition</span>
  <span class="c1">// of ON_MeshTopologyEdge for details.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshTopologyEdge</span><span class="o">&gt;</span> <span class="n">m_tope</span><span class="p">;</span>

  <span class="c1">////////////</span>
  <span class="c1">// Array of topological mesh faces.  The topological face</span>
  <span class="c1">// m_topf[fi] corresponds to the mesh face ON_Mesh.m_F[fi].</span>
  <span class="c1">// See the comments in the definition of ON_MeshTopologyFace</span>
  <span class="c1">// for details. To get the indices of the mesh topology</span>
  <span class="c1">// vertices at the face corners use</span>
  <span class="c1">// topvi = m_topv_map[m_mesh.m_F[fi].vi[n]]</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshTopologyFace</span><span class="o">&gt;</span> <span class="n">m_topf</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function for efficiently getting the</span>
<span class="cm">    integer arrays used by the ON_MeshTopologyVertex</span>
<span class="cm">    and ON_MeshTopologyEdge classes.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    count - [in] number of integers in array</span>
<span class="cm">  Returns:</span>
<span class="cm">    pointer to integer array.  The array memory</span>
<span class="cm">    will be freed by ~ON_MeshTopology()</span>
<span class="cm">  */</span>
  <span class="kt">int</span><span class="o">*</span> <span class="nf">GetIntArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_Mesh</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">Create</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span>

  <span class="c1">// efficient workspaces for</span>
  <span class="k">struct</span> <span class="n">memchunk</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="n">memchunk</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="p">}</span> <span class="o">*</span><span class="n">m_memchunk</span><span class="p">;</span>

  <span class="c1">// NOTE: this field is a bool with valid values of 0 and 1.</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">m_b32IsValid</span><span class="p">;</span> <span class="c1">// sizeof(m_bIsValid) must be 4 - it is used in sleep locks.</span>
                    <span class="c1">//    0: Not Valid</span>
                    <span class="c1">//    1: Valid</span>
                    <span class="c1">//   -1: Sleep locked - ON_Mesh::Topology() calculation is in progress</span>
  <span class="kt">int</span> <span class="nf">WaitUntilReady</span><span class="p">(</span><span class="kt">int</span> <span class="n">sleep_value</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// waits until m_b32IsValid &gt;= 0</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// no implementation</span>
  <span class="n">ON_MeshTopology</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshTopology</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_MeshTopology</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshTopology</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ON_MeshNgon</span>
<span class="p">{</span>
  <span class="c1">// Number of N-gon corners (N &gt;= 3)</span>
  <span class="kt">int</span> <span class="n">N</span><span class="p">;</span>

  <span class="c1">// N-gon vertex indices</span>
  <span class="c1">// An array of N indices into the mesh&#39;s m_V[] vertex array.</span>
  <span class="c1">// If the ON_MeshNgon is returned by the ON_MeshNgonList::AddNgon()</span>
  <span class="c1">// function, then the memory for vi is managed by the ON_MeshNgonList</span>
  <span class="c1">// class.</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">vi</span><span class="p">;</span>

  <span class="c1">// N-gon face indices</span>
  <span class="c1">// An array of N indices into the mesh&#39;s m_F[] face array.</span>
  <span class="c1">// Often, only N-2 indices are used. Unused indices are set to -1.</span>
  <span class="c1">// If the ON_MeshNgon is returned by the ON_MeshNgonList::AddNgon()</span>
  <span class="c1">// function, then the memory for fi is managed by the ON_MeshNgonList</span>
  <span class="c1">// class.</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">fi</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_MeshNgonList</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MeshNgonList</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshNgonList</span><span class="p">();</span>
  <span class="n">ON_MeshNgonList</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshNgonList</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">ON_MeshNgonList</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshNgonList</span><span class="o">&amp;</span><span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Add an N-gon to the list</span>
<span class="cm">  Parameters:</span>
<span class="cm">    N - [in] number of vertices ( &gt;= 5)</span>
<span class="cm">    vi - [in] array of N vertex indices into the mesh&#39;s m_V[] array.</span>
<span class="cm">    fi - [in] array of N face indices into the mesh&#39;s m_F[] array.</span>
<span class="cm">              Unused indices are set to -1.  In many cases</span>
<span class="cm">              there are N-2 valid indices and these are triangles.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Adding an N-gon may invalidate any pointers previously</span>
<span class="cm">    returned by Ngon.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">AddNgon</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">vi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">fi</span><span class="p">);</span>
  <span class="k">struct</span> <span class="n">ON_MeshNgon</span><span class="o">*</span> <span class="nf">AddNgon</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of Ngons</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">NgonCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    Ngon_index - [in] zero based index</span>
<span class="cm">  Returns:</span>
<span class="cm">    NULL or a pointer to the Ngon</span>
<span class="cm">  */</span>
  <span class="n">ON_MeshNgon</span><span class="o">*</span> <span class="nf">Ngon</span><span class="p">(</span><span class="kt">int</span> <span class="n">Ngon_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If you know about how many ngons you will need,</span>
<span class="cm">    then use the function to reserve space for them.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ReserveNgonCapacity</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Destroy N-gon list</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Approximate number of bytes used by this class.</span>
<span class="cm">  */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">m_ngons_count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_ngons_capacity</span><span class="p">;</span>
  <span class="n">ON_MeshNgon</span><span class="o">*</span> <span class="n">m_ngons</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ON_NGON_MEMBLK</span><span class="o">*</span> <span class="n">m_memblk_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_MeshPartition</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MeshPartition</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshPartition</span><span class="p">();</span>

  <span class="c1">// maximum number of vertices in a partition</span>
  <span class="kt">int</span> <span class="n">m_partition_max_vertex_count</span><span class="p">;</span>
  <span class="c1">// maximum number of triangles in a partition (quads count as 2 triangles)</span>
  <span class="kt">int</span> <span class="n">m_partition_max_triangle_count</span><span class="p">;</span>

  <span class="c1">// Partition i uses</span>
  <span class="c1">// vertices m_V[j] where</span>
  <span class="c1">//</span>
  <span class="c1">//   m_part[i].vi[0] &lt;= j &lt; m_part[i].vi[1]</span>
  <span class="c1">//</span>
  <span class="c1">// and uses faces m_F[k] where</span>
  <span class="c1">//</span>
  <span class="c1">//    m_part[i].fi[0] &lt;= k &lt; m_part[i].fi[1]</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="k">struct</span> <span class="n">ON_MeshPart</span><span class="o">&gt;</span> <span class="n">m_part</span><span class="p">;</span>
<span class="p">};</span>



<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_MappingTag</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MappingTag</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">Default</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">Write</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="n">ON_BinaryArchive</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">Transform</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span> <span class="p">);</span>
  <span class="kt">void</span> <span class="nf">Set</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_TextureMapping</span><span class="o">&amp;</span> <span class="n">mapping</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Sets the tag to the value the meshes have that</span>
<span class="cm">    come out of ON_Brep::CreateMesh().</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetDefaultSurfaceParameterMappingTag</span><span class="p">();</span>

  <span class="kt">int</span> <span class="nf">Compare</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_MappingTag</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span>
               <span class="kt">bool</span> <span class="n">bCompareId</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
               <span class="kt">bool</span> <span class="n">bCompareCRC</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
               <span class="kt">bool</span> <span class="n">bCompareXform</span> <span class="o">=</span> <span class="nb">true</span>
               <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the mapping tag is set.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsSet</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the mapping tag is for a mapping with</span>
<span class="cm">    type ON_TextureMapping::srfp_mapping with</span>
<span class="cm">    m_uvw = identity.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsDefaultSurfaceParameterMapping</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Identifies the mapping used to create the texture</span>
  <span class="c1">// coordinates and records transformations applied</span>
  <span class="c1">// to the mesh after the texture coordinates were</span>
  <span class="c1">// calculated.  If the texture mapping does not</span>
  <span class="c1">// change when the mesh is transformed, then set</span>
  <span class="c1">// m_mesh_xform to zero so that compares will work right.</span>
  <span class="c1">//</span>
  <span class="c1">//</span>
  <span class="n">ON_UUID</span>                 <span class="n">m_mapping_id</span><span class="p">;</span>   <span class="c1">// ON_TextureMapping::m_mapping_id</span>
  <span class="n">ON_TextureMapping</span><span class="o">::</span><span class="n">TYPE</span> <span class="n">m_mapping_type</span><span class="p">;</span> <span class="c1">// ON_TextureMapping::m_type</span>
  <span class="n">ON__UINT32</span>              <span class="n">m_mapping_crc</span><span class="p">;</span>  <span class="c1">// ON_TextureMapping::MappingCRC()</span>
  <span class="n">ON_Xform</span>                <span class="n">m_mesh_xform</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_TextureCoordinates</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_TextureCoordinates</span><span class="p">();</span>

  <span class="n">ON_MappingTag</span>   <span class="n">m_tag</span><span class="p">;</span>
  <span class="kt">int</span>                        <span class="n">m_dim</span><span class="p">;</span> <span class="c1">// 1, 2, or 3</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_3fPoint</span><span class="o">&gt;</span> <span class="n">m_T</span><span class="p">;</span>   <span class="c1">// texture coordinates</span>
<span class="p">};</span>


<span class="cp">#if defined(ON_DLL_TEMPLATE)</span>
<span class="c1">// This stuff is here because of a limitation in the way Microsoft</span>
<span class="c1">// handles templates and DLLs.  See Microsoft&#39;s knowledge base</span>
<span class="c1">// article ID Q168958 for details.</span>
<span class="cp">#pragma warning( push )</span>
<span class="cp">#pragma warning( disable : 4231 )</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MappingTag</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">ON_DLL_TEMPLATE</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_TextureCoordinates</span><span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#pragma warning( pop )</span>
<span class="cp">#endif</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_Mesh</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_Mesh</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_Mesh</span><span class="p">();</span>
  <span class="n">ON_Mesh</span><span class="p">(</span>
    <span class="kt">int</span>   <span class="n">initial_face_array_capacity</span><span class="p">,</span>   <span class="c1">// initial face array capacity</span>
    <span class="kt">int</span>   <span class="n">initial_vertex_array_capacity</span><span class="p">,</span> <span class="c1">// initial vertex array capacity</span>
    <span class="kt">bool</span>  <span class="n">has_vertex_normals</span><span class="p">,</span>            <span class="c1">// true if mesh has vertex normals</span>
    <span class="kt">bool</span>  <span class="n">has_texture_coordinates</span>        <span class="c1">// true if mesh has texture coordinates</span>
    <span class="p">);</span>
  <span class="n">ON_Mesh</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="n">ON_Mesh</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="o">~</span><span class="n">ON_Mesh</span><span class="p">();</span>

  <span class="c1">// Override of virtual ON_Object::MemoryRelocate</span>
  <span class="kt">void</span> <span class="nf">MemoryRelocate</span><span class="p">();</span>

  <span class="c1">// virtual ON_Object::DestroyRuntimeCache override</span>
  <span class="kt">void</span> <span class="nf">DestroyRuntimeCache</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDelete</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">EmergencyDestroy</span><span class="p">();</span> <span class="c1">// Call only when memory used by this class&#39;s</span>
                           <span class="c1">// members will soon become invalid for reasons</span>
                           <span class="c1">// beyond your control. EmergencyDestroy() zeros</span>
                           <span class="c1">// anything that could possibly cause</span>
                           <span class="c1">// ~ON_Mesh() to crash.  Calling</span>
                           <span class="c1">// EmergencyDestroy() under normal conditions</span>
                           <span class="c1">// will result in ~ON_Mesh() leaking</span>
                           <span class="c1">// memory.</span>

  <span class="kt">void</span> <span class="nf">DestroyTree</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bDeleteTree</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// ON_Object overrides</span>

  <span class="c1">// virtual ON_Object::SizeOf override</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Object::DataCRC override</span>
  <span class="n">ON__UINT32</span> <span class="nf">DataCRC</span><span class="p">(</span><span class="n">ON__UINT32</span> <span class="n">current_remainder</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests an object to see if its data members are correctly</span>
<span class="cm">    initialized.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    text_log - [in] if the object is not valid and text_log</span>
<span class="cm">        is not NULL, then a brief englis description of the</span>
<span class="cm">        reason the object is not valid is appened to the log.</span>
<span class="cm">        The information appended to text_log is suitable for</span>
<span class="cm">        low-level debugging purposes by programmers and is</span>
<span class="cm">        not intended to be useful as a high level user</span>
<span class="cm">        interface tool.</span>
<span class="cm">  Returns:</span>
<span class="cm">    @untitled table</span>
<span class="cm">    true     object is valid</span>
<span class="cm">    false    object is invalid, uninitialized, etc.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Overrides virtual ON_Object::IsValid</span>
<span class="cm">  */</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// for debugging</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Write</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Read</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>

  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// ON_Geometry overrides</span>

  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span> <span class="c1">// returns true if successful</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// minimum</span>
         <span class="kt">double</span><span class="o">*</span><span class="p">,</span>    <span class="c1">// maximum</span>
         <span class="n">ON_BOOL32</span> <span class="o">=</span> <span class="nb">false</span>  <span class="c1">// true means grow box</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get tight bounding box of the mesh.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    tight_bbox - [in/out] tight bounding box</span>
<span class="cm">    bGrowBox -[in]  (default=false)</span>
<span class="cm">      If true and the input tight_bbox is valid, then returned</span>
<span class="cm">      tight_bbox is the union of the input tight_bbox and the</span>
<span class="cm">      mesh&#39;s tight bounding box.</span>
<span class="cm">    xform -[in] (default=NULL)</span>
<span class="cm">      If not NULL, the tight bounding box of the transformed</span>
<span class="cm">      mesh is calculated.  The mesh is not modified.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the returned tight_bbox is set to a valid</span>
<span class="cm">    bounding box.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">GetTightBoundingBox</span><span class="p">(</span>
      <span class="n">ON_BoundingBox</span><span class="o">&amp;</span> <span class="n">tight_bbox</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">*</span> <span class="n">xform</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span>
         <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry::IsDeformable() override</span>
  <span class="kt">bool</span> <span class="nf">IsDeformable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// virtual ON_Geometry::MakeDeformable() override</span>
  <span class="kt">bool</span> <span class="nf">MakeDeformable</span><span class="p">();</span>

  <span class="n">ON_BOOL32</span> <span class="nf">SwapCoordinates</span><span class="p">(</span>
        <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span>        <span class="c1">// indices of coords to swap</span>
        <span class="p">);</span>

  <span class="c1">// virtual ON_Geometry override</span>
  <span class="kt">bool</span> <span class="nf">EvaluatePoint</span><span class="p">(</span> <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_ObjRef</span><span class="o">&amp;</span> <span class="n">objref</span><span class="p">,</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">P</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Interface</span>
  <span class="c1">//</span>

  <span class="c1">// creation</span>
  <span class="kt">bool</span> <span class="nf">SetVertex</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span>              <span class="c1">// vertex index</span>
         <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="c1">// vertex location</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetVertex</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span>              <span class="c1">// vertex index</span>
         <span class="k">const</span> <span class="n">ON_3fPoint</span><span class="o">&amp;</span> <span class="c1">// vertex location</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetVertexNormal</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span>               <span class="c1">// vertex index</span>
         <span class="k">const</span> <span class="n">ON_3dVector</span><span class="o">&amp;</span> <span class="c1">// unit normal</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetVertexNormal</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span>               <span class="c1">// vertex index</span>
         <span class="k">const</span> <span class="n">ON_3fVector</span><span class="o">&amp;</span> <span class="c1">// unit normal</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetTextureCoord</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span>               <span class="c1">// vertex index</span>
         <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span>     <span class="c1">// texture coordinates</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetTriangle</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span> <span class="c1">// face index</span>
         <span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span> <span class="c1">// vertex indices</span>
         <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SetQuad</span><span class="p">(</span>
         <span class="kt">int</span><span class="p">,</span> <span class="c1">// face index</span>
         <span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span> <span class="c1">// vertex indices</span>
         <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a vertex reference to a mesh vertex index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    ci - [in] component index with type mesh_vertex or meshtop_vertex.</span>
<span class="cm">  Returns:</span>
<span class="cm">    a reference to the vertex</span>
<span class="cm">  */</span>
  <span class="n">ON_MeshVertexRef</span> <span class="nf">VertexRef</span><span class="p">(</span><span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_MeshVertexRef</span> <span class="nf">VertexRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">mesh_V_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get an edge reference from a mesh topology edge index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    ci - [in] component index with type meshtop_edge</span>
<span class="cm">  Returns:</span>
<span class="cm">    a reference to the edge</span>
<span class="cm">  */</span>
  <span class="n">ON_MeshEdgeRef</span> <span class="nf">EdgeRef</span><span class="p">(</span><span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_MeshEdgeRef</span> <span class="nf">EdgeRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">tope_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a face reference from a mesh face index.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    ci - [in] component index with type mesh_face.</span>
<span class="cm">  Returns:</span>
<span class="cm">    a reference to the face</span>
<span class="cm">  */</span>
  <span class="n">ON_MeshFaceRef</span> <span class="nf">FaceRef</span><span class="p">(</span><span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">ON_MeshFaceRef</span> <span class="nf">FaceRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">mesh_F_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">   ci - [in] a component index with type mesh_vertex, meshtop_vertex,</span>
<span class="cm">             meshtop_edge, or mesh_face.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to an ON_MeshVertexRef, ON_MeshEdgeRef, or ON_MeshFaceRef.</span>
<span class="cm">    The caller must delete the returned object when it is no longer</span>
<span class="cm">    needed.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Mesh::VertexRef</span>
<span class="cm">    ON_Mesh::EdgeRef</span>
<span class="cm">    ON_Mesh::FaceRef</span>
<span class="cm">  */</span>
  <span class="n">ON_Geometry</span><span class="o">*</span> <span class="nf">MeshComponent</span><span class="p">(</span>
      <span class="n">ON_COMPONENT_INDEX</span> <span class="n">ci</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// query</span>
  <span class="kt">int</span> <span class="nf">VertexCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">FaceCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">QuadCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// number of faces that are quads</span>
  <span class="kt">int</span> <span class="nf">TriangleCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// number of faces that are triangles</span>
  <span class="kt">int</span> <span class="nf">InvalidFaceCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// number of face that have invalid m_vi[] values.</span>
  <span class="kt">bool</span> <span class="nf">HasVertexNormals</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// normals at vertices</span>
  <span class="kt">bool</span> <span class="nf">HasFaceNormals</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">HasTextureCoordinates</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">HasSurfaceParameters</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">HasPrincipalCurvatures</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">HasVertexColors</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of vertices that are hidden.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">HiddenVertexCount</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="nf">GetCurvatureStats</span><span class="p">(</span>
         <span class="n">ON</span><span class="o">::</span><span class="n">curvature_style</span><span class="p">,</span>
         <span class="n">ON_MeshCurvatureStats</span><span class="o">&amp;</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">InvalidateVertexBoundingBox</span><span class="p">();</span> <span class="c1">// Call if defining geometry is changed by</span>
                             <span class="c1">// directly manipulating the m_V[] array.</span>
  <span class="kt">void</span> <span class="nf">InvalidateVertexNormalBoundingBox</span><span class="p">();</span> <span class="c1">// Call if defining geometry is changed by</span>
                             <span class="c1">// directly manipulating the m_N[] array.</span>
  <span class="kt">void</span> <span class="nf">InvalidateTextureCoordinateBoundingBox</span><span class="p">();</span> <span class="c1">// Call if defining geometry is changed by</span>
                             <span class="c1">// directly manipulating the m_T[] array.</span>
  <span class="kt">void</span> <span class="nf">InvalidateCurvatureStats</span><span class="p">();</span> <span class="c1">// Call if defining geometry is changed by</span>
                             <span class="c1">// directly manipulating the m_T[] array.</span>
  <span class="kt">void</span> <span class="nf">InvalidateBoundingBoxes</span><span class="p">();</span> <span class="c1">// Invalidates all cached bounding box information.</span>


  <span class="kt">void</span> <span class="nf">Flip</span><span class="p">();</span> <span class="c1">// reverses face orientations and flips vertex and face normals</span>

  <span class="kt">void</span> <span class="nf">FlipVertexNormals</span><span class="p">();</span> <span class="c1">// reverses vertex normals</span>
  <span class="kt">void</span> <span class="nf">FlipFaceNormals</span><span class="p">();</span> <span class="c1">// reverses face normals</span>
  <span class="kt">void</span> <span class="nf">FlipFaceOrientation</span><span class="p">();</span> <span class="c1">// reverses face orientation (does nothing to normals)</span>

  <span class="kt">void</span> <span class="nf">SetMeshParameters</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_MeshParameters</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="k">const</span> <span class="n">ON_MeshParameters</span><span class="o">*</span> <span class="nf">MeshParameters</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">DeleteMeshParameters</span><span class="p">();</span>


  <span class="kt">bool</span> <span class="nf">UnitizeVertexNormals</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">UnitizeFaceNormals</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">CountQuads</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Splits all quads along the short diagonal.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ConvertQuadsToTriangles</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Joins adjacent triangles into quads if the resulting quad</span>
<span class="cm">    is nice.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    angle_tol_radians - [in] Used to compare adjacent</span>
<span class="cm">      triangles&#39; face normals.  For two triangles to be considered,</span>
<span class="cm">      the angle between their face normals has to be &lt;= angle_tol_radians.</span>
<span class="cm">      When in doubt use ON_PI/90.0 (2 degrees).</span>
<span class="cm">    min_diagonal_length_ratio - [in] ( &lt;= 1.0) For two triangles to be</span>
<span class="cm">       considered the ratio of the resulting quad&#39;s diagonals</span>
<span class="cm">       (length of the shortest diagonal)/(length of longest diagonal).</span>
<span class="cm">       has to be &gt;= min_diagonal_length_ratio.</span>
<span class="cm">       When in doubt us .875.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">ConvertTrianglesToQuads</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">angle_tol_radians</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">min_diagonal_length_ratio</span>
    <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ComputeFaceNormals</span><span class="p">();</span>   <span class="c1">// compute face normals for all faces</span>
  <span class="kt">bool</span> <span class="nf">ComputeFaceNormal</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// computes face normal of indexed face</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a list of pairs of faces that clash.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    max_pair_count - [in]</span>
<span class="cm">      If max_pair_count &gt; 0, then at most this many pairs</span>
<span class="cm">      will be appended to the clashing_pairs[] array.</span>
<span class="cm">      If max_pair_count &lt;= 0, then all clashing pairs</span>
<span class="cm">      will be appended to the clashing_pairs[] array.</span>
<span class="cm">    clashing_pairs - [out]</span>
<span class="cm">      The faces indices of clashing pairs are appended</span>
<span class="cm">      to this array.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of pairs appended to clashing_pairs[].</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetClashingFacePairs</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">max_pair_count</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span> <span class="n">ON_2dex</span> <span class="o">&gt;&amp;</span> <span class="n">clashing_pairs</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Cull clashing faces from the mesh.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    what_to_cull - [in]</span>
<span class="cm">      0: when a pair of faces clash, cull both faces</span>
<span class="cm">      1: when a pair of faces clash, leave the face with the</span>
<span class="cm">         longest edge.</span>
<span class="cm">      2: when a pair of faces clash, cull the face with the</span>
<span class="cm">         longest edge.</span>
<span class="cm">      3: when a pair of faces clash, leave the face with</span>
<span class="cm">         the largest area.</span>
<span class="cm">      4: when a pair of faces clash, cull the face with</span>
<span class="cm">         the largest area.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of faces culled from the mesh.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If a large face clashes with many small faces, the large</span>
<span class="cm">    face and one small face will be removed.  When a degenerate</span>
<span class="cm">    face is encountered, it is also culled.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">CullClashingFaces</span><span class="p">(</span> <span class="kt">int</span> <span class="n">what_to_cull</span> <span class="p">);</span>

  <span class="kt">int</span> <span class="nf">CullDegenerateFaces</span><span class="p">();</span> <span class="c1">// returns number of degenerate faces</span>

  <span class="kt">int</span> <span class="nf">CullUnusedVertices</span><span class="p">();</span> <span class="c1">// returns number of culled vertices</span>

  <span class="c1">// Description:</span>
  <span class="c1">//   Removes any unreferenced objects from arrays, reindexes as needed,</span>
  <span class="c1">//   and shrinks arrays to minimum required size.</span>
  <span class="kt">bool</span> <span class="nf">Compact</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">ComputeVertexNormals</span><span class="p">();</span>    <span class="c1">// uses face normals to cook up a vertex normal</span>

  <span class="c1">//////////</span>
  <span class="c1">// Scales textures so the texture domains are [0,1] and</span>
  <span class="c1">// eliminates any texture rotations.</span>
  <span class="kt">bool</span> <span class="nf">NormalizeTextureCoordinates</span><span class="p">();</span>

  <span class="c1">/////////</span>
  <span class="c1">// Description:</span>
  <span class="c1">//    Transposes the texture coordinates</span>
  <span class="c1">//  Returns</span>
  <span class="c1">//      true  -  success</span>
  <span class="kt">bool</span> <span class="nf">TransposeTextureCoordinates</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">TransposeSurfaceParameters</span><span class="p">();</span>

  <span class="c1">/////////</span>
  <span class="c1">// Description:</span>
  <span class="c1">//    Reverse one coordinate direction of the texture coordinates, within texture domain m_tex_domain</span>
  <span class="c1">//  Parameters:</span>
  <span class="c1">//    dir  -[in]  -   dir=0  first texture coordinate is reversed</span>
  <span class="c1">//                    dir=1 second texture coordinate is reversed</span>
  <span class="c1">//  Returns</span>
  <span class="c1">//      true  -  success</span>
  <span class="kt">bool</span> <span class="nf">ReverseTextureCoordinates</span><span class="p">(</span> <span class="kt">int</span> <span class="n">dir</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">ReverseSurfaceParameters</span><span class="p">(</span> <span class="kt">int</span> <span class="n">dir</span> <span class="p">);</span>



  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Use a texture mapping function to set the m_T[] values.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mapping - [in]</span>
<span class="cm">    mesh_xform - [in]</span>
<span class="cm">      If not NULL, the mapping calculation is performed as</span>
<span class="cm">      if the mesh were transformed by mesh_xform; the</span>
<span class="cm">      location of the mesh is not changed.</span>
<span class="cm">    bLazy - [in]</span>
<span class="cm">      If true and the m_T[] values were set using the same</span>
<span class="cm">      mapping parameters, then no calculation is performed.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if successful.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_TextureMapping::GetTextureCoordinates</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SetTextureCoordinates</span><span class="p">(</span>
          <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_TextureMapping</span><span class="o">&amp;</span> <span class="n">mapping</span><span class="p">,</span>
          <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_Xform</span><span class="o">*</span> <span class="n">mesh_xform</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">true</span>
          <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">HasCachedTextureCoordinates</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">ON_TextureCoordinates</span><span class="o">*</span> <span class="nf">CachedTextureCoordinates</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_UUID</span><span class="o">&amp;</span> <span class="n">mapping_id</span>
          <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">ON_TextureCoordinates</span><span class="o">*</span> <span class="nf">SetCachedTextureCoordinates</span><span class="p">(</span>
          <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_TextureMapping</span><span class="o">&amp;</span> <span class="n">mapping</span><span class="p">,</span>
          <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_Xform</span><span class="o">*</span> <span class="n">mesh_xform</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bLazy</span> <span class="o">=</span> <span class="nb">true</span>
          <span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">EvaluateMeshGeometry</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Surface</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// evaluate surface at tcoords</span>
                                                  <span class="c1">// to set mesh geometry</span>

  <span class="c1">// finds all coincident vertices and merges them if break angle is small enough</span>
  <span class="kt">bool</span> <span class="nf">CombineCoincidentVertices</span><span class="p">(</span>
          <span class="n">ON_3fVector</span><span class="p">,</span> <span class="c1">// coordinate tols for considering vertices</span>
                       <span class="c1">// to be coincident</span>
          <span class="kt">double</span>  <span class="c1">// cosine normal angle tolerance in radians</span>
                  <span class="c1">// if vertices are coincident, then they are combined</span>
                  <span class="c1">// if NormalA o NormalB &gt;= this value</span>
          <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Combines identical vertices.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bIgnoreVertexNormals - [in] If true, then vertex normals</span>
<span class="cm">      are ignored when comparing vertices.</span>
<span class="cm">    bIgnoreTextureCoordinates - [in] If true, then vertex</span>
<span class="cm">      texture coordinates, colors, and principal curvatures</span>
<span class="cm">      are ignored when comparing vertices.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the mesh is changed, in which case the returned</span>
<span class="cm">    mesh will have fewer vertices than the input mesh.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CombineIdenticalVertices</span><span class="p">(</span>
          <span class="kt">bool</span> <span class="n">bIgnoreVertexNormals</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bIgnoreTextureCoordinates</span> <span class="o">=</span> <span class="nb">false</span>
          <span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Append</span><span class="p">(</span> <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">&amp;</span> <span class="p">);</span> <span class="c1">// appends a copy of mesh to this and updates</span>
                                 <span class="c1">// indices of appended mesh parts</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Append a list of meshes. This function is much more efficient</span>
<span class="cm">    than making repeated calls to ON_Mesh::Append(const ON_Mesh&amp;)</span>
<span class="cm">    when lots of meshes are being joined into a single large mesh.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    count - [in]</span>
<span class="cm">      length of meshes[] array.</span>
<span class="cm">    meshes - [in]</span>
<span class="cm">      array of meshes to append.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">Append</span><span class="p">(</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">meshes</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function to set m_is_closed member.</span>
<span class="cm">    Setting this value correctly after a mesh is constructed</span>
<span class="cm">    can save time when IsClosed() is called.</span>
<span class="cm">    This function sets the private member variable m_is_closed.</span>
<span class="cm">  Paramters:</span>
<span class="cm">    closed - [in]</span>
<span class="cm">      0: The mesh is not closed.  There is at least one face with an</span>
<span class="cm">         edge that is geometrically distinct (as an unoriented line segment)</span>
<span class="cm">         from all other edges.</span>
<span class="cm">      1: The mesh is closed.  Every geometrically distict edge is used</span>
<span class="cm">         by two or more faces.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetClosed</span><span class="p">(</span><span class="kt">int</span> <span class="n">closed</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if every mesh &quot;edge&quot; has two or more faces.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsClosed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if every mesh &quot;edge&quot; has at most two faces.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsManifold</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the mesh is manifold and every pair of faces</span>
<span class="cm">    that share an &quot;edge&quot; have compatible orientations.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsOriented</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine if the mesh is a manifold.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bTopologicalTest - [in]</span>
<span class="cm">      If true, the query treats coincident vertices as</span>
<span class="cm">      the same.</span>
<span class="cm">    pbIsOriented - [out]</span>
<span class="cm">      If the input pointer is not NULL, then the returned</span>
<span class="cm">      value of *pbIsOriented will be true if the mesh</span>
<span class="cm">      is a manifold and adjacent faces have compatible</span>
<span class="cm">      face normals.</span>
<span class="cm">    pbHasBoundary - [out]</span>
<span class="cm">      If the input pointer is not NULL, then the returned</span>
<span class="cm">      value of *pbHasBoundary will be true if the mesh</span>
<span class="cm">      is a manifold and there is at least one &quot;edge&quot;</span>
<span class="cm">      with no adjacent faces have compatible</span>
<span class="cm">      face normals.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if every mesh &quot;edge&quot; has at most two adjacent faces.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsManifold</span><span class="p">(</span>
    <span class="kt">bool</span> <span class="n">bTopologicalTest</span><span class="p">,</span>
    <span class="kt">bool</span><span class="o">*</span> <span class="n">pbIsOriented</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="kt">bool</span><span class="o">*</span> <span class="n">pbHasBoundary</span> <span class="o">=</span> <span class="nb">NULL</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Expert user function to set m_is_solid member.</span>
<span class="cm">    Setting this value correctly after a mesh is constructed</span>
<span class="cm">    can save time when IsSolid() is called.</span>
<span class="cm">    This function sets the private member variable m_is_solid.</span>
<span class="cm">    If solid is nonzero, it will set m_is_closed to 1.</span>
<span class="cm">  Paramters:</span>
<span class="cm">    solid - [in]</span>
<span class="cm">      0: The mesh is not an oriented manifold solid mesh. Either</span>
<span class="cm">         the mesh is not closed, not manifold, or the faces are</span>
<span class="cm">         not oriented compatibly.</span>
<span class="cm">      1: The mesh is an oriented manifold solid whose face normals</span>
<span class="cm">         point outwards.</span>
<span class="cm">     -1: The mesh is an oriented manifold solid whose face normals</span>
<span class="cm">         point inwards.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetSolidOrientation</span><span class="p">(</span><span class="kt">int</span> <span class="n">solid_orientation</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Determine orientation of a mesh.</span>
<span class="cm">  Returns:</span>
<span class="cm">    +1     mesh is a solid with outward facing normals</span>
<span class="cm">    -1     mesh is a solid with inward facing normals</span>
<span class="cm">     0     mesh is not a solid</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Mesh::IsSolid</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">SolidOrientation</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Test mesh to see if it is a solid.  (A &quot;solid&quot; is</span>
<span class="cm">    a closed oriented manifold.)</span>
<span class="cm">  Returns:</span>
<span class="cm">    true       mesh is a solid</span>
<span class="cm">    fals       mesh is not a solid</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Mesh::SolidOrientation</span>
<span class="cm">    ON_Mesh::IsManifold</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsSolid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Appends a list of mesh edges that begin or end at the specified</span>
<span class="cm">    vertices to the edges[] array.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    vcount - [in]</span>
<span class="cm">      number of vertices</span>
<span class="cm">    vertex_index - [in]</span>
<span class="cm">      array of vertex indices</span>
<span class="cm">    bNoDuplicates - [in]</span>
<span class="cm">      If true, then only one edges[] is added for each edge,</span>
<span class="cm">      the first vertex index will alwasy be less than the</span>
<span class="cm">      second, and the returned elements are sorted in dictionary</span>
<span class="cm">      order.</span>
<span class="cm">      If false and an edge is shared by multiple faces, then</span>
<span class="cm">      there will be an edges[] element added for each face and the</span>
<span class="cm">      order of the vertex indicies will indicate the orientation</span>
<span class="cm">      of the edge with respect to the face.  No sorting is performed</span>
<span class="cm">      in this case.</span>
<span class="cm">    edges - [out]</span>
<span class="cm">      Edges that begin or end at one of the specified vertices are</span>
<span class="cm">      appended to this array.  Each ON_2dex records the start and</span>
<span class="cm">      end vertex index.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of ON_2dex values appended to the edges[] array.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetVertexEdges</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">vcount</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">vertex_index</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">bNoDuplicates</span><span class="p">,</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dex</span><span class="o">&gt;&amp;</span> <span class="n">edges</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Appends a list of mesh edges to the edges[] array.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edges - [out]</span>
<span class="cm">      Each edges[] element is a pair of vertex indices.  There</span>
<span class="cm">      is at least one face in the mesh with an edge running between</span>
<span class="cm">      the indicies.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of ON_2dex values appended to the edges[] array.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetMeshEdges</span><span class="p">(</span>
    <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dex</span><span class="o">&gt;&amp;</span> <span class="n">edges</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Assign a unique id to each vertex location.  Coincident vertices</span>
<span class="cm">    get the same id.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    first_vid - [in]</span>
<span class="cm">      Initial vertex id.  Typically 1 or 0.</span>
<span class="cm">    Vid - [out]</span>
<span class="cm">      If not null, then Vid[] sould be an array of length VertexCount().</span>
<span class="cm">      and the vertex ids will be stored in this array.  If null,</span>
<span class="cm">      the array will be allocated by calling onmalloc().  The returned</span>
<span class="cm">      array Vid[i] is the id of the vertex m_V[i].  If m_V[i] and</span>
<span class="cm">      m_V[j] are the same 3d point, then Vid[i] and Vid[j] will have</span>
<span class="cm">      the same value.</span>
<span class="cm">    Vindex - [out] (can be null)</span>
<span class="cm">      If Vindex is not null, then it must have length at least m_V.Count()</span>
<span class="cm">      and the returned array will be a permutation of (0,1,...,m_V.Count()-1)</span>
<span class="cm">      such (Vid[Vindex[0]], Vid[Vindex[1]], ..., Vid[Vindex[m_V.Count()-1]])</span>
<span class="cm">      is an increasing list of value.</span>
<span class="cm">  Returns:</span>
<span class="cm">    null if the mesh has no vertices.</span>
<span class="cm">    An array of length VertexCount(). If vertices m_V[i] and m_V[j]</span>
<span class="cm">    are coincident, then Vid[i] = Vid[j].  The id values begin at first_vid.</span>
<span class="cm">    The maximum vertex id is Vid[Vindex[m_V.Count()-1]].  The number of</span>
<span class="cm">    unique vertex locations is (Vid[Vindex[m_V.Count()-1]] - first_vid + 1).</span>
<span class="cm">  */</span>
  <span class="kt">int</span><span class="o">*</span> <span class="nf">GetVertexLocationIds</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">first_vid</span><span class="p">,</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">Vid</span><span class="p">,</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">Vindex</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a list of the sides of every face.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    Vid - [in] (can be null)</span>
<span class="cm">      If Vid is null, then the mesh m_V[] index values are used to set</span>
<span class="cm">      the ON_MeshFaceSide::vi[] values.</span>
<span class="cm">      If Vid is not null, then it must be an array of length VertexCount().</span>
<span class="cm">      The value Vid[mesh m_V[] index] will be used to set the</span>
<span class="cm">      ON_MeshFaceSide::vi[] values.</span>
<span class="cm">    sides - [out]</span>
<span class="cm">      If the input value of sides is not null, then sides[] must be long</span>
<span class="cm">      enough to hold the returned side list.  The maximum posssible length</span>
<span class="cm">      is 4*FaceCount() for a mesh contining FaceCount() nondegenerate quads.</span>
<span class="cm">      If the input value of sides is null, memory will be allocated using</span>
<span class="cm">      onmalloc() and the caller is responsible for calling onfree() at an</span>
<span class="cm">      appropriate time.  This function fills in the sides[] array</span>
<span class="cm">      with face side information.  The returned list is sorted by sides[].fi</span>
<span class="cm">      and the sides[].side and each element has vi[0] &lt;= vi[1].</span>
<span class="cm">      The function ON_SortMeshFaceSidesByVertexIndex() can be used to sort the</span>
<span class="cm">      list by the sides[].vi[] values.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of elements added to sides[].</span>
<span class="cm">  Remarks:</span>
<span class="cm">    Faces with out of range ON_MeshFace.vi[] values are skipped.</span>
<span class="cm">    Degenerate faces are processed, but degenerate sides (equal vertex indices)</span>
<span class="cm">    are not added to the list.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetMeshFaceSideList</span><span class="p">(</span>
      <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">Vid</span><span class="p">,</span>
      <span class="k">struct</span> <span class="n">ON_MeshFaceSide</span><span class="o">*&amp;</span> <span class="n">sides</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get a list of the geometrically uniqued edges in a mesh.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    edge_list - [out]</span>
<span class="cm">      The edge list for this mesh is appended to edge_list[].</span>
<span class="cm">      The ON_2dex i and j values are mesh-&gt;m_V[] array indices.</span>
<span class="cm">      There is exactly one element in edge_list[] for each</span>
<span class="cm">      unoriented 3d line segment in the mesh. The edges are</span>
<span class="cm">      oriented the same way the corresponding ON_MeshTopology</span>
<span class="cm">      edge is oriented.</span>
<span class="cm">    ci_meshtop_edge_map - [out]</span>
<span class="cm">      If you call the verson of GetMeshEdgeList() with the ci_meshtop_edge_map[],</span>
<span class="cm">      parameter, then the edge in edge_list[i] cooresponds to the edge</span>
<span class="cm">      in ON_MeshTopology.m_tope[ci_meshtop_edge_map[i]]. The value</span>
<span class="cm">      ci_meshtop_edge_map[i] is useful if you need to convert an edge_list[]</span>
<span class="cm">      index into an ON_COMPONENT_INDEX with type meshtop_edge.</span>
<span class="cm">    ci_meshtop_vertex_map - [out]</span>
<span class="cm">      If you call the verson of GetMeshEdgeList() with the ci_meshtop_vertex_map[],</span>
<span class="cm">      parameter, then the vertex m_V[i] cooresponds to the vertex</span>
<span class="cm">      in ON_MeshTopology.m_topv[ci_meshtop_vertex_map[i]]. The value</span>
<span class="cm">      ci_meshtop_vertex_map[i] is useful if you need to convert an m_V[]</span>
<span class="cm">      index into an ON_COMPONENT_INDEX with type meshtop_vertex.</span>
<span class="cm">    edge_list_partition - [out] (can be null)</span>
<span class="cm">      The edge_list[] is always ordered so that edge_types</span>
<span class="cm">      are partitioned into contiguous regions. The edge_list_partition[5]</span>
<span class="cm">      values report the edge type regions.</span>
<span class="cm">      * If edge_type_partition[0] &lt;= ei &lt; edge_type_partition[1], then</span>
<span class="cm">        edge_list[ei] is an edge of exactly two faces and the vertices</span>
<span class="cm">        used by the faces are identical.  These are also called</span>
<span class="cm">        &quot;manifold edges&quot;.</span>
<span class="cm">      * If edge_type_partition[1] &lt;= ei &lt; edge_type_partition[2], then</span>
<span class="cm">        edge_list[ei] is an edge of exactly two faces, but at least</span>
<span class="cm">        one of the vertices is duplicated.  These are also called</span>
<span class="cm">        &quot;crease edges&quot;.</span>
<span class="cm">      * If edge_type_partition[2] &lt;= ei &lt; edge_type_partition[3], then</span>
<span class="cm">        edge_list[ei] is an edge of 3 or more faces. These are also called</span>
<span class="cm">        &quot;nonmanifold edges&quot;.</span>
<span class="cm">      * If edge_type_partition[3] &lt;= ei &lt; edge_type_partition[4],</span>
<span class="cm">        then edge_list[ei] is a boundary edge of exactly one mesh face.</span>
<span class="cm">        These are also called &quot;naked edges&quot;.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Number of edges added to edge_list[].</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This calculation also sets m_closed.  If you modify the mesh&#39;s</span>
<span class="cm">    m_V or m_F information after calling this function, be sure to</span>
<span class="cm">    clear m_is_closed.</span>
<span class="cm">  */</span>
  <span class="kt">int</span> <span class="nf">GetMeshEdgeList</span><span class="p">(</span>
      <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dex</span><span class="o">&gt;&amp;</span> <span class="n">edge_list</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">edge_type_partition</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">GetMeshEdgeList</span><span class="p">(</span>
      <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dex</span><span class="o">&gt;&amp;</span> <span class="n">edge_list</span><span class="p">,</span>
      <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">ci_meshtop_edge_map</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">edge_type_partition</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">GetMeshEdgeList</span><span class="p">(</span>
      <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_2dex</span><span class="o">&gt;&amp;</span> <span class="n">edge_list</span><span class="p">,</span>
      <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">ci_meshtop_edge_map</span><span class="p">,</span>
      <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">ci_meshtop_vertex_map</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">edge_type_partition</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
      <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">///////////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// mesh editing</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Replace a mesh edge with a vertex at its center and update</span>
<span class="cm">    adjacent faces as needed.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    topei - [in] index of edge in MeshTopology().m_tope[] array</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if successful.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">CollapseEdge</span><span class="p">(</span> <span class="kt">int</span> <span class="n">topei</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Tests a mesh edge to see if it is valid as input to</span>
<span class="cm">    ON_Mesh::SwapMeshEdge.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    topei - [in] index of edge in MeshTopology().m_tope[] array</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if edge can be swapped by ON_Mesh::SwapMeshEdge.</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Mesh::SwapEdge</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">IsSwappableEdge</span><span class="p">(</span> <span class="kt">int</span> <span class="n">topei</span> <span class="p">);</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If the edge is shared by two triangular face, then</span>
<span class="cm">    the edge is &quot;swapped&quot;.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    topei - [in] index of edge in MeshTopology().m_tope[] array</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if successful</span>
<span class="cm">  See Also:</span>
<span class="cm">    ON_Mesh::IsSwappableEdge</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SwapEdge</span><span class="p">(</span> <span class="kt">int</span> <span class="n">topei</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Removes a face from a mesh and does not alter the</span>
<span class="cm">    geometry of the remaining mesh.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    meshfi - [in] index of face in ON_Mesh.m_F[] array</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This function calls DestroyTopology() and DestroyPartition().</span>
<span class="cm">    The caller is responsible for calling Compact() if that step</span>
<span class="cm">    is required.</span>
<span class="cm">  Returns:</span>
<span class="cm">    true if successful</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">DeleteFace</span><span class="p">(</span> <span class="kt">int</span> <span class="n">meshfi</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Destroys the m_H[] array and sets m_hidden_count=0.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DestroyHiddenVertexArray</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    If the mesh has some hidden vertices, then an array</span>
<span class="cm">    of length VertexCount() is returned and the i-th</span>
<span class="cm">    element is true if the i-th vertex is hidden.</span>
<span class="cm">    If no vertices are hidden, NULL is returned.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="kt">bool</span><span class="o">*</span> <span class="nf">HiddenVertexArray</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Set the runtime vertex hidden flag.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    meshvi - [in] mesh vertex index</span>
<span class="cm">    bHidden - [in] true to hide vertex</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetVertexHiddenFlag</span><span class="p">(</span> <span class="kt">int</span> <span class="n">meshvi</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bHidden</span> <span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns true if the mesh vertex is hidden.  This is a runtime</span>
<span class="cm">    setting that is not saved in 3dm files.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    meshvi - [in] mesh vertex index.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if mesh vertex is hidden.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">VertexIsHidden</span><span class="p">(</span> <span class="kt">int</span> <span class="n">meshvi</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Returns true if the mesh face is hidden.  This is a runtime</span>
<span class="cm">    setting that is not saved in 3dm files.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    meshfi - [in] mesh face index.</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if mesh face is hidden.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    A face is hidden if, and only if, at least one of its</span>
<span class="cm">    vertices is hidden.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">FaceIsHidden</span><span class="p">(</span> <span class="kt">int</span> <span class="n">meshvi</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">///////////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// mesh topology</span>
  <span class="c1">//</span>
  <span class="c1">// In order to keep the mesh facet definition simple and make the mesh</span>
  <span class="c1">// definition easily used in common rendering application, if two facets</span>
  <span class="c1">// share a vertex location but have different normals, curvatures,</span>
  <span class="c1">// textures, etc., at that common vertex location, then the vertex is</span>
  <span class="c1">// duplicated.  When the topology of the mesh needs to be known,</span>
  <span class="c1">// use Topology() to get a class that provides complete topological</span>
  <span class="c1">// information about the mesh.</span>
  <span class="k">const</span> <span class="n">ON_MeshTopology</span><span class="o">&amp;</span> <span class="n">Topology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">///////////////////////////////////////////////////////////////////////</span>
  <span class="c1">// If you modify the mesh in any way that may change its topology,</span>
  <span class="c1">// then call DestroyTopology().  Specifically if you add or remove</span>
  <span class="c1">// vertices or face, change vertex locations, or change the face m_vi[]</span>
  <span class="c1">// values, then you must call DestroyTopology().</span>
  <span class="kt">void</span> <span class="nf">DestroyTopology</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    This is an expert user function that returns true if the topology</span>
<span class="cm">    information is already calculated and cached.  It can be used to</span>
<span class="cm">    to avoid calling the Topology() function when the expensive creation</span>
<span class="cm">    step will be performed.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">TopologyExists</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">///////////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// mesh partitions</span>
  <span class="c1">//</span>
  <span class="c1">// In ancient times, some rendering engines were only able to process</span>
  <span class="c1">// small batches of triangles and th CreatePartition() function was</span>
  <span class="c1">// provided to partition the mesh into subsets of vertices and faces</span>
  <span class="c1">// that those renering engines could handle.</span>
  <span class="c1">//</span>
  <span class="k">const</span> <span class="n">ON_MeshPartition</span><span class="o">*</span> <span class="nf">CreatePartition</span><span class="p">(</span>
                <span class="kt">int</span><span class="p">,</span> <span class="c1">// maximum number of vertices in a partition</span>
                <span class="kt">int</span>  <span class="c1">// maximum number of triangles in a partition</span>
                <span class="p">);</span>
  <span class="k">const</span> <span class="n">ON_MeshPartition</span><span class="o">*</span> <span class="nf">Partition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">DestroyPartition</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Extract the portion of this mesh defined by mesh_part.</span>
<span class="cm">  Parameters:</span>
<span class="cm">    mesh_part - [in]</span>
<span class="cm">      defines portion of the mesh to extract.</span>
<span class="cm">    mesh - [in] (can be null, cannot be = &quot;this).</span>
<span class="cm">      If mesh is no null, the extracted mesh will be put into</span>
<span class="cm">      this mesh.  If mesh is null, the extracted mesh will</span>
<span class="cm">      be created in a mesh allocated on the heap using the</span>
<span class="cm">      new operator.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to the submesh.  If the input mesh parameter is null,</span>
<span class="cm">    then the caller must delete this mesh when it is no longer needed.</span>
<span class="cm">    If the input is invalid, then null is returned.</span>
<span class="cm">  */</span>
  <span class="n">ON_Mesh</span><span class="o">*</span> <span class="nf">MeshPart</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ON_MeshPart</span><span class="o">&amp;</span> <span class="n">mesh_part</span><span class="p">,</span>
    <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">mesh</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Create a mesh that is a single face of this mesh.</span>
<span class="cm">  Parameters:</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to the submesh.  If the input mesh parameter is null,</span>
<span class="cm">    then the caller must delete this mesh when it is no longer needed.</span>
<span class="cm">    If the input is invalid, then null is returned.</span>
<span class="cm">  */</span>
  <span class="n">ON_Mesh</span><span class="o">*</span> <span class="nf">DuplicateFace</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">face_index</span><span class="p">,</span>
    <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">mesh</span>
    <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">///////////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// mesh N-gon lists.</span>
  <span class="c1">//   ON_Mesh objects support faces that are triangle or quads.</span>
  <span class="c1">//   When a mesh is created from a format that supports N-gons</span>
  <span class="c1">//   for N larger than 4, an optional N-gon list can be added</span>
  <span class="c1">//   that specifies the vertices and faces that make up the N-gon.</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If the mesh has an N-gon list, return a pointer to it.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to the current N-gon list or NULL.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="k">class</span> <span class="nc">ON_MeshNgonList</span><span class="o">*</span> <span class="nf">NgonList</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If an N-gon list exists, it is returned and can be modified.</span>
<span class="cm">    If no N-gon list exists, a new empty list is returned and</span>
<span class="cm">    it can be modified.</span>
<span class="cm">  Returns:</span>
<span class="cm">    A pointer to the N-gon list that can be modified.</span>
<span class="cm">  */</span>
  <span class="k">class</span> <span class="nc">ON_MeshNgonList</span><span class="o">*</span> <span class="nf">ModifyNgonList</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Destroy any existing N-gon list.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DestroyNgonList</span><span class="p">();</span>

  <span class="c1">///////////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// mesh components</span>
  <span class="c1">//   ON_Mesh objects can consist of sets of faces that are isolated</span>
  <span class="c1">//   from any other sets of faces.  The following 2 functions will</span>
  <span class="c1">//   dissect a mesh into these sets, called components.  Not to be</span>
  <span class="c1">//   confused with ON_COMPONENT_INDEX.</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Calculates the components of a mesh and sets a label for each face in</span>
<span class="cm">      the facet_component_labels array.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      bUseVertexConnections- [in]</span>
<span class="cm">        If this parameter is true, then facets that share a common vertex</span>
<span class="cm">        are considered connected.</span>
<span class="cm">        If this parameter is false, then facets must share an edge to</span>
<span class="cm">        be considered connected.</span>
<span class="cm">      bUseTopologicalConnections - [in]</span>
<span class="cm">        If this parameter is true, then geometric location is used</span>
<span class="cm">        to determine if facets are connected.</span>
<span class="cm">        If this parameter is false, then facets must share the same vertex</span>
<span class="cm">        or vertices to be considered connected.</span>
<span class="cm">      facet_component_labels- [out]</span>
<span class="cm">        facet_component_labels[] will be an array with the same size</span>
<span class="cm">        as ON_Mesh.m_F.Count() and facet_component_labels[i]</span>
<span class="cm">        is the component id m_F[i] belongs to.  The component id</span>
<span class="cm">        will be 1 to the number of compoents.</span>
<span class="cm">    Returns:</span>
<span class="cm">      Number of components on success, 0 on failure</span>
<span class="cm">  */</span>

  <span class="kt">int</span> <span class="nf">GetConnectedComponents</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bUseVertexConnections</span><span class="p">,</span>
                              <span class="kt">bool</span> <span class="n">bTopologicalConnections</span><span class="p">,</span>
                              <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">facet_component_labels</span>
                            <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">    Description:</span>
<span class="cm">      Calculates the components of a mesh and sets a label for each face in</span>
<span class="cm">      the facet_component_labels array.</span>
<span class="cm">    Parameters:</span>
<span class="cm">      bUseVertexConnections- [in]</span>
<span class="cm">        If this parameter is true, then facets that share a common vertex</span>
<span class="cm">        are considered connected.</span>
<span class="cm">        If this parameter is false, then facets must share an edge to</span>
<span class="cm">        be considered connected.</span>
<span class="cm">      bUseTopologicalConnections - [in]</span>
<span class="cm">        If this parameter is true, then geometric location is used</span>
<span class="cm">        to determine if facets are connected.</span>
<span class="cm">        If this parameter is false, then facets must share the same vertex</span>
<span class="cm">        or vertices to be considered connected.</span>
<span class="cm">      components   - [out]</span>
<span class="cm">        New components are appended to this array</span>
<span class="cm">        if this parameter is null, then the components are just counted.</span>
<span class="cm">    Returns:</span>
<span class="cm">      Number of components on success, 0 on failure</span>
<span class="cm">  */</span>

  <span class="kt">int</span> <span class="nf">GetConnectedComponents</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">bUseVertexConnections</span><span class="p">,</span>
                              <span class="kt">bool</span> <span class="n">bTopologicalConnections</span><span class="p">,</span>
                              <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Mesh</span><span class="o">*&gt;*</span> <span class="n">components</span>
                            <span class="p">)</span> <span class="k">const</span><span class="p">;</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">//</span>
  <span class="c1">// Double precision vertex support</span>
  <span class="c1">//</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the mesh has single and double precision</span>
<span class="cm">    vertices, and the values of the two sets are synchronized.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">HasSynchronizedDoubleAndSinglePrecisionVertices</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the mesh has double precision vertices.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    This function returns true if a mesh has double</span>
<span class="cm">    precision vertex information, even if it is not</span>
<span class="cm">    updated.</span>

<span class="cm">    Use ON_Mesh::DoublePrecisionVerticesAreValid()</span>
<span class="cm">    and ON_Mesh::SinglePrecisionVerticesAreValid() to</span>
<span class="cm">    check the validity.</span>

<span class="cm">    Use ON_Mesh::UpdateDoublePrecisionVertices()</span>
<span class="cm">    or ON_Mesh::UpdateSinglePrecisionVertices() to synchronize</span>
<span class="cm">    values of single and double precision vertices.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">HasDoublePrecisionVertices</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Parameters:</span>
<span class="cm">    bEnableDoublePrecisionVertices - [in]</span>
<span class="cm">      True to enable use of double precision vertices.</span>
<span class="cm">      False to destroy any existing precision vertices.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">EnableDoublePrecisionVertices</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bEnableDoublePrecisionVertices</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If you modify the values of double precision vertices,</span>
<span class="cm">    then you must call UpdateSinglePrecisonVertices().</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If double precision vertices are not present, this function</span>
<span class="cm">    does nothing.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">UpdateSinglePrecisionVertices</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If you modify the values of the single precision vertices</span>
<span class="cm">    in m_V[], then you must call UpdateDoublePrecisionVertices().</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If double precision vertices are not present, this function</span>
<span class="cm">    does nothing.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">UpdateDoublePrecisionVertices</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If you have modified the single precision vertices</span>
<span class="cm">    and are certain they are valid, then call this</span>
<span class="cm">    function to update crc information.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If double precision vertices are not present, this function</span>
<span class="cm">    does nothing.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetSinglePrecisionVerticesAsValid</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    If you have modified the double precision vertices</span>
<span class="cm">    and are certain they are valid, then call this</span>
<span class="cm">    function to update crc information.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If double precision vertices are not present, this function</span>
<span class="cm">    does nothing.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">SetDoublePrecisionVerticesAsValid</span><span class="p">();</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    The functions UpdateSinglePrecisionVertices(),</span>
<span class="cm">    UpdateDoublePrecisionVertices(), and</span>
<span class="cm">    SetSinglePrecisionVerticesAsValid() save</span>
<span class="cm">    the count and crc of the single precision vertex</span>
<span class="cm">    array. True is returned if there are no</span>
<span class="cm">    double precision vertices or the current</span>
<span class="cm">    count and crc of the single precision</span>
<span class="cm">    vertex array match the saved values.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If double precision vertices are not present, this function</span>
<span class="cm">    does nothing and returns true.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">SinglePrecisionVerticesAreValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    The functions UpdateSinglePrecisionVertices(),</span>
<span class="cm">    UpdateDoublePrecisionVertices(), and</span>
<span class="cm">    SetDoublePrecisionVerticesAsValid() save</span>
<span class="cm">    the count and crc of the double precision vertex</span>
<span class="cm">    array. True is returned if the current</span>
<span class="cm">    count and crc of the double precision</span>
<span class="cm">    vertex array match the saved values.</span>
<span class="cm">  Remarks:</span>
<span class="cm">    If double precision vertices are not present, this function</span>
<span class="cm">    does nothing and returns true.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">DoublePrecisionVerticesAreValid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    The function removes all double precision vertex information.</span>
<span class="cm">  */</span>
  <span class="kt">void</span> <span class="nf">DestroyDoublePrecisionVertices</span><span class="p">();</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - mesh geometry</span>

  <span class="c1">// Vertex locations</span>
  <span class="c1">//   In a case where adjacent facets share a vertex</span>
  <span class="c1">//   location but have distinct normals or texture</span>
  <span class="c1">//   coordinates at that location, the vertex must</span>
  <span class="c1">//   be duplicated.</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get double precision vertices.  If they do not exist,</span>
<span class="cm">    they will be created and match the existing single</span>
<span class="cm">    precision vertices.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Array of double precision vertices.  If you modify the</span>
<span class="cm">    values in this array, you must make the same modifications</span>
<span class="cm">    to the single precision vertices, or call</span>
<span class="cm">    UpdateSinglePrecisonVertices().</span>
<span class="cm">  Example:</span>

<span class="cm">          // add a bunch of double precision information</span>
<span class="cm">          ON_3dPointArray&amp; dv = mesh.DoublePrecisionVertices();</span>
<span class="cm">          for ( i = 0; i &lt; lots; i++ )</span>
<span class="cm">          {</span>
<span class="cm">            dv[i] = ...</span>
<span class="cm">          }</span>
<span class="cm">          // This call updates the single precison values</span>
<span class="cm">          // in m_V[] and sets all the counts and CRCs that</span>
<span class="cm">          // are used in validity checking.</span>
<span class="cm">          mesh.UpdateSinglePrecisonVertices();</span>

<span class="cm">  Remarks:</span>
<span class="cm">    Avoid mulitple calls to DoublePrecisionVertices().</span>
<span class="cm">    It is most efficient to make one call, save a local</span>
<span class="cm">    reference, and use the local reference as needed.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPointArray</span><span class="o">&amp;</span> <span class="n">DoublePrecisionVertices</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">ON_3dPointArray</span><span class="o">&amp;</span> <span class="n">DoublePrecisionVertices</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Get single precision vertices.</span>
<span class="cm">  Returns:</span>
<span class="cm">    Array of float precision vertices.  If you modify the</span>
<span class="cm">    values in this array, you must make the same modifications</span>
<span class="cm">    to the double precision vertices, or call</span>
<span class="cm">    UpdateSinglePrecisonVertices().</span>
<span class="cm">  */</span>
  <span class="n">ON_3fPointArray</span><span class="o">&amp;</span> <span class="n">SinglePrecisionVertices</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">ON_3fPointArray</span><span class="o">&amp;</span> <span class="n">SinglePrecisionVertices</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    In general,use one of</span>
<span class="cm">    ON_Mesh::SinglePrecisionVertices()</span>
<span class="cm">    or</span>
<span class="cm">    ON_Mesh::DoublePrecisionVertices()</span>
<span class="cm">    to get the array of vertex locations.  If you modify</span>
<span class="cm">    m_V[] directly and HasDoublePrecisionVertices() is true,</span>
<span class="cm">    then you must make the same modifications to the array</span>
<span class="cm">    returned by DoublePrecisionVertices().</span>
<span class="cm">  */</span>
  <span class="n">ON_3fPointArray</span> <span class="n">m_V</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    Location of the vertex.  If double precision vertices</span>
<span class="cm">    are present, the double precision vertex location is</span>
<span class="cm">    returned.  If vertex_index is out of range,</span>
<span class="cm">    ON_UNSET_VALUE is returned.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Vertex</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex_index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// m_F[] facets (triangles or quads)</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_MeshFace</span><span class="o">&gt;</span> <span class="n">m_F</span><span class="p">;</span>

  <span class="c1">// m_N[] OPTIONAL vertex unit normals</span>
  <span class="c1">// If m_N[] is empty or m_N.Count() != m_V.Count(),</span>
  <span class="c1">// Either m_N[] has zero count or it m_N[j] is the</span>
  <span class="c1">// the unit vertex normal at m_V[j].</span>
  <span class="n">ON_3fVectorArray</span> <span class="n">m_N</span><span class="p">;</span>

  <span class="c1">// m_FN[] OPTIONAL face unit normals</span>
  <span class="c1">// If m_FN[] is empty or m_FN.Count() != m_F.Count(),</span>
  <span class="c1">// then m_FN is ignored.  Otherwise m_FN[j] is the</span>
  <span class="c1">// unit normal for the facet m_F[j].</span>
  <span class="n">ON_3fVectorArray</span> <span class="n">m_FN</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - texture coordinates</span>
  <span class="c1">//</span>
  <span class="c1">// OPTIONAL texture coordinates for each vertex</span>

  <span class="c1">// It would be nice if this were an ON_TextureCoordinates,</span>
  <span class="c1">// but that breaks lots of checked out code that assumes</span>
  <span class="c1">// m_T is an array of ON_2fPoints.</span>
  <span class="n">ON_MappingTag</span> <span class="n">m_Ttag</span><span class="p">;</span> <span class="c1">// OPTIONAL tag for values in m_T[]</span>
  <span class="n">ON_2fPointArray</span> <span class="n">m_T</span><span class="p">;</span>  <span class="c1">// OPTIONAL texture coordinates for each vertex</span>

  <span class="c1">// RUNTIME ONLY</span>
  <span class="c1">//   This array is used to cache texture coordinates used by</span>
  <span class="c1">//   rendering applications that require 1d texture coordinates,</span>
  <span class="c1">//   3d texture coordinates, or multiple sets of texture</span>
  <span class="c1">//   coordinates (e.g. blended textures with different mappings).</span>
  <span class="c1">//   Users are responsible for verifying</span>
  <span class="c1">//   m_TC[i].m_T.Count() = m_V.Count()</span>
  <span class="n">ON_ClassArray</span><span class="o">&lt;</span><span class="n">ON_TextureCoordinates</span><span class="o">&gt;</span> <span class="n">m_TC</span><span class="p">;</span>

  <span class="c1">// If m_T.Count() == m_V.Count(), then the mesh has texture coordinates</span>
  <span class="c1">// and m_T[j] is the texture coordinate for vertex m_V[j].</span>
  <span class="c1">//</span>
  <span class="c1">// When opennurbs or Rhino meshes an ON_Surface or ON_Brep, the texture</span>
  <span class="c1">// coordinates have a &quot;canonical&quot; linear relationship with the surface</span>
  <span class="c1">// parameters that is described in the next section.  However, various</span>
  <span class="c1">// mappings, spherical, planar, cylindrical, etc., can be applied that</span>
  <span class="c1">// change the values of the texture coordinates.</span>
  <span class="c1">//</span>
  <span class="c1">// If a texture mapping function was used to set the m_T[] values,</span>
  <span class="c1">// then the id and serial number of the mapping function is saved</span>
  <span class="c1">// in m_mapping_id and m_mapping_sn. The intended use of these fields</span>
  <span class="c1">// is to make it easy to avoid unnecessary recalculation.</span>
  <span class="c1">// If a mesh is modified, then m_mapping_id should be set to nil</span>
  <span class="c1">// and m_mapping_crc should be set to 0.</span>
  <span class="c1">//</span>
  <span class="c1">/////////////////////////////////////////////////////////////////</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - surface parameters and packed texture</span>
  <span class="c1">// information</span>
  <span class="c1">//</span>
  <span class="c1">// If m_S.Count() == m_V.Count(), then the mesh is a tesselation</span>
  <span class="c1">// of a parameteric surface and m_S[j] is the surface parameter at</span>
  <span class="c1">// m_V[j].  Storing values in m_S[] is OPTIONAL.</span>
  <span class="c1">//</span>
  <span class="c1">// If m_srf_scale[] has positive values, then they report</span>
  <span class="c1">// the world coordinate size of a rectangle that would</span>
  <span class="c1">// minimize texture distortion if it were mapped to the</span>
  <span class="c1">// mesh using normalized surface evaluation parameters.</span>
  <span class="c1">// This information is used to calculate high quality</span>
  <span class="c1">// packed texture coordinates.</span>
  <span class="n">ON_2dPointArray</span> <span class="n">m_S</span><span class="p">;</span>
  <span class="n">ON_Interval</span> <span class="n">m_srf_domain</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// surface evaluation domain.</span>
  <span class="kt">double</span> <span class="n">m_srf_scale</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>


  <span class="c1">// Packed texture information.</span>
  <span class="c1">//</span>
  <span class="c1">// If either of the m_packed_tex_domain[] intervals is a</span>
  <span class="c1">// proper subinterval of (0,1), then a texture packing</span>
  <span class="c1">// calculation assigned this subrectangle to this mesh.</span>

  <span class="n">ON_Interval</span> <span class="n">m_packed_tex_domain</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="c1">// The m_packed_tex_rotate setting is valid only when</span>
  <span class="c1">// m_S, m_srf_domain, m_packed_scale[] and</span>
  <span class="c1">// m_packed_tex_domain[] are all valid and the texture</span>
  <span class="c1">// coordinates are based on surface evaluation parameters.</span>
  <span class="c1">// In this special situation, this boolean records the</span>
  <span class="c1">// correspondence between the the surface parameters, (u,v),</span>
  <span class="c1">// and the packed texture coordinates, (s,t),</span>
  <span class="c1">//</span>
  <span class="c1">//   m_packed_tex_rotate = false:</span>
  <span class="c1">//     a = m_srf_domain[0].NormalizedParameterAt(u);</span>
  <span class="c1">//     b = m_srf_domain[1].NormalizedParameterAt(v);</span>
  <span class="c1">//     s = m_packed_tex_domain[0].ParameterAt(a);</span>
  <span class="c1">//     t = m_packed_tex_domain[1].ParameterAt(b);</span>
  <span class="c1">//</span>
  <span class="c1">//     x = m_packed_tex_domain[0].NormalizedParameterAt(s);</span>
  <span class="c1">//     y = m_packed_tex_domain[1].NormalizedParameterAt(t);</span>
  <span class="c1">//     u = m_srf_domain[0].ParameterAt(x);</span>
  <span class="c1">//     v = m_srf_domain[1].ParameterAt(y);</span>
  <span class="c1">//</span>
  <span class="c1">//   m_packed_tex_rotate = true:</span>
  <span class="c1">//     a = m_srf_domain[0].NormalizedParameterAt(u);</span>
  <span class="c1">//     b = m_srf_domain[1].NormalizedParameterAt(v);</span>
  <span class="c1">//     s = m_packed_tex_domain[0].ParameterAt(a);</span>
  <span class="c1">//     t = m_packed_tex_domain[1].ParameterAt(1.0-b);</span>
  <span class="c1">//</span>
  <span class="c1">//     x = m_packed_tex_domain[0].NormalizedParameterAt(s);</span>
  <span class="c1">//     y = m_packed_tex_domain[1].NormalizedParameterAt(t);</span>
  <span class="c1">//     u = m_srf_domain[0].ParameterAt(y);</span>
  <span class="c1">//     v = m_srf_domain[1].ParameterAt(1.0 - x);</span>
  <span class="kt">bool</span> <span class="n">m_packed_tex_rotate</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    True if the m_srf_scale[] values are positive and</span>
<span class="cm">    the m_packed_tex_domain[] intervals are set to values</span>
<span class="cm">    that describe a proper subrectangle of (0,1)x(0,1).</span>
<span class="cm">    True does not necessarily mean the current values in</span>
<span class="cm">    m_T[] are packed texture coordinates.</span>
<span class="cm">  */</span>
  <span class="kt">bool</span> <span class="nf">HasPackedTextureRegion</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - curvature</span>

  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_SurfaceCurvature</span><span class="o">&gt;</span> <span class="n">m_K</span><span class="p">;</span>  <span class="c1">// OPTIONAL surface curvatures</span>
                                            <span class="c1">// Either m_K[] has zero count or it has the same</span>
                                            <span class="c1">// count as m_V[], in which case m_K[j] reports</span>
                                            <span class="c1">// the surface curvatures at m_V[j].</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - false color</span>
  <span class="n">ON_MappingTag</span> <span class="n">m_Ctag</span><span class="p">;</span> <span class="c1">// OPTIONAL tag for values in m_C[]</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="n">ON_Color</span><span class="o">&gt;</span> <span class="n">m_C</span><span class="p">;</span>  <span class="c1">// OPTIONAL vertex color</span>
                                 <span class="c1">// Either m_C[] has zero count or it has the same</span>
                                 <span class="c1">// count as m_V[], in which case m_C[j] reports</span>
                                 <span class="c1">// the color assigned to m_V[j].</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - runtime vertex visibility - not saved in 3dm files.</span>
  <span class="n">ON_SimpleArray</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">m_H</span><span class="p">;</span> <span class="c1">// OPTIONAL vertex visibility.</span>
                            <span class="c1">// If m_H.Count() = m_V.Count(), then</span>
                            <span class="c1">// m_H[vi] is true if the vertex m_V[vi]</span>
                            <span class="c1">// is hidden.  Otherwise, all vertices are visible.</span>
  <span class="kt">int</span> <span class="n">m_hidden_count</span><span class="p">;</span>       <span class="c1">// number of vertices that are hidden</span>
                            <span class="c1">// = number of true values in m_H[] array.</span>

  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - runtime UI information</span>
  <span class="k">const</span> <span class="n">ON_Object</span><span class="o">*</span> <span class="n">m_parent</span><span class="p">;</span> <span class="c1">// runtime parent geometry (use ...::Cast() to get it)</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_MeshVertexRef</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_MeshEdgeRef</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ON_MeshFaceRef</span><span class="p">;</span>


  <span class="c1">/////////////////////////////////////////////////////////////////</span>
  <span class="c1">// Implementation - mesh topology</span>
  <span class="n">ON_MeshTopology</span> <span class="n">m_top</span><span class="p">;</span>

  <span class="n">ON_MeshParameters</span><span class="o">*</span> <span class="n">m_mesh_parameters</span><span class="p">;</span> <span class="c1">// If mesh was created from a parametric surface,</span>
                                        <span class="c1">// these parameters were used to create the mesh.</span>
  <span class="kt">int</span>                         <span class="n">m_invalid_count</span><span class="p">;</span>
  <span class="kt">int</span>                         <span class="n">m_quad_count</span><span class="p">;</span>
  <span class="kt">int</span>                         <span class="n">m_triangle_count</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">char</span> <span class="n">m_mesh_is_closed</span><span class="p">;</span>   <span class="c1">// 0 = unset, 1 = all edges have 2 or more faces, 2 = at least one boundary edge</span>
  <span class="kt">char</span> <span class="n">m_mesh_is_manifold</span><span class="p">;</span> <span class="c1">// 0 = unset, 1 = all edges have 1 or 2 faces, 2 = not manifold</span>
  <span class="kt">char</span> <span class="n">m_mesh_is_oriented</span><span class="p">;</span> <span class="c1">// 0 = unset, 1 = faces normals agree across all edges that have 2 faces, 2 = not oriented</span>
  <span class="kt">char</span> <span class="n">m_mesh_is_solid</span><span class="p">;</span>    <span class="c1">// 0 = unset, 1 = solid with outward face normals, 2 = solid with inward face normals, 3 = not solid</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="c1">// The bounding boxes are valid if m_?box[0][0] &lt;= m_?box[0][1];</span>
  <span class="kt">float</span> <span class="n">m_vbox</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 3d bounding box of all referenced vertices</span>
  <span class="kt">float</span> <span class="n">m_nbox</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 3d bounding box of all referenced unit normals</span>
                      <span class="c1">// (for estimation of Gauss map bounds)</span>
  <span class="kt">float</span> <span class="n">m_tbox</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 2d bounding box of all referenced texture coordinates</span>
  <span class="n">ON_MeshCurvatureStats</span><span class="o">*</span> <span class="n">m_kstat</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// gaussian,mean,min,max,sectionx,sectiony,sectionz</span>

  <span class="c1">// sub-mesh information rendering large meshes</span>
  <span class="n">ON_MeshPartition</span><span class="o">*</span> <span class="n">m_partition</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">Write_1</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// uncompressed 1.x format</span>
  <span class="kt">bool</span> <span class="nf">Write_2</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// compressed 2.x format</span>
  <span class="kt">bool</span> <span class="nf">Read_1</span><span class="p">(</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">Read_2</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">WriteFaceArray</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">ReadFaceArray</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ON_BinaryArchive</span><span class="o">&amp;</span> <span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">SwapEdge_Helper</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span> <span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_MeshVertexRef</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_MeshVertexRef</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MeshVertexRef</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshVertexRef</span><span class="p">();</span>
  <span class="n">ON_MeshVertexRef</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshVertexRef</span><span class="o">&amp;</span><span class="p">);</span>


  <span class="c1">// parent mesh</span>
  <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">m_mesh</span><span class="p">;</span>

  <span class="c1">// m_mesh-&gt;m_V[] index</span>
  <span class="c1">// (can be -1 when m_top_vi references a shared vertex location)</span>
  <span class="kt">int</span> <span class="n">m_mesh_vi</span><span class="p">;</span>

  <span class="c1">// m_mesh-&gt;m_top.m_tope[] index</span>
  <span class="kt">int</span> <span class="n">m_top_vi</span><span class="p">;</span>


  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Override of the virtual ON_Geometry::ComponentIndex().</span>
<span class="cm">  Returns:</span>
<span class="cm">    A component index for the vertex.  The type of the returned</span>
<span class="cm">    component index can be</span>
<span class="cm">    ON_COMPONENT_INDEX::mesh_vertex,</span>
<span class="cm">    ON_COMPONENT_INDEX::meshtop_vertex, or</span>
<span class="cm">    ON_COMPONENT_INDEX::invalid_type.</span>
<span class="cm">  */</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The mesh topology associated with this</span>
<span class="cm">    mesh vertex reference or NULL if it doesn&#39;t</span>
<span class="cm">    exist.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_MeshTopology</span><span class="o">*</span> <span class="nf">MeshTopology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The 3d location of the mesh vertex.  Returns</span>
<span class="cm">    ON_UNSET_POINT is this ON_MeshVertexRef is not</span>
<span class="cm">    valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_3dPoint</span> <span class="nf">Point</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The mesh topology vertex associated with this</span>
<span class="cm">    mesh vertex reference.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_MeshTopologyVertex</span><span class="o">*</span> <span class="nf">MeshTopologyVertex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides of virtual ON_Object functions</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides of virtual ON_Geometry functions</span>
  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmin</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmax</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span>
         <span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_MeshEdgeRef</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_MeshEdgeRef</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MeshEdgeRef</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshEdgeRef</span><span class="p">();</span>
  <span class="n">ON_MeshEdgeRef</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshEdgeRef</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// parent mesh</span>
  <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">m_mesh</span><span class="p">;</span>

  <span class="c1">// m_mesh-&gt;m_top.m_tope[] index</span>
  <span class="kt">int</span> <span class="n">m_top_ei</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Override of the virtual ON_Geometry::ComponentIndex().</span>
<span class="cm">  Returns:</span>
<span class="cm">    A mesh component index for the edge.  The type is</span>
<span class="cm">    ON_COMPONENT_INDEX::meshtop_edge and the index is the</span>
<span class="cm">    index into the ON_MeshTopology.m_tope[] array.</span>
<span class="cm">  */</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The mesh topology associated with this</span>
<span class="cm">    mesh edge reference or NULL if it doesn&#39;t</span>
<span class="cm">    exist.</span>
<span class="cm">  */</span>

  <span class="k">const</span> <span class="n">ON_MeshTopology</span><span class="o">*</span> <span class="nf">MeshTopology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The 3d location of the mesh edge.  Returns</span>
<span class="cm">    ON_UNSET_POINT,ON_UNSET_POINT, is this ON_MeshEdgeRef</span>
<span class="cm">    is not valid.</span>
<span class="cm">  */</span>
  <span class="n">ON_Line</span> <span class="nf">Line</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The mesh topology edge associated with this</span>
<span class="cm">    mesh edge reference.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_MeshTopologyEdge</span><span class="o">*</span> <span class="nf">MeshTopologyEdge</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides of virtual ON_Object functions</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides of virtual ON_Geometry functions</span>
  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmin</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmax</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span>
         <span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ON_CLASS</span> <span class="nl">ON_MeshFaceRef</span> <span class="p">:</span> <span class="k">public</span> <span class="n">ON_Geometry</span>
<span class="p">{</span>
  <span class="n">ON_OBJECT_DECLARE</span><span class="p">(</span><span class="n">ON_MeshFaceRef</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">ON_MeshFaceRef</span><span class="p">();</span>
  <span class="o">~</span><span class="n">ON_MeshFaceRef</span><span class="p">();</span>
  <span class="n">ON_MeshFaceRef</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ON_MeshFaceRef</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// parent mesh</span>
  <span class="k">const</span> <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">m_mesh</span><span class="p">;</span>

  <span class="c1">// m_mesh-&gt;m_F[] and m_mesh-&gt;m_top.m_tope[] index.</span>
  <span class="kt">int</span> <span class="n">m_mesh_fi</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Description:</span>
<span class="cm">    Override of the virtual ON_Geometry::ComponentIndex().</span>
<span class="cm">  Returns:</span>
<span class="cm">    A mesh component index for the face.  The type is</span>
<span class="cm">    ON_COMPONENT_INDEX::mesh_face and the index is the</span>
<span class="cm">    index into the ON_Mesh.m_F[] array.</span>
<span class="cm">  */</span>
  <span class="n">ON_COMPONENT_INDEX</span> <span class="nf">ComponentIndex</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The mesh topology associated with this</span>
<span class="cm">    mesh face reference or NULL if it doesn&#39;t</span>
<span class="cm">    exist.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_MeshTopology</span><span class="o">*</span> <span class="nf">MeshTopology</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The mesh face associated with this mesh face reference.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_MeshFace</span><span class="o">*</span> <span class="nf">MeshFace</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">  Returns:</span>
<span class="cm">    The mesh topology face associated with this</span>
<span class="cm">    mesh face reference.</span>
<span class="cm">  */</span>
  <span class="k">const</span> <span class="n">ON_MeshTopologyFace</span><span class="o">*</span> <span class="nf">MeshTopologyFace</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides of virtual ON_Object functions</span>
  <span class="n">ON_BOOL32</span> <span class="nf">IsValid</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">*</span> <span class="n">text_log</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">Dump</span><span class="p">(</span> <span class="n">ON_TextLog</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">SizeOf</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON</span><span class="o">::</span><span class="n">object_type</span> <span class="n">ObjectType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// overrides of virtual ON_Geometry functions</span>
  <span class="kt">int</span> <span class="nf">Dimension</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">GetBBox</span><span class="p">(</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmin</span><span class="p">,</span>
         <span class="kt">double</span><span class="o">*</span> <span class="n">boxmax</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">bGrowBox</span> <span class="o">=</span> <span class="nb">false</span>
         <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ON_BOOL32</span> <span class="nf">Transform</span><span class="p">(</span>
         <span class="k">const</span> <span class="n">ON_Xform</span><span class="o">&amp;</span> <span class="n">xform</span>
         <span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Calculate a mesh representation of the NURBS surface&#39;s control polygon.</span>
<span class="cm">Parameters:</span>
<span class="cm">  nurbs_surface - [in]</span>
<span class="cm">  bCleanMesh - [in] If true, then degenerate quads are cleaned</span>
<span class="cm">                    up to be triangles. Surfaces with singular</span>
<span class="cm">                    sides are a common source of degenerate qauds.</span>
<span class="cm">  input_mesh - [in] If NULL, then the returned mesh is created</span>
<span class="cm">       by a class to new ON_Mesh().  If not null, then this</span>
<span class="cm">       mesh will be used to store the conrol polygon.</span>
<span class="cm">Returns:</span>
<span class="cm">  If successful, a pointer to a mesh.</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_Mesh</span><span class="o">*</span> <span class="nf">ON_ControlPolygonMesh</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">ON_NurbsSurface</span><span class="o">&amp;</span> <span class="n">nurbs_surface</span><span class="p">,</span>
          <span class="kt">bool</span> <span class="n">bCleanMesh</span><span class="p">,</span>
          <span class="n">ON_Mesh</span><span class="o">*</span> <span class="n">input_mesh</span> <span class="o">=</span> <span class="nb">NULL</span>
          <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Finds the unit normal to the triangle</span>
<span class="cm">Parameters:</span>
<span class="cm">  A - [in] triangle corner</span>
<span class="cm">  B - [in] triangle corner</span>
<span class="cm">  C - [in] triangle corner</span>
<span class="cm">Returns:</span>
<span class="cm">  Unit normal</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="n">ON_3dVector</span> <span class="nf">ON_TriangleNormal</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">B</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">C</span>
        <span class="p">);</span>


<span class="cm">/*</span>
<span class="cm">Description:</span>
<span class="cm">  Finds the unit normal to the triangle</span>
<span class="cm">Parameters:</span>
<span class="cm">  A - [in] triangle corner</span>
<span class="cm">  B - [in] triangle corner</span>
<span class="cm">  C - [in] triangle corner</span>
<span class="cm">  a - [out] must not be null</span>
<span class="cm">  b - [out] must not be null</span>
<span class="cm">  c - [out] must not be null</span>
<span class="cm">  d - [out] must not be null</span>
<span class="cm">    The equation of the plane is a*x + b*y + c*z + d = 0</span>
<span class="cm">  ev_tol - [out]</span>
<span class="cm">    If ev_tol is not null, then it is the maximum absolute</span>
<span class="cm">    value of the plane equation evaluated at A,B,C.  Mathematically,</span>
<span class="cm">    ev_tol is zero.  Since these computations are performed with</span>
<span class="cm">    finite precision doubles, ev_tol is generally not zero.</span>
<span class="cm">Returns:</span>
<span class="cm">  Unit normal</span>
<span class="cm">*/</span>
<span class="n">ON_DECL</span>
<span class="kt">bool</span> <span class="nf">ON_GetTrianglePlaneEquation</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">B</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">ON_3dPoint</span><span class="o">&amp;</span> <span class="n">C</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">d</span><span class="p">,</span>
        <span class="kt">double</span><span class="o">*</span> <span class="n">evaluation_tol</span>
        <span class="p">);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_nurbscurve.h.html" class="btn btn-neutral float-right" title="File opennurbs_nurbscurve.h" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_surface_3rdparty_opennurbs_opennurbs_mesh.h.html" class="btn btn-neutral float-left" title="File opennurbs_mesh.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>