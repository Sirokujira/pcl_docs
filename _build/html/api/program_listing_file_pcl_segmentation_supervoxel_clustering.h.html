

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File supervoxel_clustering.h &mdash; pcl 1.9.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/modified_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File supervoxel_clustering.hpp" href="file_pcl_segmentation_impl_supervoxel_clustering.hpp.html" />
    <link rel="prev" title="File supervoxel_clustering.h" href="file_pcl_segmentation_supervoxel_clustering.h.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pcl
          

          
          </a>

          
            
            
              <div class="version">
                1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pcl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Library API</a> &raquo;</li>
        
          <li><a href="file_pcl_segmentation_supervoxel_clustering.h.html">File supervoxel_clustering.h</a> &raquo;</li>
        
      <li>Program Listing for File supervoxel_clustering.h</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_pcl_segmentation_supervoxel_clustering.h.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-supervoxel-clustering-h">
<span id="program-listing-file-pcl-segmentation-supervoxel-clustering-h"></span><h1>Program Listing for File supervoxel_clustering.h<a class="headerlink" href="#program-listing-for-file-supervoxel-clustering-h" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_pcl_segmentation_supervoxel_clustering.h.html#file-pcl-segmentation-supervoxel-clustering-h"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">pcl\segmentation\supervoxel_clustering.h</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Software License Agreement (BSD License)</span>
<span class="cm"> *</span>
<span class="cm"> *  Point Cloud Library (PCL) - www.pointclouds.org</span>
<span class="cm"> *</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above</span>
<span class="cm"> *     copyright notice, this list of conditions and the following</span>
<span class="cm"> *     disclaimer in the documentation and/or other materials provided</span>
<span class="cm"> *     with the distribution.</span>
<span class="cm"> *   * Neither the name of Willow Garage, Inc. nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> *  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="cm"> *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE</span>
<span class="cm"> *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<span class="cm"> *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</span>
<span class="cm"> *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<span class="cm"> *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="cm"> *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN</span>
<span class="cm"> *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> *  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> * Author : jpapon@gmail.com</span>
<span class="cm"> * Email  : jpapon@gmail.com</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;boost/version.hpp&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;pcl/features/normal_3d.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/pcl_base.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/point_cloud.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/point_types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/octree/octree_search.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/octree/octree_pointcloud_adjacency.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/search/search.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/segmentation/boost.h&gt;</span><span class="cp"></span>



<span class="c1">//DEBUG TODO REMOVE</span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/common/time.h&gt;</span><span class="cp"></span>


<span class="k">namespace</span> <span class="n">pcl</span>
<span class="p">{</span>
  <span class="cm">/** \brief Supervoxel container class - stores a cluster extracted using supervoxel clustering</span>
<span class="cm">   */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">Supervoxel</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">Supervoxel</span> <span class="p">()</span> <span class="o">:</span>
        <span class="n">voxels_</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="p">()),</span>
        <span class="n">normals_</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">Normal</span><span class="o">&gt;</span> <span class="p">())</span>
        <span class="p">{</span>  <span class="p">}</span>

      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

      <span class="cm">/** \brief Gets the centroid of the supervoxel</span>
<span class="cm">       *  \param[out] centroid_arg centroid of the supervoxel</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">getCentroidPoint</span> <span class="p">(</span><span class="n">PointXYZRGBA</span> <span class="o">&amp;</span><span class="n">centroid_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">centroid_arg</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Gets the point normal for the supervoxel</span>
<span class="cm">       * \param[out] normal_arg Point normal of the supervoxel</span>
<span class="cm">       * \note This isn&#39;t an average, it is a normal computed using all of the voxels in the supervoxel as support</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">getCentroidPointNormal</span> <span class="p">(</span><span class="n">PointNormal</span> <span class="o">&amp;</span><span class="n">normal_arg</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">normal_arg</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
        <span class="n">normal_arg</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
        <span class="n">normal_arg</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
        <span class="n">normal_arg</span><span class="p">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="n">normal_</span><span class="p">.</span><span class="n">normal_x</span><span class="p">;</span>
        <span class="n">normal_arg</span><span class="p">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="n">normal_</span><span class="p">.</span><span class="n">normal_y</span><span class="p">;</span>
        <span class="n">normal_arg</span><span class="p">.</span><span class="n">normal_z</span> <span class="o">=</span> <span class="n">normal_</span><span class="p">.</span><span class="n">normal_z</span><span class="p">;</span>
        <span class="n">normal_arg</span><span class="p">.</span><span class="n">curvature</span> <span class="o">=</span> <span class="n">normal_</span><span class="p">.</span><span class="n">curvature</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/** \brief The normal calculated for the voxels contained in the supervoxel */</span>
      <span class="n">pcl</span><span class="o">::</span><span class="n">Normal</span> <span class="n">normal_</span><span class="p">;</span>
      <span class="cm">/** \brief The centroid of the supervoxel - average voxel */</span>
      <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGBA</span> <span class="n">centroid_</span><span class="p">;</span>
      <span class="cm">/** \brief A Pointcloud of the voxels in the supervoxel */</span>
      <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">voxels_</span><span class="p">;</span>
      <span class="cm">/** \brief A Pointcloud of the normals for the points in the supervoxel */</span>
      <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">Normal</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">normals_</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
      <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>
  <span class="p">};</span>

  <span class="cm">/** \brief Implements a supervoxel algorithm based on voxel structure, normals, and rgb values</span>
<span class="cm">   *   \note Supervoxels are oversegmented volumetric patches (usually surfaces)</span>
<span class="cm">   *   \note Usually, color isn&#39;t needed (and can be detrimental)- spatial structure is mainly used</span>
<span class="cm">    * - J. Papon, A. Abramov, M. Schoeler, F. Woergoetter</span>
<span class="cm">    *   Voxel Cloud Connectivity Segmentation - Supervoxels from PointClouds</span>
<span class="cm">    *   In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR) 2013</span>
<span class="cm">    *  \ingroup segmentation</span>
<span class="cm">    *  \author Jeremie Papon (jpapon@gmail.com)</span>
<span class="cm">    */</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PointT</span><span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">PCL_EXPORTS</span> <span class="nl">SupervoxelClustering</span> <span class="p">:</span> <span class="k">public</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PCLBase</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">//Forward declaration of friended helper class</span>
    <span class="k">class</span> <span class="nc">SupervoxelHelper</span><span class="p">;</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">SupervoxelHelper</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="cm">/** \brief VoxelData is a structure used for storing data within a pcl::octree::OctreePointCloudAdjacencyContainer</span>
<span class="cm">       *  \note It stores xyz, rgb, normal, distance, an index, and an owner.</span>
<span class="cm">       */</span>
      <span class="k">class</span> <span class="nc">VoxelData</span>
      <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
          <span class="n">VoxelData</span> <span class="p">()</span><span class="o">:</span>
            <span class="n">xyz_</span> <span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span>
            <span class="n">rgb_</span> <span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span>
            <span class="n">normal_</span> <span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span>
            <span class="n">curvature_</span> <span class="p">(</span><span class="mf">0.0f</span><span class="p">),</span>
            <span class="n">owner_</span> <span class="p">(</span><span class="k">nullptr</span><span class="p">)</span>
            <span class="p">{}</span>

          <span class="cm">/** \brief Gets the data of in the form of a point</span>
<span class="cm">           *  \param[out] point_arg Will contain the point value of the voxeldata</span>
<span class="cm">           */</span>
          <span class="kt">void</span>
          <span class="n">getPoint</span> <span class="p">(</span><span class="n">PointT</span> <span class="o">&amp;</span><span class="n">point_arg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

          <span class="cm">/** \brief Gets the data of in the form of a normal</span>
<span class="cm">           *  \param[out] normal_arg Will contain the normal value of the voxeldata</span>
<span class="cm">           */</span>
          <span class="kt">void</span>
          <span class="nf">getNormal</span> <span class="p">(</span><span class="n">Normal</span> <span class="o">&amp;</span><span class="n">normal_arg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

          <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">xyz_</span><span class="p">;</span>
          <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">rgb_</span><span class="p">;</span>
          <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span> <span class="n">normal_</span><span class="p">;</span>
          <span class="kt">float</span> <span class="n">curvature_</span><span class="p">;</span>
          <span class="kt">float</span> <span class="n">distance_</span><span class="p">;</span>
          <span class="kt">int</span> <span class="n">idx_</span><span class="p">;</span>
          <span class="n">SupervoxelHelper</span><span class="o">*</span> <span class="n">owner_</span><span class="p">;</span>

        <span class="k">public</span><span class="o">:</span>
          <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>
      <span class="p">};</span>

      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">octree</span><span class="o">::</span><span class="n">OctreePointCloudAdjacencyContainer</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">VoxelData</span><span class="o">&gt;</span> <span class="n">LeafContainerT</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">LeafContainerT</span><span class="o">*&gt;</span> <span class="n">LeafVectorT</span><span class="p">;</span>

      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="n">PointCloudT</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">Normal</span><span class="o">&gt;</span> <span class="n">NormalCloudT</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">octree</span><span class="o">::</span><span class="n">OctreePointCloudAdjacency</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">LeafContainerT</span><span class="o">&gt;</span> <span class="n">OctreeAdjacencyT</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">octree</span><span class="o">::</span><span class="n">OctreePointCloudSearch</span> <span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="n">OctreeSearchT</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">pcl</span><span class="o">::</span><span class="n">search</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span> <span class="n">KdTreeT</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">IndicesPtr</span><span class="p">;</span>

      <span class="k">using</span> <span class="n">PCLBase</span> <span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">initCompute</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">PCLBase</span> <span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">deinitCompute</span><span class="p">;</span>
      <span class="k">using</span> <span class="n">PCLBase</span> <span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">input_</span><span class="p">;</span>

      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">adjacency_list</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">setS</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">setS</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">undirectedS</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">VoxelAdjacencyList</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">VoxelAdjacencyList</span><span class="o">::</span><span class="n">vertex_descriptor</span> <span class="n">VoxelID</span><span class="p">;</span>
      <span class="k">typedef</span> <span class="n">VoxelAdjacencyList</span><span class="o">::</span><span class="n">edge_descriptor</span> <span class="n">EdgeID</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>

      <span class="cm">/** \brief Constructor that sets default values for member variables.</span>
<span class="cm">       *  \param[in] voxel_resolution The resolution (in meters) of voxels used</span>
<span class="cm">       *  \param[in] seed_resolution The average size (in meters) of resulting supervoxels</span>
<span class="cm">       */</span>
      <span class="n">SupervoxelClustering</span> <span class="p">(</span><span class="kt">float</span> <span class="n">voxel_resolution</span><span class="p">,</span> <span class="kt">float</span> <span class="n">seed_resolution</span><span class="p">);</span>

      <span class="p">[[</span><span class="n">deprecated</span><span class="p">(</span><span class="s">&quot;constructor with flag for using the single camera transform is deprecated. Default behavior is now to use the transform for organized clouds, and not use it for unorganized. Use setUseSingleCameraTransform() to override the defaults.&quot;</span><span class="p">)]]</span>
      <span class="n">SupervoxelClustering</span> <span class="p">(</span><span class="kt">float</span> <span class="n">voxel_resolution</span><span class="p">,</span> <span class="kt">float</span> <span class="n">seed_resolution</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">:</span> <span class="n">SupervoxelClustering</span> <span class="p">(</span><span class="n">voxel_resolution</span><span class="p">,</span> <span class="n">seed_resolution</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

      <span class="cm">/** \brief This destructor destroys the cloud, normals and search method used for</span>
<span class="cm">        * finding neighbors. In other words it frees memory.</span>
<span class="cm">        */</span>

      <span class="o">~</span><span class="n">SupervoxelClustering</span> <span class="p">();</span>

      <span class="cm">/** \brief Set the resolution of the octree voxels */</span>
      <span class="kt">void</span>
      <span class="nf">setVoxelResolution</span> <span class="p">(</span><span class="kt">float</span> <span class="n">resolution</span><span class="p">);</span>

      <span class="cm">/** \brief Get the resolution of the octree voxels */</span>
      <span class="kt">float</span>
      <span class="nf">getVoxelResolution</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Set the resolution of the octree seed voxels */</span>
      <span class="kt">void</span>
      <span class="nf">setSeedResolution</span> <span class="p">(</span><span class="kt">float</span> <span class="n">seed_resolution</span><span class="p">);</span>

      <span class="cm">/** \brief Get the resolution of the octree seed voxels */</span>
      <span class="kt">float</span>
      <span class="nf">getSeedResolution</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Set the importance of color for supervoxels */</span>
      <span class="kt">void</span>
      <span class="nf">setColorImportance</span> <span class="p">(</span><span class="kt">float</span> <span class="n">val</span><span class="p">);</span>

      <span class="cm">/** \brief Set the importance of spatial distance for supervoxels */</span>
      <span class="kt">void</span>
      <span class="nf">setSpatialImportance</span> <span class="p">(</span><span class="kt">float</span> <span class="n">val</span><span class="p">);</span>

      <span class="cm">/** \brief Set the importance of scalar normal product for supervoxels */</span>
      <span class="kt">void</span>
      <span class="nf">setNormalImportance</span> <span class="p">(</span><span class="kt">float</span> <span class="n">val</span><span class="p">);</span>

      <span class="cm">/** \brief Set whether or not to use the single camera transform</span>
<span class="cm">       *  \note By default it will be used for organized clouds, but not for unorganized - this parameter will override that behavior</span>
<span class="cm">       *  The single camera transform scales bin size so that it increases exponentially with depth (z dimension).</span>
<span class="cm">       *  This is done to account for the decreasing point density found with depth when using an RGB-D camera.</span>
<span class="cm">       *  Without the transform, beyond a certain depth adjacency of voxels breaks down unless the voxel size is set to a large value.</span>
<span class="cm">       *  Using the transform allows preserving detail up close, while allowing adjacency at distance.</span>
<span class="cm">       *  The specific transform used here is:</span>
<span class="cm">       *  x /= z; y /= z; z = ln(z);</span>
<span class="cm">       *  This transform is applied when calculating the octree bins in OctreePointCloudAdjacency</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">setUseSingleCameraTransform</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">val</span><span class="p">);</span>

      <span class="cm">/** \brief This method launches the segmentation algorithm and returns the supervoxels that were</span>
<span class="cm">       * obtained during the segmentation.</span>
<span class="cm">       * \param[out] supervoxel_clusters A map of labels to pointers to supervoxel structures</span>
<span class="cm">       */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">extract</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="k">typename</span> <span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">supervoxel_clusters</span><span class="p">);</span>

      <span class="cm">/** \brief This method sets the cloud to be supervoxelized</span>
<span class="cm">       * \param[in] cloud The cloud to be supervoxelize</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">setInputCloud</span> <span class="p">(</span><span class="k">const</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">ConstPtr</span><span class="o">&amp;</span> <span class="n">cloud</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

      <span class="cm">/** \brief This method sets the normals to be used for supervoxels (should be same size as input cloud)</span>
<span class="cm">      * \param[in] normal_cloud The input normals</span>
<span class="cm">      */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">setNormalCloud</span> <span class="p">(</span><span class="k">typename</span> <span class="n">NormalCloudT</span><span class="o">::</span><span class="n">ConstPtr</span> <span class="n">normal_cloud</span><span class="p">);</span>

      <span class="cm">/** \brief This method refines the calculated supervoxels - may only be called after extract</span>
<span class="cm">       * \param[in] num_itr The number of iterations of refinement to be done (2 or 3 is usually sufficient)</span>
<span class="cm">       * \param[out] supervoxel_clusters The resulting refined supervoxels</span>
<span class="cm">       */</span>
      <span class="k">virtual</span> <span class="kt">void</span>
      <span class="nf">refineSupervoxels</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num_itr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="k">typename</span> <span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">supervoxel_clusters</span><span class="p">);</span>

      <span class="c1">////////////////////////////////////////////////////////////</span>
      <span class="cm">/** \brief Returns an RGB colorized cloud showing superpixels</span>
<span class="cm">        * Otherwise it returns an empty pointer.</span>
<span class="cm">        * Points that belong to the same supervoxel have the same color.</span>
<span class="cm">        * But this function doesn&#39;t guarantee that different segments will have different</span>
<span class="cm">        * color(it&#39;s random). Points that are unlabeled will be black</span>
<span class="cm">        * \note This will expand the label_colors_ vector so that it can accommodate all labels</span>
<span class="cm">        */</span>
      <span class="p">[[</span><span class="n">deprecated</span><span class="p">(</span><span class="s">&quot;use getLabeledCloud() instead. An example of how to display and save with colorized labels can be found in examples/segmentation/example_supervoxels.cpp&quot;</span><span class="p">)]]</span>
      <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointXYZRGBA</span><span class="o">&gt;::</span><span class="n">Ptr</span>
      <span class="n">getColoredCloud</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointXYZRGBA</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointXYZRGBA</span><span class="o">&gt;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Returns a deep copy of the voxel centroid cloud */</span>
      <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span>
      <span class="n">getVoxelCentroidCloud</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Returns labeled cloud</span>
<span class="cm">        * Points that belong to the same supervoxel have the same label.</span>
<span class="cm">        * Labels for segments start from 1, unlabled points have label 0</span>
<span class="cm">        */</span>
      <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointXYZL</span><span class="o">&gt;::</span><span class="n">Ptr</span>
      <span class="n">getLabeledCloud</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Returns an RGB colorized voxelized cloud showing superpixels</span>
<span class="cm">       * Otherwise it returns an empty pointer.</span>
<span class="cm">       * Points that belong to the same supervoxel have the same color.</span>
<span class="cm">       * But this function doesn&#39;t guarantee that different segments will have different</span>
<span class="cm">       * color(it&#39;s random). Points that are unlabeled will be black</span>
<span class="cm">       * \note This will expand the label_colors_ vector so that it can accommodate all labels</span>
<span class="cm">       */</span>
      <span class="p">[[</span><span class="n">deprecated</span><span class="p">(</span><span class="s">&quot;use getLabeledVoxelCloud() instead. An example of how to display and save with colorized labels can be found in examples/segmentation/example_supervoxels.cpp&quot;</span><span class="p">)]]</span>
      <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGBA</span><span class="o">&gt;::</span><span class="n">Ptr</span>
      <span class="n">getColoredVoxelCloud</span> <span class="p">()</span> <span class="k">const</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointXYZRGBA</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointXYZRGBA</span><span class="o">&gt;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="cm">/** \brief Returns labeled voxelized cloud</span>
<span class="cm">       * Points that belong to the same supervoxel have the same label.</span>
<span class="cm">       * Labels for segments start from 1, unlabled points have label 0</span>
<span class="cm">       */</span>
      <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZL</span><span class="o">&gt;::</span><span class="n">Ptr</span>
      <span class="n">getLabeledVoxelCloud</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Gets the adjacency list (Boost Graph library) which gives connections between supervoxels</span>
<span class="cm">       *  \param[out] adjacency_list_arg BGL graph where supervoxel labels are vertices, edges are touching relationships</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">getSupervoxelAdjacencyList</span> <span class="p">(</span><span class="n">VoxelAdjacencyList</span> <span class="o">&amp;</span><span class="n">adjacency_list_arg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Get a multimap which gives supervoxel adjacency</span>
<span class="cm">       *  \param[out] label_adjacency Multi-Map which maps a supervoxel label to all adjacent supervoxel labels</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">getSupervoxelAdjacency</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">label_adjacency</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Static helper function which returns a pointcloud of normals for the input supervoxels</span>
<span class="cm">       *  \param[in] supervoxel_clusters Supervoxel cluster map coming from this class</span>
<span class="cm">       *  \returns Cloud of PointNormals of the supervoxels</span>
<span class="cm">       *</span>
<span class="cm">       */</span>
      <span class="k">static</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointNormal</span><span class="o">&gt;::</span><span class="n">Ptr</span>
      <span class="n">makeSupervoxelNormalCloud</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="k">typename</span> <span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">supervoxel_clusters</span><span class="p">);</span>

      <span class="cm">/** \brief Returns the current maximum (highest) label */</span>
      <span class="kt">int</span>
      <span class="nf">getMaxLabel</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
      <span class="cm">/** \brief This method simply checks if it is possible to execute the segmentation algorithm with</span>
<span class="cm">        * the current settings. If it is possible then it returns true.</span>
<span class="cm">        */</span>
      <span class="k">virtual</span> <span class="kt">bool</span>
      <span class="n">prepareForSegmentation</span> <span class="p">();</span>

      <span class="cm">/** \brief This selects points to use as initial supervoxel centroids</span>
<span class="cm">       *  \param[out] seed_indices The selected leaf indices</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">selectInitialSupervoxelSeeds</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">seed_indices</span><span class="p">);</span>

      <span class="cm">/** \brief This method creates the internal supervoxel helpers based on the provided seed points</span>
<span class="cm">       *  \param[in] seed_indices Indices of the leaves to use as seeds</span>
<span class="cm">       */</span>
      <span class="kt">void</span>
      <span class="nf">createSupervoxelHelpers</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">seed_indices</span><span class="p">);</span>

      <span class="cm">/** \brief This performs the superpixel evolution */</span>
      <span class="kt">void</span>
      <span class="nf">expandSupervoxels</span> <span class="p">(</span><span class="kt">int</span> <span class="n">depth</span><span class="p">);</span>

      <span class="cm">/** \brief This sets the data of the voxels in the tree */</span>
      <span class="kt">void</span>
      <span class="nf">computeVoxelData</span> <span class="p">();</span>

      <span class="cm">/** \brief Reseeds the supervoxels by finding the voxel closest to current centroid */</span>
      <span class="kt">void</span>
      <span class="nf">reseedSupervoxels</span> <span class="p">();</span>

      <span class="cm">/** \brief Constructs the map of supervoxel clusters from the internal supervoxel helpers */</span>
      <span class="kt">void</span>
      <span class="nf">makeSupervoxels</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="k">typename</span> <span class="n">Supervoxel</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">supervoxel_clusters</span><span class="p">);</span>

      <span class="cm">/** \brief Stores the resolution used in the octree */</span>
      <span class="kt">float</span> <span class="n">resolution_</span><span class="p">;</span>

      <span class="cm">/** \brief Stores the resolution used to seed the superpixels */</span>
      <span class="kt">float</span> <span class="n">seed_resolution_</span><span class="p">;</span>

      <span class="cm">/** \brief Distance function used for comparing voxelDatas */</span>
      <span class="kt">float</span>
      <span class="nf">voxelDataDistance</span> <span class="p">(</span><span class="k">const</span> <span class="n">VoxelData</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">VoxelData</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

      <span class="cm">/** \brief Transform function used to normalize voxel density versus distance from camera */</span>
      <span class="kt">void</span>
      <span class="nf">transformFunction</span> <span class="p">(</span><span class="n">PointT</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

      <span class="cm">/** \brief Contains a KDtree for the voxelized cloud */</span>
      <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">search</span><span class="o">::</span><span class="n">KdTree</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">voxel_kdtree_</span><span class="p">;</span>

      <span class="cm">/** \brief Octree Adjacency structure with leaves at voxel resolution */</span>
      <span class="k">typename</span> <span class="n">OctreeAdjacencyT</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">adjacency_octree_</span><span class="p">;</span>

      <span class="cm">/** \brief Contains the Voxelized centroid Cloud */</span>
      <span class="k">typename</span> <span class="n">PointCloudT</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">voxel_centroid_cloud_</span><span class="p">;</span>

      <span class="cm">/** \brief Contains the Voxelized centroid Cloud */</span>
      <span class="k">typename</span> <span class="n">NormalCloudT</span><span class="o">::</span><span class="n">ConstPtr</span> <span class="n">input_normals_</span><span class="p">;</span>

      <span class="cm">/** \brief Importance of color in clustering */</span>
      <span class="kt">float</span> <span class="n">color_importance_</span><span class="p">;</span>
      <span class="cm">/** \brief Importance of distance from seed center in clustering */</span>
      <span class="kt">float</span> <span class="n">spatial_importance_</span><span class="p">;</span>
      <span class="cm">/** \brief Importance of similarity in normals for clustering */</span>
      <span class="kt">float</span> <span class="n">normal_importance_</span><span class="p">;</span>

      <span class="cm">/** \brief Whether or not to use the transform compressing depth in Z</span>
<span class="cm">       *  This is only checked if it has been manually set by the user.</span>
<span class="cm">       *  The default behavior is to use the transform for organized, and not for unorganized.</span>
<span class="cm">       */</span>
      <span class="kt">bool</span> <span class="n">use_single_camera_transform_</span><span class="p">;</span>
      <span class="cm">/** \brief Whether to use default transform behavior or not */</span>
      <span class="kt">bool</span> <span class="n">use_default_transform_behaviour_</span><span class="p">;</span>

      <span class="cm">/** \brief Internal storage class for supervoxels</span>
<span class="cm">       * \note Stores pointers to leaves of clustering internal octree,</span>
<span class="cm">       * \note so should not be used outside of clustering class</span>
<span class="cm">       */</span>
      <span class="k">class</span> <span class="nc">SupervoxelHelper</span>
      <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
          <span class="cm">/** \brief Comparator for LeafContainerT pointers - used for sorting set of leaves</span>
<span class="cm">           * \note Compares by index in the overall leaf_vector. Order isn&#39;t important, so long as it is fixed.</span>
<span class="cm">           */</span>
          <span class="k">struct</span> <span class="n">compareLeaves</span>
          <span class="p">{</span>
            <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">LeafContainerT</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">left</span><span class="p">,</span> <span class="n">LeafContainerT</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">right</span><span class="p">)</span> <span class="k">const</span>
            <span class="p">{</span>
              <span class="k">const</span> <span class="n">VoxelData</span><span class="o">&amp;</span> <span class="n">leaf_data_left</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">getData</span> <span class="p">();</span>
              <span class="k">const</span> <span class="n">VoxelData</span><span class="o">&amp;</span> <span class="n">leaf_data_right</span> <span class="o">=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">getData</span> <span class="p">();</span>
              <span class="k">return</span> <span class="n">leaf_data_left</span><span class="p">.</span><span class="n">idx_</span> <span class="o">&lt;</span> <span class="n">leaf_data_right</span><span class="p">.</span><span class="n">idx_</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">};</span>
          <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">LeafContainerT</span><span class="o">*</span><span class="p">,</span> <span class="k">typename</span> <span class="n">SupervoxelHelper</span><span class="o">::</span><span class="n">compareLeaves</span><span class="o">&gt;</span> <span class="n">LeafSetT</span><span class="p">;</span>
          <span class="k">typedef</span> <span class="k">typename</span> <span class="n">LeafSetT</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iterator</span><span class="p">;</span>
          <span class="k">typedef</span> <span class="k">typename</span> <span class="n">LeafSetT</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">const_iterator</span><span class="p">;</span>

          <span class="n">SupervoxelHelper</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">label</span><span class="p">,</span> <span class="n">SupervoxelClustering</span><span class="o">*</span> <span class="n">parent_arg</span><span class="p">)</span><span class="o">:</span>
            <span class="n">label_</span> <span class="p">(</span><span class="n">label</span><span class="p">),</span>
            <span class="n">parent_</span> <span class="p">(</span><span class="n">parent_arg</span><span class="p">)</span>
          <span class="p">{</span> <span class="p">}</span>

          <span class="kt">void</span>
          <span class="n">addLeaf</span> <span class="p">(</span><span class="n">LeafContainerT</span><span class="o">*</span> <span class="n">leaf_arg</span><span class="p">);</span>

          <span class="kt">void</span>
          <span class="nf">removeLeaf</span> <span class="p">(</span><span class="n">LeafContainerT</span><span class="o">*</span> <span class="n">leaf_arg</span><span class="p">);</span>

          <span class="kt">void</span>
          <span class="nf">removeAllLeaves</span> <span class="p">();</span>

          <span class="kt">void</span>
          <span class="nf">expand</span> <span class="p">();</span>

          <span class="kt">void</span>
          <span class="nf">refineNormals</span> <span class="p">();</span>

          <span class="kt">void</span>
          <span class="nf">updateCentroid</span> <span class="p">();</span>

          <span class="kt">void</span>
          <span class="nf">getVoxels</span> <span class="p">(</span><span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="o">&amp;</span><span class="n">voxels</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

          <span class="kt">void</span>
          <span class="nf">getNormals</span> <span class="p">(</span><span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">Normal</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="o">&amp;</span><span class="n">normals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

          <span class="k">typedef</span> <span class="nf">float</span> <span class="p">(</span><span class="n">SupervoxelClustering</span><span class="o">::*</span><span class="n">DistFuncPtr</span><span class="p">)(</span><span class="k">const</span> <span class="n">VoxelData</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">VoxelData</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>

          <span class="kt">uint32_t</span>
          <span class="nf">getLabel</span> <span class="p">()</span> <span class="k">const</span>
          <span class="p">{</span> <span class="k">return</span> <span class="n">label_</span><span class="p">;</span> <span class="p">}</span>

          <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span>
          <span class="n">getNormal</span> <span class="p">()</span> <span class="k">const</span>
          <span class="p">{</span> <span class="k">return</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">normal_</span><span class="p">;</span> <span class="p">}</span>

          <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span>
          <span class="n">getRGB</span> <span class="p">()</span> <span class="k">const</span>
          <span class="p">{</span> <span class="k">return</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">rgb_</span><span class="p">;</span> <span class="p">}</span>

          <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span>
          <span class="n">getXYZ</span> <span class="p">()</span> <span class="k">const</span>
          <span class="p">{</span> <span class="k">return</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">xyz_</span><span class="p">;}</span>

          <span class="kt">void</span>
          <span class="n">getXYZ</span> <span class="p">(</span><span class="kt">float</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">)</span> <span class="k">const</span>
          <span class="p">{</span> <span class="n">x</span><span class="o">=</span><span class="n">centroid_</span><span class="p">.</span><span class="n">xyz_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">y</span><span class="o">=</span><span class="n">centroid_</span><span class="p">.</span><span class="n">xyz_</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">z</span><span class="o">=</span><span class="n">centroid_</span><span class="p">.</span><span class="n">xyz_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="p">}</span>

          <span class="kt">void</span>
          <span class="n">getRGB</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">&amp;</span><span class="n">rgba</span><span class="p">)</span> <span class="k">const</span>
          <span class="p">{</span>
            <span class="n">rgba</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">centroid_</span><span class="p">.</span><span class="n">rgb_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
                   <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">centroid_</span><span class="p">.</span><span class="n">rgb_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
                   <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">centroid_</span><span class="p">.</span><span class="n">rgb_</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
          <span class="p">}</span>

          <span class="kt">void</span>
          <span class="n">getNormal</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">Normal</span> <span class="o">&amp;</span><span class="n">normal_arg</span><span class="p">)</span> <span class="k">const</span>
          <span class="p">{</span>
            <span class="n">normal_arg</span><span class="p">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">normal_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">normal_arg</span><span class="p">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">normal_</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">normal_arg</span><span class="p">.</span><span class="n">normal_z</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">normal_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">normal_arg</span><span class="p">.</span><span class="n">curvature</span> <span class="o">=</span> <span class="n">centroid_</span><span class="p">.</span><span class="n">curvature_</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="kt">void</span>
          <span class="n">getNeighborLabels</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">neighbor_labels</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

          <span class="n">VoxelData</span>
          <span class="nf">getCentroid</span> <span class="p">()</span> <span class="k">const</span>
          <span class="p">{</span> <span class="k">return</span> <span class="n">centroid_</span><span class="p">;</span> <span class="p">}</span>

          <span class="kt">size_t</span>
          <span class="nf">size</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">leaves_</span><span class="p">.</span><span class="n">size</span> <span class="p">();</span> <span class="p">}</span>
        <span class="k">private</span><span class="o">:</span>
          <span class="c1">//Stores leaves</span>
          <span class="n">LeafSetT</span> <span class="n">leaves_</span><span class="p">;</span>
          <span class="kt">uint32_t</span> <span class="n">label_</span><span class="p">;</span>
          <span class="n">VoxelData</span> <span class="n">centroid_</span><span class="p">;</span>
          <span class="n">SupervoxelClustering</span><span class="o">*</span> <span class="n">parent_</span><span class="p">;</span>
        <span class="k">public</span><span class="o">:</span>
          <span class="c1">//Type VoxelData may have fixed-size Eigen objects inside</span>
          <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>
      <span class="p">};</span>

      <span class="c1">//Make boost::ptr_list can access the private class SupervoxelHelper</span>
<span class="cp">#if BOOST_VERSION &gt;= 107000</span>
      <span class="k">friend</span> <span class="kt">void</span> <span class="n">boost</span><span class="o">::</span><span class="n">checked_delete</span><span class="o">&lt;&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">SupervoxelClustering</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">SupervoxelHelper</span> <span class="o">*</span><span class="p">)</span> <span class="n">BOOST_NOEXCEPT</span><span class="p">;</span>
<span class="cp">#else</span>
      <span class="k">friend</span> <span class="kt">void</span> <span class="n">boost</span><span class="o">::</span><span class="n">checked_delete</span><span class="o">&lt;&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="k">typename</span> <span class="n">pcl</span><span class="o">::</span><span class="n">SupervoxelClustering</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;::</span><span class="n">SupervoxelHelper</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>

      <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">ptr_list</span><span class="o">&lt;</span><span class="n">SupervoxelHelper</span><span class="o">&gt;</span> <span class="n">HelperListT</span><span class="p">;</span>
      <span class="n">HelperListT</span> <span class="n">supervoxel_helpers_</span><span class="p">;</span>

      <span class="c1">//TODO DEBUG REMOVE</span>
      <span class="n">StopWatch</span> <span class="n">timer_</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>

  <span class="p">};</span>

<span class="p">}</span>

<span class="cp">#ifdef PCL_NO_PRECOMPILE</span>
<span class="cp">#include</span> <span class="cpf">&lt;pcl/segmentation/impl/supervoxel_clustering.hpp&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_pcl_segmentation_impl_supervoxel_clustering.hpp.html" class="btn btn-neutral float-right" title="File supervoxel_clustering.hpp" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_pcl_segmentation_supervoxel_clustering.h.html" class="btn btn-neutral float-left" title="File supervoxel_clustering.h" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, open perception foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>